<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.2.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css"><script src="/lib/pace/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"wangng.com",root:"/",scheme:"Pisces",version:"7.7.2",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!1,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="不经一番彻骨寒,怎得梅花扑鼻香"><meta property="og:type" content="website"><meta property="og:title" content="jackcywang&#39;s blog"><meta property="og:url" content="https://wangng.com/page/6/index.html"><meta property="og:site_name" content="jackcywang&#39;s blog"><meta property="og:description" content="不经一番彻骨寒,怎得梅花扑鼻香"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="jackcywang"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://wangng.com/page/6/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!0,isPost:!1,lang:"zh-CN"}</script><title>jackcywang's blog</title><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?8ce866754ae6c95a7238894d36ad3ab0";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div> <a href="https://github.com/jackcywang" target="_blank" rel="noopener" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#64ceaa;color:#fff;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">jackcywang's blog</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">梦想与现实只在一念之间</p></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i> 关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i> 归档</a></li></ul></nav></div></header><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://wangng.com/articles/c71d2dd7.html/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="jackcywang"><meta itemprop="description" content="不经一番彻骨寒,怎得梅花扑鼻香"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="jackcywang's blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a href="/articles/c71d2dd7.html/" class="post-title-link" itemprop="url">C++之static静态成员变量与static静态成员函数</a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-07-28 20:28:47" itemprop="dateCreated datePublished" datetime="2019-07-28T20:28:47+08:00">2019-07-28</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i></span> <span class="post-meta-item-text">Valine：</span><a title="valine" href="/articles/c71d2dd7.html/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/articles/c71d2dd7.html/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>4.7k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>4 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="static静态成员变量"><a href="#static静态成员变量" class="headerlink" title="static静态成员变量"></a>static静态成员变量</h3><p>　　对象的内存中包含了成员变量，不同的对象占用不同的内存，这使得不同对象的成员变量相互独立，它们的值不受其他对象的影响。例如有两个相同类型的对象a、b,它们都有一个成员变量m_name,那么修改 a.m_name 的值不会影响 b.m_name 的值。</p><p>　　可是有时候我们希望在多个对象之间共享数据，对象a改变了某份数据后对象b可以检测到。共享数据的典型使用场景是计数，以前面的 Student 类为例,如果我们想知道班级中共有多少名学生,就可以设置一份共享的变量，每次创建对象时让该变量加 1。</p><p>　　在C++中，我们可以使用静态成员变量来实现多个对象共享数据的目标。<font color="red" size="3">静态成员变量是一种特殊的成员变量,它被关键字static修饰</font>,如<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">float</span> score);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_total;  <span class="comment">//静态成员变量</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">    <span class="keyword">float</span> m_score;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>　　这段代码声明了一个静态成员变量 m_total，用来统计学生的人数。<strong>static成员变量属于类，不属于某个具体的对象,即使创建多个对象,也只为m_total分配一份内存，所有对象使用的都是这份内存中的数据</strong>。当某个对象修改了m_total，也会影响到其他对象。<p></p><p>static成员变量必须在类声明的外部初始化,具体形式为：<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type class::name = value;</span><br></pre></td></tr></table></figure><br>type 是变量的类型,class 是类名,name是变量名,value是初始值。将上面的 m_total 初始化：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Student::m_total = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><br>静态成员变量在初始化时不能再加static,但必须要有数据类型。<strong>被private、protected、public修饰的静态成员变量都可以用这种方式初始化。</strong><p></p> <font color="red" size="3">注意：static 成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是在（类外）初始化时分配。反过来说，没有在类外初始化的 static 成员变量不能使用。</font><p>static成员变量既可以通过对象来访问,也可以通过类来访问。请看下面的例子：<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过类访问static成员变量</span></span><br><span class="line">Student::m_total = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//通过对象来访问 static 成员变量</span></span><br><span class="line"><span class="function">Student <span class="title">stu</span><span class="params">(<span class="string">"小明"</span>, <span class="number">15</span>, <span class="number">92.5f</span>)</span></span>;</span><br><span class="line">stu.m_total = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//通过对象指针来访问 static 成员变量</span></span><br><span class="line">Student *pstu = <span class="keyword">new</span> Student(<span class="string">"李华"</span>, <span class="number">16</span>, <span class="number">96</span>);</span><br><span class="line">pstu -&gt; m_total = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><br>这三种方式是等效的。注意：static 成员变量不占用对象的内存,而是在所有对象之外开辟内存,即使不创建对象也可以访问。具体来说，static成员变量和普通的static变量类似,都在内存分区中的全局数据区分配内存。<p></p><p>下面是整个完整例子:<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">float</span> score);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_total;  <span class="comment">//静态成员变量</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">    <span class="keyword">float</span> m_score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化静态成员变量</span></span><br><span class="line"><span class="keyword">int</span> Student::m_total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Student::Student(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">float</span> score): m_name(name), m_age(age), m_score(score)&#123;</span><br><span class="line">    m_total++;  <span class="comment">//操作静态成员变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m_name&lt;&lt;<span class="string">"的年龄是"</span>&lt;&lt;m_age&lt;&lt;<span class="string">"，成绩是"</span>&lt;&lt;m_score&lt;&lt;<span class="string">"（当前共有"</span>&lt;&lt;m_total&lt;&lt;<span class="string">"名学生）"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建匿名对象</span></span><br><span class="line">    (<span class="keyword">new</span> Student(<span class="string">"小明"</span>, <span class="number">15</span>, <span class="number">90</span>)) -&gt; show();</span><br><span class="line">    (<span class="keyword">new</span> Student(<span class="string">"李磊"</span>, <span class="number">16</span>, <span class="number">80</span>)) -&gt; show();</span><br><span class="line">    (<span class="keyword">new</span> Student(<span class="string">"张华"</span>, <span class="number">16</span>, <span class="number">99</span>)) -&gt; show();</span><br><span class="line">    (<span class="keyword">new</span> Student(<span class="string">"王康"</span>, <span class="number">14</span>, <span class="number">60</span>)) -&gt; show();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">小明的年龄是<span class="number">15</span>，成绩是<span class="number">90</span>（当前共有<span class="number">1</span>名学生）</span><br><span class="line">李磊的年龄是<span class="number">16</span>，成绩是<span class="number">80</span>（当前共有<span class="number">2</span>名学生）</span><br><span class="line">张华的年龄是<span class="number">16</span>，成绩是<span class="number">99</span>（当前共有<span class="number">3</span>名学生）</span><br><span class="line">王康的年龄是<span class="number">14</span>，成绩是<span class="number">60</span>（当前共有<span class="number">4</span>名学生）</span><br></pre></td></tr></table></figure><br>本例中将 m_total 声明为静态成员变量,每次创建对象时,会调用构造函数使m_total的值加 1。之所以使用匿名对象,是因为每次创建对象后只会使用它的show()函数,不再进行其他操作。不过使用匿名对象无法回收内存,会导致内存泄露,在中大型程序中不建议使用。<p></p><h4 id="其他要点"><a href="#其他要点" class="headerlink" title="其他要点"></a>其他要点</h4><p>(1) 一个类中可以有一个或多个静态成员变量，所有的对象都共享这些静态成员变量，都可以引用它。</p><p>(2)static 成员变量和普通 static 变量一样，都在内存分区中的全局数据区分配内存，到程序结束时才释放。这就意味着，static 成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。而普通成员变量在对象创建时分配内存，在对象销毁时释放内存。</p><p>(3)静态成员变量必须初始化,而且只能在类体外进行。<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Student::m_total = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><br>初始化时可以赋初值，也可以不赋值。如果不赋值，那么会被默认初始化为 0。全局数据区的变量都有默认的初始值 0，而动态数据区（堆区、栈区）变量的默认值是不确定的，一般认为是垃圾值。<p></p><p>(4)静态成员变量既可以通过对象名访问，也可以通过类名访问，但要遵循 private、protected 和 public 关键字的访问权限限制。当通过对象名访问时，对于不同的对象，访问的是同一份内存。</p><h3 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h3><p>　　在类中,static 除了可以声明静态成员变量,还可以声明静态成员函数。普通成员函数可以访问所有成员(包括成员变量和成员函数),静态成员函数只能访问静态成员。</p><p>　　<strong>编译器在编译一个普通成员函数时,会隐式地增加一个形参this,并把当前对象的地址赋值给this,所以普通成员函数只能在创建对象后通过对象来调用，因为它需要当前对象的地址</strong>。而静态成员函数可以通过类来直接调用，编译器不会为它增加形参this,它不需要当前对象的地址，所以不管有没有创建对象,都可以调用静态成员函数。</p><p>　　普通成员变量占用对象的内存,静态成员函数没有this指针,不知道指向哪个对象,无法访问对象的成员变量,也就是说<strong>静态成员函数不能访问普通成员变量,只能访问静态成员变量</strong>。</p><p>　　普通成员函数必须通过对象才能调用，而静态成员函数没有this指针,无法在函数体内部访问某个对象，所以不能调用普通成员函数，只能调用静态成员函数.<font color="red" size="3">静态成员函数与普通成员函数的根本区别在于:普通成员函数有this指针，可以访问类中的任意成员；而静态成员函数没有this指针，只能访问静态成员(包括静态成员变量和静态成员函数)。</font></p><p>下面是一个完整的例子，该例通过静态成员函数来获得学生的总人数和总成绩：<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">float</span> score);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//声明静态成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getTotal</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">float</span> <span class="title">getPoints</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_total;  <span class="comment">//总人数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">float</span> m_points;  <span class="comment">//总成绩</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">    <span class="keyword">float</span> m_score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Student::m_total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">float</span> Student::m_points = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">Student::Student(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">float</span> score): m_name(name), m_age(age), m_score(score)&#123;</span><br><span class="line">    m_total++;</span><br><span class="line">    m_points += score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m_name&lt;&lt;<span class="string">"的年龄是"</span>&lt;&lt;m_age&lt;&lt;<span class="string">"，成绩是"</span>&lt;&lt;m_score&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义静态成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Student::getTotal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_total;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">Student::getPoints</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_points;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    (<span class="keyword">new</span> Student(<span class="string">"小明"</span>, <span class="number">15</span>, <span class="number">90.6</span>)) -&gt; show();</span><br><span class="line">    (<span class="keyword">new</span> Student(<span class="string">"李磊"</span>, <span class="number">16</span>, <span class="number">80.5</span>)) -&gt; show();</span><br><span class="line">    (<span class="keyword">new</span> Student(<span class="string">"张华"</span>, <span class="number">16</span>, <span class="number">99.0</span>)) -&gt; show();</span><br><span class="line">    (<span class="keyword">new</span> Student(<span class="string">"王康"</span>, <span class="number">14</span>, <span class="number">60.8</span>)) -&gt; show();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> total = Student::getTotal();</span><br><span class="line">    <span class="keyword">float</span> points = Student::getPoints();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"当前共有"</span>&lt;&lt;total&lt;&lt;<span class="string">"名学生，总成绩是"</span>&lt;&lt;points&lt;&lt;<span class="string">"，平均分是"</span>&lt;&lt;points/total&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">小明的年龄是<span class="number">15</span>，成绩是<span class="number">90.6</span></span><br><span class="line">李磊的年龄是<span class="number">16</span>，成绩是<span class="number">80.5</span></span><br><span class="line">张华的年龄是<span class="number">16</span>，成绩是<span class="number">99</span></span><br><span class="line">王康的年龄是<span class="number">14</span>，成绩是<span class="number">60.8</span></span><br><span class="line">当前共有<span class="number">4</span>名学生，总成绩是<span class="number">330.9</span>，平均分是<span class="number">82.725</span></span><br></pre></td></tr></table></figure><p></p><p>　　总人数m_total和总成绩m_points由各个对象累加得到,必须声明为static才能共享;getTotal()、getPoints() 分别用来获取总人数和总成绩,为了访问static成员变量,我们将这两个函数也声明为static。</p><p>　　在C++中,静态成员函数的主要目的是访问静态成员。getTotal()、getPoints()当然也可以声明为普通成员函数,但是它们都只对静态成员进行操作,加上 static 语义更加明确。</p><p>　　和静态成员变量类似,<strong>静态成员函数在声明时要加 static，在定义时不能加static</strong>。<u>静态成员函数可以通过类来调用(一般都是这样做)，也可以通过对象来调用，上例仅仅演示了如何通过类来调用。</u></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>1.<a href="http://c.biancheng.net/cpp/biancheng/view/209.html" target="_blank" rel="noopener">C++ static静态成员变量</a><br>2.<a href="http://c.biancheng.net/cpp/biancheng/view/3260.html" target="_blank" rel="noopener">C++ static静态成员函数</a></p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://wangng.com/articles/65a68211.html/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="jackcywang"><meta itemprop="description" content="不经一番彻骨寒,怎得梅花扑鼻香"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="jackcywang's blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a href="/articles/65a68211.html/" class="post-title-link" itemprop="url">C++之类的构造函数与析构函数</a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-07-25 20:28:47" itemprop="dateCreated datePublished" datetime="2019-07-25T20:28:47+08:00">2019-07-25</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i></span> <span class="post-meta-item-text">Valine：</span><a title="valine" href="/articles/65a68211.html/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/articles/65a68211.html/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>4.5k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>4 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>　　C++的目标之一就是让使用类和对象就像使用标准类型一样.然而前面所讲的内容我们还无法像初始化int,结构那样直接给成员属性进行初始化.C++类中有这样一个特殊函数,它的名字和类名相同,没有返回值,<strong>能在创建对象的时候为成员变量赋值</strong>,而不是用公有函数间接给成员变量赋值.这个函数就是构函数.</p><h4 id="构造函数的声明和定义"><a href="#构造函数的声明和定义" class="headerlink" title="构造函数的声明和定义"></a>构造函数的声明和定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">    <span class="keyword">float</span> m_score;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//声明构造函数</span></span><br><span class="line">    Student(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">float</span> score);</span><br><span class="line">    <span class="comment">//声明普通成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义构造函数</span></span><br><span class="line">Student::Student(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">float</span> score)&#123;</span><br><span class="line">    m_name = name;</span><br><span class="line">    m_age = age;</span><br><span class="line">    m_score = score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义普通成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m_name&lt;&lt;<span class="string">"的年龄是"</span>&lt;&lt;m_age&lt;&lt;<span class="string">"，成绩是"</span>&lt;&lt;m_score&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建对象时向构造函数传参</span></span><br><span class="line">    <span class="function">Student <span class="title">stu</span><span class="params">(<span class="string">"小明"</span>, <span class="number">15</span>, <span class="number">92.5f</span>)</span></span>;</span><br><span class="line">    <span class="comment">//或Student stu = Student("小明", 15, 92.5f);</span></span><br><span class="line">    stu.show();</span><br><span class="line">    <span class="comment">//创建对象时向构造函数传参</span></span><br><span class="line">    Student *pstu = <span class="keyword">new</span> Student(<span class="string">"李华"</span>, <span class="number">16</span>, <span class="number">96</span>);</span><br><span class="line">    pstu -&gt; show();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　构造函数的函数名与类名相同,且没有返回类型.在构造对象的时候,我们需直接对成员变量赋值.该例在Public中声明了Student(char *name, int age, float score)的构造函数,对Private中的三个类属性进行赋值.要想调用该构造函数，就得在创建对象的同时传递实参，并且实参由()包围，和普通的函数调用非常类似.</p><p>在栈上创建对象时，实参位于对象名后面，例如Student stu(“小明”, 15, 92.5f)；在堆上创建对象时，实参位于类名后面，例如new Student(“李华”, 16, 96)。</p><h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h4><p>默认构造函数是在程序员未重新定义构造函数时自动生成的构造函数,这个构造函数没有形参,不会对成员变量有任何操作.上例中的默认构造函数为:<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类中默认构造函数声明</span></span><br><span class="line">Student();</span><br><span class="line"><span class="comment">//默认构造函数定义</span></span><br><span class="line">Student()&#123;&#125;;</span><br></pre></td></tr></table></figure><p></p><p><font color="red" size="3">一个类必须有构造函数，要么用户自己定义，要么编译器自动生成。一旦用户自己定义了构造函数，不管有几个，也不管形参如何，编译器都不再自动生成。</font>构造函数的调用是强制性的，一旦在类中定义了构造函数，那么创建对象时就一定要调用，不调用是错误的。如果有多个重载的构造函数，那么创建对象时提供的实参必须和其中的一个构造函数匹配；反过来说，创建对象时只有一个构造函数会被调用。</p><h4 id="构造函数的初始化参数列表"><a href="#构造函数的初始化参数列表" class="headerlink" title="构造函数的初始化参数列表"></a>构造函数的初始化参数列表</h4><p>构造函数除了可以用参数为成员变量一一赋值外,还可以用初始化的参数列表来初始化.<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">    <span class="keyword">float</span> m_score;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">float</span> score);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//采用参数初始化表</span></span><br><span class="line">Student::Student(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">float</span> score): m_name(name), m_age(age), m_score(score)&#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m_name&lt;&lt;<span class="string">"的年龄是"</span>&lt;&lt;m_age&lt;&lt;<span class="string">"，成绩是"</span>&lt;&lt;m_score&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">stu</span><span class="params">(<span class="string">"小明"</span>, <span class="number">15</span>, <span class="number">92.5f</span>)</span></span>;</span><br><span class="line">    stu.show();</span><br><span class="line">    Student *pstu = <span class="keyword">new</span> Student(<span class="string">"李华"</span>, <span class="number">16</span>, <span class="number">96</span>);</span><br><span class="line">    pstu -&gt; show();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如上面的代码所示,在构造函数后加入:,并紧跟m_name(name), m_age(age), m_score(score),后面的函数体为空,这个语句的意思相当于函数体内部的m_name = name; m_age = age; m_score = score语句，也是赋值的意思。<p></p><p>使用参数初始化表并没有效率上的优势，仅仅是书写方便，尤其是成员变量较多时，这种写法非常简明了。参数初始化表可以用于全部成员变量，也可以只用于部分成员变量。下面的示例只对 m_name 使用参数初始化表，其他成员变量还是一一赋值：<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student::Student(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">float</span> score): m_name(name)&#123;</span><br><span class="line">    m_age = age;</span><br><span class="line">    m_score = score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="初始化-const-成员变量"><a href="#初始化-const-成员变量" class="headerlink" title="初始化 const 成员变量"></a>初始化 const 成员变量</h4><p>参数初始化表还有一个很重要的作用，那就是初始化 const 成员变量。<strong>初始化 const 成员变量的唯一方法就是使用参数初始化表</strong>。例如 VS/VC 不支持变长数组（数组长度不能是变量），我们自己定义了一个 VLA 类，用于模拟变长数组，请看下面的代码：<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VLA</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> m_len;</span><br><span class="line">    <span class="keyword">int</span> *m_arr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    VLA(<span class="keyword">int</span> len);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//必须使用参数初始化表来初始化 m_len</span></span><br><span class="line">VLA::VLA(<span class="keyword">int</span> len): m_len(len)&#123;</span><br><span class="line">    m_arr = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>VLA 类包含了两个成员变量，m_len 和 m_arr 指针，需要注意的是 m_len 加了 const 修饰，只能使用参数初始化表的方式赋值，如果写作下面的形式是错误的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VLA</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> m_len;</span><br><span class="line">    <span class="keyword">int</span> *m_arr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    VLA(<span class="keyword">int</span> len);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">VLA::VLA(<span class="keyword">int</span> len)&#123;</span><br><span class="line">    m_len = len;</span><br><span class="line">    m_arr = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>析构函数（Destructor）也是一种特殊的成员函数，没有返回值，不需要程序员显式调用（程序员也没法显式调用），而是在销毁对象时自动执行。构造函数的名字和类名相同，而析构函数的名字是在类名前面加一个~符号</p><blockquote><p>注意：析构函数没有参数，不能被重载，因此一个类只能有一个析构函数。如果用户没有定义，编译器会自动生成一个默认的析构函数。</p></blockquote><p>我们前面定义了一个 VLA 类来模拟变长数组，它使用一个构造函数为数组分配内存，这些内存在数组被销毁后不会自动释放，所以非常有必要再添加一个析构函数，专门用来释放已经分配的内存。请看下面的完整示例：<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VLA</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    VLA(<span class="keyword">int</span> len);  <span class="comment">//构造函数</span></span><br><span class="line">    ~VLA();  <span class="comment">//析构函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span></span>;  <span class="comment">//从控制台输入数组元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;  <span class="comment">//显示数组元素</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> *<span class="title">at</span><span class="params">(<span class="keyword">int</span> i)</span></span>;  <span class="comment">//获取第i个元素的指针</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> m_len;  <span class="comment">//数组长度</span></span><br><span class="line">    <span class="keyword">int</span> *m_arr; <span class="comment">//数组指针</span></span><br><span class="line">    <span class="keyword">int</span> *m_p;  <span class="comment">//指向数组第i个元素的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">VLA::VLA(<span class="keyword">int</span> len): m_len(len)&#123;</span><br><span class="line">    <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123; m_arr = <span class="keyword">new</span> <span class="keyword">int</span>[len];  <span class="comment">/*分配内存*/</span> &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123; m_arr = <span class="literal">NULL</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line">VLA::~VLA()&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_arr;  <span class="comment">//释放内存</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VLA::input</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; m_p=at(i); i++)&#123; <span class="built_in">cin</span>&gt;&gt;*at(i); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VLA::show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; m_p=at(i); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == m_len - <span class="number">1</span>)&#123; <span class="built_in">cout</span>&lt;&lt;*at(i)&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="built_in">cout</span>&lt;&lt;*at(i)&lt;&lt;<span class="string">", "</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">VLA::at</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!m_arr || i&lt;<span class="number">0</span> || i&gt;=m_len)&#123; <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123; <span class="keyword">return</span> m_arr + i; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个有n个元素的数组（对象）</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Input array length: "</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    VLA *parr = <span class="keyword">new</span> VLA(n);</span><br><span class="line">    <span class="comment">//输入数组元素</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Input "</span>&lt;&lt;n&lt;&lt;<span class="string">" numbers: "</span>;</span><br><span class="line">    parr -&gt; input();</span><br><span class="line">    <span class="comment">//输出数组元素</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Elements: "</span>;</span><br><span class="line">    parr -&gt; show();</span><br><span class="line">    <span class="comment">//删除数组（对象）</span></span><br><span class="line">    <span class="keyword">delete</span> parr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>输出结果:<br>Input array length: 5<br>Input 5 numbers: 99 23 45 10 100<br>Elements: 99, 23, 45, 10, 100<p></p><p>~VLA()就是 VLA 类的析构函数，它的唯一作用就是在删除对象（第 53 行代码）后释放已经分配的内存。</p><p>函数名是标识符的一种，原则上标识符的命名中不允许出现~符号，在析构函数的名字中出现的~可以认为是一种特殊情况，目的是为了和构造函数的名字加以对比和区分。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://c.biancheng.net/cpp/biancheng/view/196.html" target="_blank" rel="noopener">http://c.biancheng.net/cpp/biancheng/view/196.html</a></p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://wangng.com/articles/e7ccb3bf.html/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="jackcywang"><meta itemprop="description" content="不经一番彻骨寒,怎得梅花扑鼻香"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="jackcywang's blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a href="/articles/e7ccb3bf.html/" class="post-title-link" itemprop="url">C++之类与对象</a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-07-23 20:28:47" itemprop="dateCreated datePublished" datetime="2019-07-23T20:28:47+08:00">2019-07-23</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i></span> <span class="post-meta-item-text">Valine：</span><a title="valine" href="/articles/e7ccb3bf.html/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/articles/e7ccb3bf.html/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>3.3k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>3 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p>　　C++是一门面向对象的编程语言，而让C++具有这一特性的重要原因就是类和对象。类，通俗来说就是模板，一个模板可以创建很多的实例，也就是对象，比如人类就是一个类，而黄种人，白种人和黑种人就是这个类的对象。类包含属性和方法，比如身高，体重等是人类的属性，吃饭睡觉是人类的方法。我们在用类创建对象时，被称为类的实例化，而创建后的对象会继承类的属性和方法.</p><blockquote><p>和结构体一样,类只是一种复杂数据类型的声明,不占用内存.而对象是类这种数据类型的一个变量，或者说是通过类这种数据类型创建出来的一份实实在在的数据，所以占用内存空间。</p></blockquote><div class="post-button"> <a class="btn" href="/articles/e7ccb3bf.html/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://wangng.com/articles/874edf70.html/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="jackcywang"><meta itemprop="description" content="不经一番彻骨寒,怎得梅花扑鼻香"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="jackcywang's blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a href="/articles/874edf70.html/" class="post-title-link" itemprop="url">DCN可变形卷积</a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-07-22 19:25:32" itemprop="dateCreated datePublished" datetime="2019-07-22T19:25:32+08:00">2019-07-22</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Deeplearning/" itemprop="url" rel="index"><span itemprop="name">Deeplearning</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Deeplearning/Object-Detection/" itemprop="url" rel="index"><span itemprop="name">Object Detection</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i></span> <span class="post-meta-item-text">Valine：</span><a title="valine" href="/articles/874edf70.html/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/articles/874edf70.html/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>6.5k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>6 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><p>论文：<a href="https://arxiv.org/pdf/1703.06211.pdf" target="_blank" rel="noopener">Deformable Convolutional Networks</a><br>代码：<a href="https://github.com/oeway/pytorch-deform-conv" target="_blank" rel="noopener">github</a></p><div class="post-button"> <a class="btn" href="/articles/874edf70.html/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://wangng.com/articles/fae94215.html/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="jackcywang"><meta itemprop="description" content="不经一番彻骨寒,怎得梅花扑鼻香"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="jackcywang's blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a href="/articles/fae94215.html/" class="post-title-link" itemprop="url">目标跟踪之SiamFC:基于全卷积孪生网络的目标跟踪</a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-07-16 23:12:49" itemprop="dateCreated datePublished" datetime="2019-07-16T23:12:49+08:00">2019-07-16</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Deeplearning/" itemprop="url" rel="index"><span itemprop="name">Deeplearning</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Deeplearning/Object-tracking/" itemprop="url" rel="index"><span itemprop="name">Object tracking</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i></span> <span class="post-meta-item-text">Valine：</span><a title="valine" href="/articles/fae94215.html/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/articles/fae94215.html/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>2.3k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>2 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><p>论文：<a href="https://arxiv.org/pdf/1606.09549.pdf" target="_blank" rel="noopener">Fully-Convolutional Siamese Networks for Object Tracking</a><br>代码：<a href="https://github.com/bertinetto/siamese-fc" target="_blank" rel="noopener">github</a></p><h3 id="背景简介"><a href="#背景简介" class="headerlink" title="背景简介"></a>背景简介</h3><p><img src="/articles/fae94215.html/track.gif" alt><br>　　目标跟踪是计算机视觉中一个非常重要的研究方向，它的应用领域包括自动驾驶,人机交互,视频监控等。目标(单目标)跟踪任务就是在给定某视频序列初始帧的目标大小与位置的情况下，预测后续帧中该目标的大小与位置。这一基本任务流程可以按如下的框架划分：</p><div class="post-button"> <a class="btn" href="/articles/fae94215.html/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://wangng.com/articles/c8047a06.html/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="jackcywang"><meta itemprop="description" content="不经一番彻骨寒,怎得梅花扑鼻香"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="jackcywang's blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a href="/articles/c8047a06.html/" class="post-title-link" itemprop="url">C++之数组与指针传参</a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-07-15 18:49:52" itemprop="dateCreated datePublished" datetime="2019-07-15T18:49:52+08:00">2019-07-15</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i></span> <span class="post-meta-item-text">Valine：</span><a title="valine" href="/articles/c8047a06.html/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/articles/c8047a06.html/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>3.9k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>4 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>　　要使用C++函数，必须完成如下工作</p><ul><li>提供函数定义</li><li>提供函数原型(即函数声明)</li><li>调用函数</li></ul><p>库函数是已经定义和编译好的函数，同时可以使用标准库头文件提供其原型，因此只需正确地调用这种函数即可。然而，创建自己的函数时，必须自行处理这3个方面——定义、提供原型和调用。程序1示例<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// calling.cpp -- defining, prototyping, and calling a function</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simple</span><span class="params">()</span></span>;    <span class="comment">// 函数原型(声明)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"main() will call the simple() function:\n"</span>;</span><br><span class="line">    simple();     <span class="comment">// 函数调用</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"main() is finished with the simple() function.\n"</span>;</span><br><span class="line">    <span class="comment">// cin.get();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simple</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm but a simple function.\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="函数与数组"><a href="#函数与数组" class="headerlink" title="函数与数组"></a>函数与数组</h3><p>　　我们平时编写的函数都比较简单，参数基本上都是按值传递的，参数形式都是基本的int,float型的．现在来学习一种较为复杂的参数形式数组．将数组作为参数传入函数,函数需要知道要对哪个数组进行累计，因此需要将数组名作为参数传递给它。为使函数通用，而不限于特定长度的数组，还需要传递数组长度。这里唯一的新内容是，需要将一个形参声明为数组名。下面来看一看函数头及其其他部分：<br><code>int sum_arr(int arr[], int n) //arr是数组名,n是数组大小</code></p><p>这看起来似乎合理。方括号指出arr是一个数组，而方括号为空则表明，可以将任何长度的数组传递给该函数。但实际情况并非如此：<strong>arr实际上并不是数组，而是一个指针！好消息是，在编写函数的其余部分时，可以将arr看作是数组</strong>。首先，通过一个示例验证这种方法可行，然后看看它为什么可行</p><p>程序演示如同使用数组名那样使用指针的情况。程序将数组初始化为某些值，并使用sum_arr()函数计算总数。<strong>注意到sum_arr()函数使用arr时，就像是使用数组名一样。</strong><br>程序2示例<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arrfun1.cpp -- functions with an array argument</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ArSize = <span class="number">8</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_arr</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span>;        <span class="comment">// 原型</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">int</span> cookies[ArSize] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">16</span>,<span class="number">32</span>,<span class="number">64</span>,<span class="number">128</span>&#125;;</span><br><span class="line"><span class="comment">// some systems require preceding int with static to</span></span><br><span class="line"><span class="comment">// enable array initialization</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = sum_arr(cookies, ArSize);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Total cookies eaten: "</span> &lt;&lt; sum &lt;&lt;  <span class="string">"\n"</span>;</span><br><span class="line">    <span class="comment">// cin.get();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// return the sum of an integer array</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_arr</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        total = total + arr[i];</span><br><span class="line">    <span class="keyword">return</span> total; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>程序输出:<br>Total cookies eaten: 255<p></p><h4 id="函数如何使用指针来处理数组"><a href="#函数如何使用指针来处理数组" class="headerlink" title="函数如何使用指针来处理数组"></a>函数如何使用指针来处理数组</h4><p>　　在大多数情况下，C++和C语言一样，也将数组名视为指针。指针一文中介绍过，<strong>C++将数组名解释为其第一个元素的地址</strong><br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cookies == &amp;cookies[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><br>该规则有一些例外。首先，数组声明使用数组名来标记存储位置；其次，对数组名使用 sizeof将得到整个数组的长度（以字节为单位）；第三，正如指针那节指出的，将地址运算符&amp;用于数组名时，将返回整个数组的地址，例如&amp;cookies将返回一个32字节内存块的地址（如果int长4字节）。程序2示例中函数调用<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = sum_arr(cookies, ArSize)</span><br></pre></td></tr></table></figure><br>其中， cookies是数组名，而根据C++规则， cookies是其第一个元素的地址，因此函数传递的是地址,由于数组的元素的类型为int，因此 cookies的类型必须是int指针，即int<em>。这表明，正确的函数头应该是这样的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_arr</span><span class="params">(<span class="keyword">int</span>* cookies, ArSize)</span></span></span><br></pre></td></tr></table></figure><br>其中用`int</em> arr<code>替换了</code>int arr[]<code>。这证明这两个函数头都是正确的，因为在C++中，当(且仅当)用于函数头或函数原型中，</code>int*ar<code>和</code>int arr[]`的含义才是相同的。它们都意味着arr是一个int指针.<p></p><p>鉴于变量ar实际上就是一个指针，函数的其余部分是合理的。同数组名或指针一样，也可以用方括号数组表示法来访问数组元素。<strong>无论rarr是指针还是数组名，表达式arr[3]都指的是数组的第4个元素</strong>。就目前而言,记住下面两个恒等式，将不会有任何坏处：<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr[i] = *(arr+i)  <span class="comment">//数组第i个值得访问形式</span></span><br><span class="line">&amp;arr[i] = arr+i    <span class="comment">//数组第i个值地址访问形式</span></span><br></pre></td></tr></table></figure><br>记住，将指针（包括数组名）加1，实际上是加上了一个与指针指向的类型的长度（以字节为单位）相等的值。对于遍历数组而言，使用指针加法和数组下标时等效的。<p></p><h4 id="将数组作为参数意味着什么"><a href="#将数组作为参数意味着什么" class="headerlink" title="将数组作为参数意味着什么"></a>将数组作为参数意味着什么</h4><p>　　我们来看一看程序2暗示了什么。函数调用sum_arr(cookies, ArSize)将cookies数组第一个元素的地址和数组中的元素数目传递给sum_arr()函数。sum_arr()函数将cookies的地址赋给指针变量arr，将ArSize赋给int变量n。这意味着，程序2实际上并没有将数组内容传递给函数，而是将数组的位置（地址）、包含的元素种类（类型）以及元素数目（n变量）提交给函数。有了这些信息后，函数便可以使用原来的数组。<strong>传递常规变量时，函数将使用该变量的拷贝；但传递数组时，函数将使用原来的数组</strong>。</p><h3 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h3><p>可以用两种不同的方式将 const关键字用于指针。第一种方法是让指针指向一个常量对象，这样可以防止使用该指针来修改所指向的值，第二种方法是将指针本身声明为常量，这样可以防止改变指针指向的位置.</p><p>首先声明一个指向常量得指针<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">39</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * pt = &amp;age;</span><br></pre></td></tr></table></figure><br>该声明指出，pt指向一个 const int（这里为39），因此不能使用pt来修改这个值。换句话来说，*pt的值为 const，不能被修改.<p></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*pt += <span class="number">1</span>       <span class="comment">// 无效</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; *pt     <span class="comment">// 无效</span></span><br></pre></td></tr></table></figure><p>现在来看一个微妙的问题。pt的声明并不意味着它指向的值实际上就是一个常量，而只是意味着对pt而言，这个值是常量。例如，pt指向age，而age不是 const。可以直接通过age变量来修改age的值，但不能使用pt指针来修改它<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*pt = <span class="number">20</span>      <span class="comment">//无效</span></span><br><span class="line">age = <span class="number">20</span>      <span class="comment">//有效</span></span><br></pre></td></tr></table></figure><p></p><p>以前我们将常规变量的地址赋给常规指针，而这里将常规变量的地址赋给指向 const的指针。因此还有两种可能：将 const变量的地址赋给指向 const的指针、将 const的地址赋给常规指针。这两种操作都可行吗？第一种可行，但第二种不可行：<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> g_earth = <span class="number">9.80</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> * pe = &amp;g_earth   <span class="comment">//有效</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> g_moon = <span class="number">1.63</span></span><br><span class="line"><span class="keyword">float</span> * pm = &amp;g_moon          <span class="comment">//无效</span></span><br></pre></td></tr></table></figure><br>对于第一种情况来说，既不能使用 g earth来修改值9.80，也不能使用pe来修改。C++禁止第二种情况的原因很简单—如果将 moon的地址赋给pm，则可以使用pm来修改 moon的值，这使得 goon的 const状态很荒谬，因此C艹+禁止将 const的地址赋给非 const指针。如果非要这样做，可以使用强制类型转换来突破这种限制.<p></p><p><strong>注意：如果数据类型本身并不是指针，则可以将 const数据或非 const数据的地址赋给指向 const的指针，但只能将非 const数据的地址赋给非 const指针。</strong></p><p>假设有一个由 const数据组成的数组：<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> months[<span class="number">12</span>]=&#123;<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;；</span><br></pre></td></tr></table></figure><br>则禁止将常量数组的地址赋给非常量指针将意味着不能将数组名作为参数传递给使用非常量形参的函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> arr[]， <span class="keyword">int</span> n)</span><span class="comment">// should have been const int arr[]</span></span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">int</span> j= sum(months, <span class="number">12</span>)；<span class="comment">// not allowed</span></span><br></pre></td></tr></table></figure><br>上述函数调用试图将 const指针(months)赋给非 const指针(arr)，编译器将禁止这种函数调用。<p></p><p>尽可能使用,const将指针参数声明为指向常量数据的指针有两条理由：</p><ul><li>这样可以避免由于无意间修改数据而导致的编程错误；</li><li>使用 const使得函数能够处理 const和非 const实参，否则将只能接受非 const数据。<br>如果条件允许，则应将指针形参声明为指向 const的指针。</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://wangng.com/articles/869ca03d.html/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="jackcywang"><meta itemprop="description" content="不经一番彻骨寒,怎得梅花扑鼻香"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="jackcywang's blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a href="/articles/869ca03d.html/" class="post-title-link" itemprop="url">C++之指针_3</a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-07-05 18:49:52" itemprop="dateCreated datePublished" datetime="2019-07-05T18:49:52+08:00">2019-07-05</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i></span> <span class="post-meta-item-text">Valine：</span><a title="valine" href="/articles/869ca03d.html/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/articles/869ca03d.html/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>5k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>5 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="使用new创建动态结构"><a href="#使用new创建动态结构" class="headerlink" title="使用new创建动态结构"></a>使用new创建动态结构</h3><p><strong>在运行时创建数组优于在编译时创建数组，对于结构也是如此</strong>。需要在程序运行时为结构分配所需的空间，这也可以使用new运算符来完成。通过使用new，可以创建动态结构。同样，“动态”意味着内存是在运行时，而不是编译时分配的。由于类与结构非常相似，因此这里介绍的有关结构的技术也适用于类。</p><p>将new用于结构由两步组成：创建结构和访问其成员。要创建结构，需要同时使用结构类型和new例如，要创建一个未命名的 inflatable类型，并将其地址赋给一个指针，可以这样做：<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inflatable * ps = <span class="keyword">new</span> inflatable;</span><br></pre></td></tr></table></figure><br>这将把存储inflatable结构的一块可用内存的地址赋给ps。<strong>创建动态结构时，不能将成员运算符句点用于结构名，因为这种结构没有名称</strong>，只是知道它的地址。C++专门为这种情况提供了一个运算符：箭头成员运算符（-&gt;）。该运算符由连字符和大于号组成，可用于指向结构的指针，就像点运算符可用于结构名一样。例如，如果ps指向一个inflatable结构，则ps-&gt;price是被指向的结构的price成员。<p></p><div align="center"> <img src="http://cdn.wangng.com/C++/C++之指针_3/img1.png"></div><blockquote><p>提示：有时，C++新手在指定结构成员时，搞不清楚何时应使用句点运算符，何时应使用箭头运算符规则非常简单。如果结构标识符是结构名，如grubnose，则使用句点运算符；如果标识符是指向结构的指针，如pt，则使用箭头运算符</p></blockquote><p>另一种访问结构成员的方法是，如果ps是指向结构的指针，则<code>*ps</code>就是被指向的值—结构本身。由于<code>*ps</code>是一个结构，因此(<code>*ps</code>).price是该结构的price成员。C++的运算符优先规则要求使用括号。示例程序使用new创建了一个未命名的结构，并演示了两种访问结构成员的指针表示法。<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序4.21 newstrct.cpp  使用new创建结构体</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inflatable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">float</span> volume;</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    inflatable * ps = <span class="keyword">new</span> inflatable;   <span class="comment">//为inflatable结构分配内存</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter name of inflatable item: "</span>;</span><br><span class="line">    <span class="built_in">cin</span>.<span class="built_in">get</span>(ps-&gt;name,<span class="number">20</span>);   <span class="comment">//结构成员的方法一</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter volume in cubic feet: "</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; (*ps).volume;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter price: $"</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; ps-&gt;name;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Name: "</span> &lt;&lt; (*ps).name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Volume"</span> &lt;&lt; ps-&gt;volume &lt;&lt; <span class="string">"cubic feet\n"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Price: $"</span> &lt;&lt; ps-&gt;price &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> ps;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>程序输出<br>Enter name of inflatable item: Fabulous Frodo<br>Enter volume in cubic feet: 1.4<br>Enter price: 27.99<br>Name: Fabulous Frodo<br>Volume: 1.4 cubic feet<br>Price： 27.99</p></blockquote><h4 id="一个使用new和delete的示例"><a href="#一个使用new和delete的示例" class="headerlink" title="一个使用new和delete的示例"></a>一个使用new和delete的示例</h4><p>下面介绍一个使用new和 delete来存储通过键盘输入的字符串的示例，下面程序定义了一个函数getname()，该函数返回一个指向输入字符串的指针，该函数将输入读入到一个大型的临时数组中，然后使用new[]创建一个刚好能够存储该输入字符串的内存块，并返回一个指向该内存块的指针。对于读取大量字符串的程序，这种方法可以节省大量内存（实际编写程序时，使用 string类将更容易，因为这样可以使用内置的new和 delete）</p><p>假设程序要读取100个字符串，其中最大的字符串包含79个字符，而大多数字符串都短得多。如果用char数组来存储这些字符串，则需要1000个数组，其中每个数组的长度为80个字符。这总共需要80000个字节，而其中的很多内存没有被使用。另一种方法是，创建一个数组，它包含1000个指向char的指针,然后使用new根据每个字符串的需要分配相应数量的内存，这将节省几万个字节。<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序清单4.22 delete.cpp</span></span><br><span class="line"><span class="comment">//delete.cpp     使用删除操作</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;  //或者string.h</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">getname</span><span class="params">(<span class="keyword">void</span>)</span></span>;  <span class="comment">//函数声名</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * name;       <span class="comment">//创建一个未初始化的指针</span></span><br><span class="line">    name = getname();   <span class="comment">//将字符串的地址赋给name</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">" at "</span> &lt;&lt; (<span class="keyword">int</span>*)name &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">delete</span> [] name;    <span class="comment">//释放内存</span></span><br><span class="line"></span><br><span class="line">    name = getname();  <span class="comment">//重新使用释放的内存</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">" at "</span> &lt;&lt; (<span class="keyword">int</span>*) name &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">delete</span> [] name;    <span class="comment">//内存再次释放</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">getname</span><span class="params">()</span>      <span class="comment">//返回新字符串的地址</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> temp[<span class="number">80</span>];    <span class="comment">//临时存储</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter last name: "</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">    <span class="keyword">char</span> * pn = <span class="keyword">new</span> <span class="keyword">char</span> [<span class="built_in">strlen</span>(temp)+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(pn,temp);  <span class="comment">//赋值字符串到较小的空间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pn;       <span class="comment">//当函数结束时temp被丢失</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>程序输出<br>Enter last name: Fredeldumpkin<br>Fredeldumpkin at 0x12e1358<br>Enter last name: Pook<br>Pook at 0x12e1358</p></blockquote><p>函数getname()它使用cin将输入的单词放到temp数组中，然后使用new分配新内存，以存储该单词。程序需要strlen(temp)+1个字符（包括空字符）来存储该字符串，因此将这个值提供给new。获得空间后,getname()使用标准库函数 strcpy（将temp中的字符串复制到新的内存块中。该函数并不检查内存块是否能够容纳字符串，但 getname（）通过使用new请求合适的字节数来完成了这样的工作。最后，函数返回pn，这是字符串副本的地址。</p><p>在main()中，返回值（地址）被赋给指针name.该指针是在main()中定义的，但它指向 getname()函数中分配的内存块。然后，程序打印该字符串及其地址。</p><p>在这个例子中， getname()分配内存，而main()释放内存，将new和 delete放在不同的函数中通常井不是个好办法，因为这样很容易忘记使用 delete.不过这个例子确实把new和 delete分开放置了，只是为了说明这样做也是可以的。</p><h3 id="自动存储、静态存储和动态存储"><a href="#自动存储、静态存储和动态存储" class="headerlink" title="自动存储、静态存储和动态存储"></a>自动存储、静态存储和动态存储</h3><p>根据用于分配内存的方法，C+有3种管理数据内存的方式：自动存储、静态存储和动态存储（有时也叫作自由存储空间或堆）。在存在时间的长短方面，以这3种方式分配的数据对象各不相同。下面简要地介绍每种类型(C++11新增了第四种类型—-线性存储)</p><h4 id="自动存储"><a href="#自动存储" class="headerlink" title="自动存储"></a>自动存储</h4><p>在函数内部定义的常规变量使用自动存储空间，被称为自动变量,这意味着它们在所属函数被调用时自动产生，在该函数结束时消亡。如上面4.22程序中temp数组仅当getname()函数活动时存在，当程序控制权回到main()时，temp使用的内存被自动释放。如果getname()返回temp的地址,则main()中的name指针指向的内存将很快得到重新使用，这就是在getname()中使用new的原因。</p><p>实际上，自动变量是一个局部变量，其作用域为包含它的代码块。代码块是被包含在花括号中的一段代码。如果在其中的某个代码块定义了一个变量，则该变量仅在程序执行该代码块中的代码时存在。</p><p><strong>自动变量通常存储在栈中。这意味着执行代码块时，其中的变量将依次加入到栈中，而在离开代码块时，将按相反的顺序释放这些变量，这被称为后进先出（LIFO）</strong>。因此，在程序执行过程中，栈将不断地增大和缩小。</p><h4 id="静态存储"><a href="#静态存储" class="headerlink" title="静态存储"></a>静态存储</h4><p><strong>静态存储是整个程序执行期间都存在的存储方式</strong>。使变量成为静态的方式有两种：一种是在函数外面定义它；另一种是在声明变量时使用关键字 static：<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">double</span> fee = <span class="number">56.60</span>;</span><br></pre></td></tr></table></figure><p></p><h4 id="动态存储"><a href="#动态存储" class="headerlink" title="动态存储"></a>动态存储</h4><p>new和 delete运算符提供了一种比自动变量和静态变量更灵活的方法。它们管理了一个内存池，<strong>这在C++中被称为自由存储空间（ free store）或堆（heap）</strong>。该内存池中用于静态变量和自动变量的内存是分开的。程序4.22表明，new和 delete让我们能够在一个函数中分配内存，而在另一个函数中释放它。因此，数据的生命周期不完全受程序或函数的生存时间控制。与使用常规变量相比，使用new和 delete让程序员对程序如何使用内存有更大的控制权。然而，内存管理也更复杂了。在栈中，自动添加和删除机制使得占用的内存总是连续的，但new和delete的相互影响可能导致占用的自由存储区不连续，这使得跟踪新分配内存的位置更困难</p><h4 id="栈、堆和内存泄漏"><a href="#栈、堆和内存泄漏" class="headerlink" title="栈、堆和内存泄漏"></a>栈、堆和内存泄漏</h4><p>如果使用new运算符在自由存储空间（或堆）上创建变量后，没有调用delete,将发生什么情况呢？<br>如果没有调用delete,则即使包含指针的内存由于作用域规则和对象生命周期的原因而被释放，在自由存储空间上动态分配的变量或结构也将继续存在。实际上，将会无法访问自由存储空间中的结构，因为指向这些内存的指针无效。这将导致内存泄漏。被泄漏的内存将在程序的整个生命周期内都不可使用；这些内存被分配出去，但无法收回。极端情况（不过不常见）是，内存泄漏可能会非常严重，以致于应用程序可用的内存被耗尽，出现内存耗尽错误，导致程序崩溃。另外，这种泄漏还会给一些操作系统或在相同的内存空间中运行的应用程序带来负面影响，导致它们崩溃。</p><h3 id="类型组合"><a href="#类型组合" class="headerlink" title="类型组合"></a>类型组合</h3><p>我们学习了数组，结构和指针，其实还可以用各种方式组合他们。先从结构开始。<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">antarctica_year_end</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">    <span class="keyword">int</span> birthday;</span><br><span class="line">    <span class="comment">/*还有一些实际有趣的数据等*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><ul><li>可以创建这种类型的变量<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">antarctica_year_end s01, s02, s03; <span class="comment">//s01,s02,s03 是结构体</span></span><br></pre></td></tr></table></figure> 然后使用成员运算符访问其成员：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s01.year = <span class="number">1998</span>;</span><br></pre></td></tr></table></figure></li><li>可创建这种结构的指针：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">antarctica_year_end * pa = &amp;s02;</span><br></pre></td></tr></table></figure> 将该指针设置为有效地址后，就可使用间接成员运算符来访问成员：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pa-&gt;year = <span class="number">1999</span>;</span><br></pre></td></tr></table></figure></li><li>可创建结构数组:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">antarctica_year_end trio[<span class="number">3</span>];  <span class="comment">//包含3个结构体的数组</span></span><br></pre></td></tr></table></figure> 然后可以使用成员运算符访问元素的成员：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trio[<span class="number">0</span>].year = <span class="number">2003</span>;    <span class="comment">//trio[0]是一个结构体</span></span><br></pre></td></tr></table></figure> 其中tiro是一个数组，tiro[0]是一个结构，而 trio[0].year是该结构的一个成员，<strong>由于数组名是一个指针(数组名是第一个元素的地址)</strong>，因此也可使用间接成员运算符：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(trio+<span class="number">1</span>)-&gt;year = <span class="number">2004</span>;  <span class="comment">//等价于trio[1].year = 2004</span></span><br></pre></td></tr></table></figure></li><li>可创建指针数组:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">antarctica_year_end *arp[<span class="number">3</span>] = &#123;&amp;s01, $s02, &amp;s03&#125;;</span><br></pre></td></tr></table></figure> 既然arp是一个指针数组，arp[1]就是一个指针，可将间接成员运算符应用于它，以访问成员:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; arp[<span class="number">1</span>]-&gt;year &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://wangng.com/articles/6892c111.html/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="jackcywang"><meta itemprop="description" content="不经一番彻骨寒,怎得梅花扑鼻香"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="jackcywang's blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a href="/articles/6892c111.html/" class="post-title-link" itemprop="url">C++之指针_1</a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-07-05 16:49:52" itemprop="dateCreated datePublished" datetime="2019-07-05T16:49:52+08:00">2019-07-05</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i></span> <span class="post-meta-item-text">Valine：</span><a title="valine" href="/articles/6892c111.html/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/articles/6892c111.html/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>8.8k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>8 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="1-指针简介"><a href="#1-指针简介" class="headerlink" title="1.指针简介"></a>1.指针简介</h3><p>计算机程序在存储数据时必须跟踪3种基本属性：</p><ul><li>信息存储在何处</li><li>存储的值为多少</li><li>存储的信息是什么类型</li></ul><div class="post-button"> <a class="btn" href="/articles/6892c111.html/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><nav class="pagination"><a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a> <a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a></nav></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">jackcywang</p><div class="site-description" itemprop="description">不经一番彻骨寒,怎得梅花扑鼻香</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">66</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">14</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">65</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/jackcywang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jackcywang" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:yourname@gmail.com" title="E-Mail → mailto:yourname@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i> E-Mail</a></span><span class="links-of-author-item"><a href="https://blog.csdn.net/weixin_42631693" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_42631693" rel="noopener" target="_blank"><i class="fa fa-fw fa-CSDN"></i> CSDN</a></span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/hao-han-zhong-de-yipian-xie" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;hao-han-zhong-de-yipian-xie" rel="noopener" target="_blank"><i class="fa fa-fw fa-知乎"></i> 知乎</a></span></div></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; 2019 – <span itemprop="copyrightYear">2020</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">jackcywang</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-area-chart"></i></span> <span title="站点总字数">261k</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span title="站点阅读时长">3:57</span></div><span id="sitetime"></span><script language="javascript">function siteTime(){window.setTimeout("siteTime()",1e3);var e=36e5,t=24*e,o=new Date,i=o.getFullYear(),n=o.getMonth()+1,a=o.getDate(),r=o.getHours(),s=o.getMinutes(),g=o.getSeconds(),l=Date.UTC(2020,1,1,15,0,0),m=Date.UTC(i,n,a,r,s,g)-l,M=Math.floor(m/t),T=Math.floor((m-M*t)/e),u=Math.floor((m-M*t-T*e)/6e4),f=Math.floor((m-M*t-T*e-6e4*u)/1e3);document.getElementById("sitetime").innerHTML=" 在此已等候"+M+" 天 "+T+" 小时 "+u+" 分钟 "+f+" 秒"}siteTime()</script><div> <a href="http://www.miitbeian.gov.cn/" rel="noopener" target="_blank">陕ICP备19023518号-1</a> <span class="post-meta-divider">|</span> <span style="padding-left:25px;background:url(/images/beian.png) no-repeat left center" rel="nofollow"><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=61019002001038" rel="noopener" target="_blank">陕公网安备61019002001038号</a></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script><script async src="/js/cursor/fireworks.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/moment.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment-precise-range-plugin@1.3.0/moment-precise-range.min.js"></script><script>
    function timer() {
      var ages = moment.preciseDiff(moment(),moment(20191220,"YYYYMMDD"));
      //去除时分秒信息
      ages = ages.replace(/\s?\d{0,2}\s+hours?/, "");
      ages = ages.replace(/\s?\d{0,2}\s+minutes?/, "");
      ages = ages.replace(/\s?\d{0,2}\s+seconds?/, "");
      //将年月日转换为中文
      ages = ages.replace(/years?/, "年");
      ages = ages.replace(/months?/, "月");
      ages = ages.replace(/days?/, "天");
      ages = ages.replace(/\d+/g, '<span style="color:#1890ff">$&</span>');
      span.innerHTML = `footer.age ${ages}`;
    }
    var span = document.createElement("span");
    //插入到agesicon之后
    var agesicon = document.querySelector(".footer-ages-icon");
    document.querySelector(".copyright").insertBefore(span, agesicon.nextSibling);
    timer();
  </script><script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'qHl8YMnB0b5OHNGx0AO0fjIE-gzGzoHsz',
      appKey     : 'wN3c6hhMnkEwVWOSLF0xQ3In',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script><script src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><script src="https://player.lmih.cn/player/js/player.js" id="myhk" key="158704924834" m="1"></script></body></html>