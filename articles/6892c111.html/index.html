<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.2.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css"><script src="/lib/pace/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"wangng.com",root:"/",scheme:"Pisces",version:"7.7.2",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!1,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="1.指针简介计算机程序在存储数据时必须跟踪3种基本属性：  信息存储在何处 存储的值为多少 存储的信息是什么类型"><meta property="og:type" content="article"><meta property="og:title" content="C++之指针_1"><meta property="og:url" content="https://wangng.com/articles/6892c111.html/index.html"><meta property="og:site_name" content="jackcywang&#39;s blog"><meta property="og:description" content="1.指针简介计算机程序在存储数据时必须跟踪3种基本属性：  信息存储在何处 存储的值为多少 存储的信息是什么类型"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://cdn.wangng.com/C++/C++%E4%B9%8B%E6%8C%87%E9%92%88_1/image_48.png"><meta property="og:image" content="http://cdn.wangng.com/C++/C++%E4%B9%8B%E6%8C%87%E9%92%88_1/image_49.png"><meta property="article:published_time" content="2019-07-05T08:49:52.000Z"><meta property="article:modified_time" content="2020-04-26T07:37:38.009Z"><meta property="article:author" content="jackcywang"><meta property="article:tag" content="C++"><meta property="article:tag" content="指针"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://cdn.wangng.com/C++/C++%E4%B9%8B%E6%8C%87%E9%92%88_1/image_48.png"><link rel="canonical" href="https://wangng.com/articles/6892c111.html/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>C++之指针_1 | jackcywang's blog</title><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?8ce866754ae6c95a7238894d36ad3ab0";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div> <a href="https://github.com/jackcywang" target="_blank" rel="noopener" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#64ceaa;color:#fff;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">jackcywang's blog</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">梦想与现实只在一念之间</p></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i> 关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i> 归档</a></li></ul></nav></div></header><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://wangng.com/articles/6892c111.html/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="jackcywang"><meta itemprop="description" content="不经一番彻骨寒,怎得梅花扑鼻香"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="jackcywang's blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> C++之指针_1</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-07-05 16:49:52" itemprop="dateCreated datePublished" datetime="2019-07-05T16:49:52+08:00">2019-07-05</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i></span> <span class="post-meta-item-text">Valine：</span><a title="valine" href="/articles/6892c111.html/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/articles/6892c111.html/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>8.8k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>8 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="1-指针简介"><a href="#1-指针简介" class="headerlink" title="1.指针简介"></a>1.指针简介</h3><p>计算机程序在存储数据时必须跟踪3种基本属性：</p><ul><li>信息存储在何处</li><li>存储的值为多少</li><li>存储的信息是什么类型</li></ul><a id="more"></a><p>一种策略是：定义一个简单变量。声明语句指出了值的类型和符号名，还让程序为值分配内存，并在内部跟踪该存储单元。</p><p>另外一种策略，它在开发C++类时非常重要，这种策略以指针为基础，指针是一个变量其存储的是值的地址，而不是值本身。在讨论指针之前，我们先看一看如何找到常规变量的地址。只需对变量应用地址运算符（&amp;），就可以获得它的位置：例如，如果home是一个变量，则&amp;home是它的地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">	<span class="keyword">int</span> donuts = <span class="number">6</span>;</span><br><span class="line">	<span class="keyword">double</span> cups = <span class="number">4.5</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"donuts value = "</span> &lt;&lt; donuts;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">" and donuts address = "</span> &lt;&lt; &amp;donuts &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"cups value = "</span> &lt;&lt; cups;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">" and cups address = "</span> &lt;&lt; &amp;cups &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;程序输出</span><br><span class="line">donuts value &#x3D; 6 and donuts address &#x3D; 0x0065fd40</span><br><span class="line">cups value &#x3D; 4.5 and cups address &#x3D; 0x0065fd44</span><br></pre></td></tr></table></figure><p>处理存储数据的新策略刚好相反，将地址视为指定的量，而将值视为派生量。一种特殊类型的变量—指针,用于存储值的地址。因此，指针名表示的是地址。<code>*</code>运算符被称为间接值(indirect value)或解除引用(dereferencing运算符，将其应用于指针，可以得到该地址处存储的值（这和乘法使用的符号相同；C++根据上下文来确定所指的是乘法还是解除引用）。例如，假设manyl是个指针，则 manly表示的是一个地址，而<code>*</code>manly表示存储在该地址处的值。<code>*</code>manly与常规int变量等效。</p><ul><li><p>指针示例pointer.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">	<span class="keyword">int</span> updates = <span class="number">6</span>;</span><br><span class="line">	<span class="keyword">int</span> * p_updates;</span><br><span class="line">	p_updates = &amp;updates;</span><br><span class="line">	<span class="comment">//显示值</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Values: updates = "</span> &lt;&lt; updates;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">", *p_updates = "</span> &lt;&lt; *p_updates &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//显示地址</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Address: &amp;updataes = "</span> &lt;&lt; &amp;updates;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">",p_updates = "</span> &lt;&lt; p_updates &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//使用指针更改值</span></span><br><span class="line">	*p_updates = *p_updates + <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Now updates = "</span> &lt;&lt; updates &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">Value: updates &#x3D; 6,*p_updates &#x3D; 6</span><br><span class="line">Address: &amp;updatas &#x3D; 0x0065fd48,p_updates &#x3D; 0x0065fd48</span><br><span class="line">Now updates &#x3D; 7</span><br></pre></td></tr></table></figure><p>从中可知，int变量updates和指针变量 p<em>updates只不过是同一枚硬币的两面，变量updates表示值,并使用&amp;运算符来获得地址：而变量p_updates表示地址，并使用运算符来获得值（参见图4.8）。由于p</em> updates指向 updates，因此<code>*</code>p<em>updates和 updates完全等价。可以像使用int变量那样使用 <code>*</code>p</em> updates，正如上述程序表明的，甚至可以将值赋给<code>*</code>p_updates，这样做将修改指向的值，即updates</p></li></ul><p><img src="http://cdn.wangng.com/C++/C++之指针_1/image_48.png" alt></p><h4 id="1-2指针声明和初始化"><a href="#1-2指针声明和初始化" class="headerlink" title="1.2指针声明和初始化"></a>1.2指针声明和初始化</h4><p>计算机需要跟踪指针指向的值的类型。例如，char的地址与 double的地址看上去没什么两样，但char和 double使用的字节数是不同的，它们存储值时使用的内部格式也不同。因此，指针声明必须指定指针指向的数据的类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * p_udates;</span><br></pre></td></tr></table></figure><p>这表明，$<em>$ p_updates的类型为int。由于$</em>$运算符被用于指针，因此p_updates变量本身必须是指针。我们说p_updates指向int类型，我们还说p_updates的类型是指向int的指针，或int <em>类型，可以这样说，p_updates是指针(地址)，而</em> p_updates是int,而不是指针(见图4.9).</p><p><img src="http://cdn.wangng.com/C++/C++之指针_1/image_49.png" alt></p><p>顺便说一句，* 运算符两边的空格是可选的。传统上C程序员使用这种格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptr</span><br></pre></td></tr></table></figure><p>这强调*ptr是一个int类型的值。而很多C++程序元使用这种格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* ptr</span><br></pre></td></tr></table></figure><p>这强调int* 是一种类型—指向int的指针。</p><p>但要知道的是，下面的声明创建一个指针(p1)和一个int变量(p2)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p1,p2;</span><br></pre></td></tr></table></figure><p>对每一个指针变量名，都需要使用一个*。</p><p>可以用同样的句法来声明指向其他类型的指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> * tax_ptr;  <span class="comment">//指向double类型的指针</span></span><br><span class="line"><span class="keyword">char</span> * str;        <span class="comment">//指向char类型的指针</span></span><br></pre></td></tr></table></figure><p>由于已将tax_ptr声明为一个指向 double的指针，因此编译器知道 <code>*</code>tax_ptr是一个 double类型的值。也就是说，它知道 <code>*</code>tax_ptr是一个以浮点格式存储的值，这个值（在大多数系统上）占据8个字节。指针变量不仅仅是指针，而且是指向特定类型的指针。 tax_ptr的类型是指向 double的指针(或 double <code>*</code>类型),str是指向char的指针类型(或char *)。尽管它们都是指针，却是不同类型的指针。和数组一样，指针都是基于其他类型的。</p><p>虽然tax_ptr和str指向两种长度不同的数据类型，但这两个变量本身的长度通常是相同的，也就是说， char的地址与 double的地址的长度相同，这就好比1016可能是超市的街道地址，而1024可以是小村庄的道地址一样。地址的长度或值既不能指示关于变量的长度或类型的任何信息，也不能指示该地址上有什么建筑物。一般来说，地址需要2个还是4个字节，取决于计算机系统(有些系统可能需要更大的地址,系统可以针对不同的类型使用不同长度的地址）。</p><p>可以在声明语句中初始化指针。在这种情况下，被初始化的是指针，而不是它指向的值。也就是说下面的语句将pt（而不是*pt）的值设置为&amp; higgens：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> higgens = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> * pt = &amp;higgens;</span><br></pre></td></tr></table></figure><h4 id="1-3指针和数字"><a href="#1-3指针和数字" class="headerlink" title="1.3指针和数字"></a>1.3指针和数字</h4><p>指针不是整型，虽然计算机通常把地址当作整数来处理。从概念上看，指针与整数是截然不同的类型。整数是可以执行加、减、除等运算的数字，而指针描述的是位置，将两个地址相乘没有任何意义。从可以对整数和指针执行的操作上看，它们也是彼此不同的。因此，不能简单地将整数赋给指针:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * pt;</span><br><span class="line">pt = <span class="number">0xB8000000</span>;    <span class="comment">//类型不匹配;</span></span><br></pre></td></tr></table></figure><p>在这里，左边是指向int的指针，因此可以把它赋给地址，但右边是一个整数。你可能知道，0xB8000000是老式计算机系统中内存的组合段偏移地址，但这条语句并没有告诉程序，这个数字就是一个地址。在C99标准发布之前，C语言允许这样赋值。但C++在类型一致方面的要求更严格，编译器将显示一条错误消息，通告类型不匹配。要将数字值作为地址来使用，应通过强制类型转换将数字转换为适当的地址类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * pt;</span><br><span class="line">pt = (<span class="keyword">int</span>*) <span class="number">0xB8000000</span>;  <span class="comment">//类型匹配</span></span><br></pre></td></tr></table></figure><h4 id="1-4使用new来分配内存"><a href="#1-4使用new来分配内存" class="headerlink" title="1.4使用new来分配内存"></a>1.4使用new来分配内存</h4><p>前面我们都将指针初始化为变量的地址;变量是在编译时分配的有名称的内存，而指针只是为可以通过名称直接访问的内存提供了 一个别名。指针真正的用武之地在于，在运行阶段分配未命名的内存以存储值。在这种情况下，只能通过指针来访问内存。</p><p>下面来试试这种新技术，在运行阶段为一个int值分配未命名的内存，并使用指针来访问这个值。这里的关键所在是C++的new运算符。程序员要告诉new，需要为哪种数据类型分配内存；new将找到一个长度正确的内存块，并返回该内存块的地址。程序员的责任是将该地址赋给一个指针。下面是一个这样的示例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * pn = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br></pre></td></tr></table></figure><p>new int告诉程序，需要适合存储int的内存。new运算符根据类型来确定需要多少字节的内存。然后它找到这样的内存，并返回其地址。接下来，将地址赋给pn,pn是被声明为指向int的指针，现在，pn是地址，而*pn是存储在那里的值。将这种方法与将变量的地址赋给指针进行比较：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> higgens;</span><br><span class="line"><span class="keyword">int</span> * pt = &amp;higgens;</span><br></pre></td></tr></table></figure><p>在这两种情况（pn和pt）下，都是将一个int变量的地址赋给了指针。在第二种情况下，可以通过名称 higgens来访问该int，在第一种情况下，则只能通过该指针进行访问，这引出了一个问题：pn指向的内存没有名称，如何称呼它呢？我们说pn指向一个数据对象，这里的“对象”不是“面向对象编程”中的对象，而是一样“东西”。术语“数据对象”比“变量”更通用，它指的是为数据项分配的内存块。因此，变量也是数据对象，但pn指向的内存不是变量。乍一看，处理数据对象的指针方法可能不太好用，但它使程序在管理内存方面有更大的控制权。</p><p>为一个数据对象（可以是结构，也可以是基本类型）获得并指定分配内存的通用格式如：</p><p>typeName * pointer_name = new typeName</p><p>需要在两个地方指定数据类型：用来指定需要什么样的内存和用来声明合适的指针。当然，如果已经声明了相应类型的指针，则可以使用该指针，而不用再声明一个新的指针。下面程序展示如何将new用于两种不同的类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ues_new.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">	<span class="keyword">int</span> nights = <span class="number">1001</span>;</span><br><span class="line">	<span class="keyword">int</span> * pt = <span class="keyword">new</span> <span class="keyword">int</span>;   <span class="comment">//分配一个int内存</span></span><br><span class="line">	*pt = <span class="number">1001</span>;           <span class="comment">//给该内存赋值</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"nights value = "</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; nights &lt;&lt; <span class="string">": location "</span> &lt;&lt; &amp;nights &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"int "</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"value = "</span> &lt;&lt; *pt &lt;&lt; <span class="string">": location = "</span> &lt;&lt; pt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">double</span> * pd = <span class="keyword">new</span> <span class="keyword">double</span>; <span class="comment">//分配一个double内存</span></span><br><span class="line">	*pd = <span class="number">10000001.0</span>;     <span class="comment">//给该内存赋double类型值</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"double "</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"value = "</span> &lt;&lt; *pd &lt;&lt; <span class="string">":location = "</span> &lt;&lt; pd &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"location of pointer pd： "</span> &lt;&lt; &amp;pd &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"size of pt = "</span> &lt;&lt; <span class="keyword">sizeof</span>(pt);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">": size of *pt = "</span> &lt;&lt; <span class="keyword">sizeof</span>(*pt) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"size of pd = "</span> &lt;&lt; <span class="keyword">sizeof</span> pd;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">": size of *pd = "</span> &lt;&lt; <span class="keyword">sizeof</span>(*pd) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//程序输出</span></span><br><span class="line">nights value = <span class="number">1001</span>: location = <span class="number">0028F</span>7F8;</span><br><span class="line"><span class="keyword">int</span> value = <span class="number">1001</span>: location = <span class="number">00033</span>A98</span><br><span class="line"><span class="keyword">double</span> value = <span class="number">1e+007</span>: location = <span class="number">000339B</span>8</span><br><span class="line">location of pointer pd: <span class="number">0028F</span>7FC</span><br><span class="line"><span class="built_in">size</span> of pt = <span class="number">4</span>: <span class="built_in">size</span> of *pt = <span class="number">4</span></span><br><span class="line"><span class="built_in">size</span> of pd = <span class="number">4</span>: <span class="built_in">size</span> of *pd = <span class="number">8</span></span><br></pre></td></tr></table></figure><p>当然,内存位置的准确值随系统而异。</p><p>对于指针，需要指出的另一点是，new分配的内存块通常与常规变量声明分配的内存块不同，变量和pd的值都存储在被称为栈（ stack）的内存区域中，而new从被称为堆（heap）或自由存储区（free store)的内存区域分配内存。</p><h4 id="1-5使用delete释放内存"><a href="#1-5使用delete释放内存" class="headerlink" title="1.5使用delete释放内存"></a>1.5使用delete释放内存</h4><p>当需要内存时，可以使用new来请求，这只是C++内存管理数据包中有魅力的一个方面。另一个方面是 delete运算符，它使得在使用完内存后，能够将其归还给内存池，这是通向最有效地使用内存的关键一步。归还或释放（free）的内存可供程序的其他部分使用。使用 delete时，后面要加上指向内存块的指针（这些内存块最初是用new分配的):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * ps = <span class="keyword">new</span> <span class="keyword">int</span>;   <span class="comment">//使用new分配一个内存</span></span><br><span class="line">...                   <span class="comment">//使用内存</span></span><br><span class="line"><span class="keyword">delete</span> ps;             <span class="comment">//使用完后释放内存</span></span><br></pre></td></tr></table></figure><p>这将释放ps指向的内存，但不会删除指针ps本身，例如，可以将ps重新指向另一个新分配的内存块定要配对地使用new和 delete否则将发生内存泄漏（ memory leak），也就是说，被分配的内存再也无法使用了。如果内存泄漏严重，则程序将由于不断寻找更多内存而终止。</p><p>不要尝试释放已经释放的内存块，C++标准指出，这样做的结果将是不确定的，这意味着什么情况都可能发生。另外，不能使用 delete来释放声明变量所获得的内存：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * ps = <span class="keyword">new</span> <span class="keyword">int</span>;  <span class="comment">//ok</span></span><br><span class="line"><span class="keyword">delete</span> ps;            <span class="comment">//ok</span></span><br><span class="line"><span class="keyword">delete</span> ps;            <span class="comment">//not ok</span></span><br><span class="line"><span class="keyword">int</span> jugs = <span class="number">5</span>;        <span class="comment">//ok</span></span><br><span class="line"><span class="keyword">int</span> * pi = &amp;jugs     <span class="comment">//ok</span></span><br><span class="line"><span class="keyword">delete</span> pi             <span class="comment">//不允许；内存不是由new分配的</span></span><br></pre></td></tr></table></figure><p><strong>注意：只能用 delete来释放使用new分配的内存。对空指针使用 delete是安全的。</strong></p><p>注意，使用 delete的关键在于，将它用于new分配的内存。这并不意味着要使用用于new的指针，而是用于new的地址：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * ps = <span class="keyword">new</span> <span class="keyword">int</span>;   <span class="comment">//分配内存</span></span><br><span class="line"><span class="keyword">int</span> * pq = ps;        <span class="comment">//设置第二个指针指向同一个内存</span></span><br><span class="line"><span class="keyword">delete</span> pq;             <span class="comment">//删除第二个指针指向的内存</span></span><br></pre></td></tr></table></figure><p>般来说，不要创建两个指向同一个内存块的指针，因为这将增加错误地删除同一个内存块两次的可能性。但稍后你会看到，对于返回指针的函数，使用另一个指针是有道理的。</p><h4 id="1-6使用new创建动态数组"><a href="#1-6使用new创建动态数组" class="headerlink" title="1.6使用new创建动态数组"></a>1.6使用new创建动态数组</h4><p>如果程序只需要一个值，则可能会声明一个简单变量，因为对于管理一个小型数据对象来说，这样做比使用new和指针更简单，尽管给人留下的印象不那么深刻。通常，对于大型数据（如数组、字符串和结构），应使用new，这正是new的用武之地。例如，假设要编写一个程序，它是否需要数组取决于运行时用户提供的信息。如果通过声明来创建数组，则在程序被编译时将为它分配内存空间。不管程序最终是否使用数组，数组都在那里，它占用了内存。在编译时给数组分配内存被称为静态联编（ static binding），意味着数组是在编译时加入到程序中的。但使用new时，如果在运行阶段需要数组，则创建它；如果不需要则不创建。还可以在程序运行时选择数组的长度。这被称为动态联编（ dynamic binding），意味着数组是在程序运行时创建的。这种数组叫作动态数组（ dynamic array）。使用静态联编时，必须在编写程序时指定数组的长度；使用动态联编时，程序将在运行时确定数组的长度。</p><p><strong>使用new创建动态数组</strong></p><p>在C++中，创建动态数组很容易：只要将数组的元素类型和元素数目告诉new即可。必须在类型名后加上方括号，其中包含元素数目。例如，要创建一个包含10个int元素的数组，可以这样做：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * psome = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>new运算符返回第一个元素的地址。在这个例子中，该地址被赋给指针 psome</p><p>当程序使用完new分配的内存块时，应使用 delete释放它们。然而，对于使用new创建的数组，应使种格式的 delete来释放：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> [] psome;   <span class="comment">//释放一个动态数组</span></span><br></pre></td></tr></table></figure><p>方括号告诉程序，应释放整个数组，而不仅仅是指针指向的元素。请注意 delete和指针之间的方括号如果使用new时，不带方括号，则使用 delete时，也不应带方括号。如果使用new时带方括号，则使用 delete时也应带方括号。C++的早期版本无法识别方括号表示法。然而，对于 ANSIISO标准来说，new与delete的格式不匹配导致的后果是不确定的，这意味着程序员不能依赖于某种特定的行为。下面是一个例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * pt = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">short * ps = <span class="keyword">new</span> short [<span class="number">500</span>];</span><br><span class="line"><span class="keyword">delete</span> [] pt;    <span class="comment">//不能这样做</span></span><br><span class="line"><span class="keyword">delete</span> ps;       <span class="comment">//不能这样做</span></span><br></pre></td></tr></table></figure><p>总之，使用new和delet时，应遵循以下规则。</p><ul><li>不要使用delet释放不是new分配的内存</li><li>不要使用delet释放同一个内存块两次。</li><li>如果使用new []为数组分配内存，则应使用delet[]释放</li><li>如果使用new[]为一个实体分配内存，则应使用delete(没有方括号)来释放。</li><li>对空指针应用delete时安全的。</li></ul><p>现在我们回过头来讨论动态数组。psome是指向一个int（数组第一个元素）的指针。你的责任是跟踪内存块中的元素个数。也就是说，由于编译器不能对 psome是指向10个整数中的第1个这种情况进行跟踪，因此编写程序时，必须让程序跟踪元素的数目。</p><p>实际上，程序确实跟踪了分配的内存量，以便以后使用 delete[]运算符时能够正确地释放这些内存，这种信息不是公用的，例如，不能使用 sizeof运算符来确定动态分配的数组包含的字节数。为数组分配内存的通用格式如下：</p><p>type_name * pointer_name = new type_name [num_elements];</p><p>使用new运算符可以确保内存块足以存储 num elements个类型为 type_name的元素，而pointer name将指向第1个元素。下面将会看到，可以以使用数组名的方式来使用 pointer_name。</p><p><strong>使用动态数组</strong></p><p>创建动态数组后，如何使用它呢？首先，从概念上考虑这个问题。下面的语句创建指针 psome，它指向包含10个int值的内存块中的第1个元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * psome = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">10</span>]; <span class="comment">//得到占10个int大小的内存块</span></span><br></pre></td></tr></table></figure><p>可以将它看作是一根指向该元素的手指。假设int占4个字节，则将手指沿正确的方向移动4个字节，手指将指向第2个元素。总共有10个元素，这就是手指的移动范围。因此，new语句提供了识别内存块中每个元素所需的全部信息。</p><p>现在从实际角度考虑这个问题。如何访问其中的元素呢？第一个元素不成问题。由于 psome指向数组的第1个元素，因此 <em>psome是第1个元素的值。这样，还有9个元素。如果没有使用过C语言，下面这种最简单的方法可能会令你大吃一惊：只要把指针当作数组名使用即可。也就是说，对于第1个元素，可以使用 psome[0]，而不是·</em> psome；对于第2个元素，可以使用 psome[1]，依此类推。这样，使用指针来访问动态数组就非常简单了，虽然还不知道为何这种方法管用。可以这样做的原因是，C和C++内部都使用指针来处理数组。数组和指针基本等价是C和C++的优点之一（这在有时候也是个问题，但这是另一码事）。首先，程序arraynew.cpp演示了如何使用new来创建动态数组以及使用数组表示法来访问元素；它还指出了指针和真正的数组名之间的根本差别。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">	<span class="keyword">double</span> * p3 = <span class="keyword">new</span> <span class="keyword">double</span> [<span class="number">3</span>];</span><br><span class="line">	p3[<span class="number">0</span>] = <span class="number">0.2</span>;</span><br><span class="line">	p3[<span class="number">1</span>] = <span class="number">0.5</span>;</span><br><span class="line">	p3[<span class="number">2</span>] = <span class="number">0.8</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"p3[1] is "</span> &lt;&lt; p3[<span class="number">1</span>] &lt;&lt; <span class="string">".\n"</span>;</span><br><span class="line">	p3 = p3 + <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Now p3[0] is"</span> &lt;&lt; p3[<span class="number">0</span>] &lt;&lt; <span class="string">" and "</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"p3[1] is "</span> &lt;&lt; p3[<span class="number">1</span>] &lt;&lt; <span class="string">".\n"</span>;</span><br><span class="line">	p3 = p3 - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">delete</span> [] p3;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;程序输出</span><br><span class="line">p3[1] is 0.5.</span><br><span class="line">Now p3[0] is 0.5 and p3[1] is 0.8.</span><br></pre></td></tr></table></figure><p>从中可知， arraynew.cpp将指针p3当作数组名来使用，p3[0]为第1个元素，依次类推。下面的代码行指出了数组名和指针之间的根本差别:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p3 = p3 + <span class="number">1</span>;   <span class="comment">//对与指针可行，对于数组则是不可行</span></span><br></pre></td></tr></table></figure><p>不能修改数组名的值。但指针是变量，因此可以修改它的值。请注意将p3加1的效果。表达式p3[0]现在指的是数组的第2个值。因此，将p3加1导致它指向第2个元素而不是第1个。将它减1后，指针将指向原来的值，这样程序便可以给 delete[]提供正确的地址。相邻的int地址通常相差2个字节或4个字节，而将p3加1后，它将指向下一个元素的地址，这表明指针算术有一些特别的地方。情况确实如此。</p></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> jackcywang</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://wangng.com/articles/6892c111.html/" title="C++之指针_1">https://wangng.com/articles/6892c111.html/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a><a href="/tags/%E6%8C%87%E9%92%88/" rel="tag"><i class="fa fa-tag"></i> 指针</a></div><div class="post-nav"><div class="post-nav-item"><a href="/articles/f19b90ab.html/" rel="prev" title="C++之指针_2"><i class="fa fa-chevron-left"></i> C++之指针_2</a></div><div class="post-nav-item"> <a href="/articles/869ca03d.html/" rel="next" title="C++之指针_3">C++之指针_3<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div><div class="tabs tabs-comment"><ul class="nav-tabs"><li class="tab"><a href="#comment-gitalk">gitalk</a></li><li class="tab"><a href="#comment-valine">valine</a></li></ul><div class="tab-content"><div class="tab-pane gitalk" id="comment-gitalk"><div class="comments" id="gitalk-container"></div></div><div class="tab-pane valine" id="comment-valine"><div class="comments" id="valine-comments"></div></div></div></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-指针简介"><span class="nav-number">1.</span> <span class="nav-text">1.指针简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2指针声明和初始化"><span class="nav-number">1.1.</span> <span class="nav-text">1.2指针声明和初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3指针和数字"><span class="nav-number">1.2.</span> <span class="nav-text">1.3指针和数字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4使用new来分配内存"><span class="nav-number">1.3.</span> <span class="nav-text">1.4使用new来分配内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5使用delete释放内存"><span class="nav-number">1.4.</span> <span class="nav-text">1.5使用delete释放内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6使用new创建动态数组"><span class="nav-number">1.5.</span> <span class="nav-text">1.6使用new创建动态数组</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">jackcywang</p><div class="site-description" itemprop="description">不经一番彻骨寒,怎得梅花扑鼻香</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">66</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">14</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">65</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/jackcywang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jackcywang" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:yourname@gmail.com" title="E-Mail → mailto:yourname@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i> E-Mail</a></span><span class="links-of-author-item"><a href="https://blog.csdn.net/weixin_42631693" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_42631693" rel="noopener" target="_blank"><i class="fa fa-fw fa-CSDN"></i> CSDN</a></span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/hao-han-zhong-de-yipian-xie" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;hao-han-zhong-de-yipian-xie" rel="noopener" target="_blank"><i class="fa fa-fw fa-知乎"></i> 知乎</a></span></div></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; 2019 – <span itemprop="copyrightYear">2020</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">jackcywang</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-area-chart"></i></span> <span title="站点总字数">261k</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span title="站点阅读时长">3:57</span></div><span id="sitetime"></span><script language="javascript">function siteTime(){window.setTimeout("siteTime()",1e3);var e=36e5,t=24*e,o=new Date,i=o.getFullYear(),n=o.getMonth()+1,a=o.getDate(),r=o.getHours(),s=o.getMinutes(),g=o.getSeconds(),l=Date.UTC(2020,1,1,15,0,0),m=Date.UTC(i,n,a,r,s,g)-l,M=Math.floor(m/t),T=Math.floor((m-M*t)/e),u=Math.floor((m-M*t-T*e)/6e4),f=Math.floor((m-M*t-T*e-6e4*u)/1e3);document.getElementById("sitetime").innerHTML=" 在此已等候"+M+" 天 "+T+" 小时 "+u+" 分钟 "+f+" 秒"}siteTime()</script><div> <a href="http://www.miitbeian.gov.cn/" rel="noopener" target="_blank">陕ICP备19023518号-1</a> <span class="post-meta-divider">|</span> <span style="padding-left:25px;background:url(/images/beian.png) no-repeat left center" rel="nofollow"><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=61019002001038" rel="noopener" target="_blank">陕公网安备61019002001038号</a></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script async src="/js/cursor/fireworks.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/moment.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment-precise-range-plugin@1.3.0/moment-precise-range.min.js"></script><script>
    function timer() {
      var ages = moment.preciseDiff(moment(),moment(20191220,"YYYYMMDD"));
      //去除时分秒信息
      ages = ages.replace(/\s?\d{0,2}\s+hours?/, "");
      ages = ages.replace(/\s?\d{0,2}\s+minutes?/, "");
      ages = ages.replace(/\s?\d{0,2}\s+seconds?/, "");
      //将年月日转换为中文
      ages = ages.replace(/years?/, "年");
      ages = ages.replace(/months?/, "月");
      ages = ages.replace(/days?/, "天");
      ages = ages.replace(/\d+/g, '<span style="color:#1890ff">$&</span>');
      span.innerHTML = `footer.age ${ages}`;
    }
    var span = document.createElement("span");
    //插入到agesicon之后
    var agesicon = document.querySelector(".footer-ages-icon");
    document.querySelector(".copyright").insertBefore(span, agesicon.nextSibling);
    timer();
  </script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css"><script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '500094376d9d18a3ed06',
      clientSecret: '71db1de3f4d19d73479a0ad6887d90081e8b7ca1',
      repo        : 'MyGitalk',
      owner       : 'jackcywang',
      admin       : ['jackcywang'],
      id          : '2dfbb0fb4d1df888d4f0c8b8052dfa3d',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script><script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'qHl8YMnB0b5OHNGx0AO0fjIE-gzGzoHsz',
      appKey     : 'wN3c6hhMnkEwVWOSLF0xQ3In',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script><script src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><script src="https://player.lmih.cn/player/js/player.js" id="myhk" key="158704924834" m="1"></script></body></html>