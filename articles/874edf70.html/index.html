<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.2.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css"><script src="/lib/pace/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"wangng.com",root:"/",scheme:"Pisces",version:"7.7.2",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!1,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="论文：Deformable Convolutional Networks代码：github"><meta property="og:type" content="article"><meta property="og:title" content="DCN可变形卷积"><meta property="og:url" content="https://wangng.com/articles/874edf70.html/index.html"><meta property="og:site_name" content="jackcywang&#39;s blog"><meta property="og:description" content="论文：Deformable Convolutional Networks代码：github"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://wangng.com/articles/874edf70.html/img1.png"><meta property="og:image" content="https://wangng.com/articles/874edf70.html/fig2.png"><meta property="og:image" content="https://wangng.com/articles/874edf70.html/fig5.png"><meta property="og:image" content="https://wangng.com/articles/874edf70.html/fig3.png"><meta property="og:image" content="https://wangng.com/articles/874edf70.html/fig6.png"><meta property="og:image" content="https://wangng.com/articles/874edf70.html/res.png"><meta property="article:published_time" content="2019-07-22T11:25:32.000Z"><meta property="article:modified_time" content="2020-06-22T05:33:16.653Z"><meta property="article:author" content="jackcywang"><meta property="article:tag" content="Object Detection"><meta property="article:tag" content="DCN"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://wangng.com/articles/874edf70.html/img1.png"><link rel="canonical" href="https://wangng.com/articles/874edf70.html/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>DCN可变形卷积 | jackcywang's blog</title><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?8ce866754ae6c95a7238894d36ad3ab0";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div> <a href="https://github.com/jackcywang" target="_blank" rel="noopener" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#64ceaa;color:#fff;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">jackcywang's blog</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">梦想与现实只在一念之间</p></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i> 关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i> 归档</a></li></ul></nav></div></header><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://wangng.com/articles/874edf70.html/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="jackcywang"><meta itemprop="description" content="不经一番彻骨寒,怎得梅花扑鼻香"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="jackcywang's blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> DCN可变形卷积</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-07-22 19:25:32" itemprop="dateCreated datePublished" datetime="2019-07-22T19:25:32+08:00">2019-07-22</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Deeplearning/" itemprop="url" rel="index"><span itemprop="name">Deeplearning</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Deeplearning/Object-Detection/" itemprop="url" rel="index"><span itemprop="name">Object Detection</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i></span> <span class="post-meta-item-text">Valine：</span><a title="valine" href="/articles/874edf70.html/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/articles/874edf70.html/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>6.5k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>6 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><p>论文：<a href="https://arxiv.org/pdf/1703.06211.pdf" target="_blank" rel="noopener">Deformable Convolutional Networks</a><br>代码：<a href="https://github.com/oeway/pytorch-deform-conv" target="_blank" rel="noopener">github</a></p><a id="more"></a><h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><p>　　由于卷积神经网络是通过卷积核这种固定的几何结构来提取特征的，比如$3\times3$、$5\times5$这种大小结构固定的卷积核，但是这种几何固定的提取特征的方式对目标物体的大小尺寸、姿态、视角、位置变化是不敏感的。通常应对这种情况的解决方式有两种：1)采用数据增强的方式来得到更大不同视角、不同几何变换后的数据集，如仿射变换；2)使用具有平移不变性的特征或算法等，如SIFT特征。事实这两种方式还是有各自缺陷的，方式1)由于数据更多了，训练变得困难了,而且对于不同数据集得采用不同得增强方式;方式2)则是人工很难设计这种有效特征或者设计的特征不具有适应性.<br>　　<br>　　还有池化层，池化层以固定的比例大小进行池化，即使是ROI pooling也是将ROI分割到固定的目标区域中去。这些特性是有影响的，例如，在同一Conv层中，所有的激活单元的感受野是一样的，但由于不同位置可能对应着不同尺度或形变的物体，因此对尺度或者感受野大小进行自适应是进行精确定位所需要的。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>　　论文针对上述两个问题分别提出了可变形卷积(Deformable Convolutional)和可变形感兴趣区域池化(deformable ROI Pooling)来提高目标不同形变的建模能力.<strong>这两种特征提取方式都是在各自原有的基础上加上可学习的偏置来实现变形卷积,变形池化.从而使得卷积核能集中于感兴趣的区域</strong>.</p><p><img src="/articles/874edf70.html/img1.png" alt><br>(a)是常见的3x3卷积核的采样方式，(b)是采样可变形卷积，加上偏移量之后的采样点的变化，其中(c)(d)是可变形卷积的特殊形式</p><h3 id="Deformable-Convolutional"><a href="#Deformable-Convolutional" class="headerlink" title="Deformable Convolutional"></a>Deformable Convolutional</h3><p>　　CNN中的特征映射和卷积是3D的。可变形卷积和RoI池化模块都在2D空间域上运行。在整个通道维度上的操作保持不变。常规的2D卷积包含两个步骤:1)使用一个规则的栅格$\mathcal{R}$对输入特征进行采样;2)对采样的值用权重w线性求和.栅格$\mathcal{R}$定义的是感受野大小和空洞率,如下表示的是感受野大小是$3\times3$,空洞率是1的栅格$\mathcal{R}$.</p><script type="math/tex;mode=display">
\mathcal{R}=\{(-1,-1),(-1,0), \ldots,(0,1),(1,1)\}</script><p>对于输出特征$\mathbf{y}$中每个位置$\mathbf{p}_{0}$,我们有</p><script type="math/tex;mode=display">
\mathbf{y}\left(\mathbf{p}_{0}\right)=\sum_{\mathbf{p}_{n} \in \mathcal{R}} \mathbf{w}\left(\mathbf{p}_{n}\right) \cdot \mathbf{x}\left(\mathbf{p}_{0}+\mathbf{p}_{n}\right)\tag{1}</script><p>这里$\mathbf{p}_{n}$是$\mathcal{R}$中所有位置.(这里我的理解是p表示postion,以$p_0$为基准,$p_n$相对于$p_0$的位置是$p_0+p_n$)</p><p>　　而在可变形卷积中，栅格$\mathcal{R}$还增加了不同位置的偏置$\left{\Delta \mathbf{p}_{n} | n=1, \ldots, N\right}$,所以(1)式变成了</p><script type="math/tex;mode=display">
\mathbf{y}\left(\mathbf{p}_{0}\right)=\sum_{\mathbf{p}_{n} \in \mathcal{R}} \mathbf{w}\left(\mathbf{p}_{n}\right) \cdot \mathbf{x}\left(\mathbf{p}_{0}+\mathbf{p}_{n}+\Delta \mathbf{p}_{n}\right)\tag{2}</script><p>也就是说<strong>可变形卷积在原本卷积的基础上加了一个偏移量</strong>，需要注意的是，这个偏移量是位置的偏移量.通俗一点讲，某个点位于原图的（0,0）位置，有了偏移量之后，可能位于（1.1,2.3）的位置。通常$\Delta \mathbf{p}_{n}$是小数,所以(2)式的实现是通过非线性插值来实现的</p><script type="math/tex;mode=display">
\mathbf{x}(\mathbf{p})=\sum_{\mathbf{q}} G(\mathbf{q}, \mathbf{p}) \cdot \mathbf{x}(\mathbf{q})\tag{3}</script><p>其中$\mathbf{p}=\mathbf{p}<em>{0}+\mathbf{p}</em>{n}+\Delta \mathbf{p}_{n}$,而$\mathbf{q}$是特征图$\mathbf{x}$中所有空间位置点的集合,$G(\cdot, \cdot)$是<strong>非线性插值核</strong>并且$G$是二维的,它能分解成两个一维的核.</p><script type="math/tex;mode=display">
G(\mathbf{q}, \mathbf{p})=g\left(q_{x}, p_{x}\right) \cdot g\left(q_{y}, p_{y}\right)\tag{4}</script><p>并且有$g(a, b)=\max (0,1-|a-b|)$</p><p><img src="/articles/874edf70.html/fig2.png" alt></p><p>上图演示了一个$3\times3$变形卷积的过程.输入特征图是$H\times W\times N$,经过一个普通卷积,填充为same,得到$H\times W\times 2N$的offset field,由于偏移量有x,y两个方向,所有通道数为2N.offset field里的偏移量是卷积得到的，可能是浮点数，所以需要通过双向性插值计算偏移位置的特征值。在偏移量的学习中，梯度是通过双线性插值来进行反向传播的。</p><p>具体的:<br>1、原始图片batch（大小为$b\times h\times w\times c$），记为U，经过一个普通卷积，卷积填充为same，即输出输入大小不变，对应的输出结果为($b\times h\times w\times 2c$)，记为V，输出的结果是指原图片batch中每个像素的偏移量（x偏移与y偏移，因此为2c）。<br>2、将U中图片的像素索引值(位置$\mathbf{p}<em>{0}+\mathbf{p}</em>{n}$)与V(偏移量$\Delta \mathbf{p}<em>{n}$)相加，得到偏移后的position(即在原始图片U中的坐标值$\mathbf{p}</em>{0}+\mathbf{p}<em>{n}+\Delta \mathbf{p}</em>{n}$)，需要将position值限定为图片大小以内。position的大小为($b\times h\times w\times 2c$)，但position只是一个坐标值，而且还是float类型的，我们需要这些float类型的坐标值获取像素。<br>3、例如position中一个坐标值(a,b)，将其转换为四个整数，floor(a), ceil(a), floor(b), ceil(b)，将这四个整数进行整合，得到四对坐标（floor(a),floor(b)), ((floor(a),ceil(b)), ((ceil(a),floor(b)), ((ceil(a),ceil(b))。这四对坐标每个坐标都对应U中的一个像素值，而我们需要得到(a,b)的像素值，这里采用双线性差值的方式计算（一方面得到的像素准确，另一方面可以进行反向传播）。<br>4、在得到position的所有像素后，即得到了一个新图片M，将这个新图片M作为输入数据输入到别的层中，如普通卷积。</p><p>代码如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConvOffset2D</span><span class="params">(nn.Conv2d)</span>:</span></span><br><span class="line">    <span class="string">"""ConvOffset2D</span></span><br><span class="line"><span class="string">    Convolutional layer responsible for learning the 2D offsets and output the</span></span><br><span class="line"><span class="string">    deformed feature map using bilinear interpolation</span></span><br><span class="line"><span class="string">    Note that this layer does not perform convolution on the deformed feature</span></span><br><span class="line"><span class="string">    map. See get_deform_cnn in cnn.py for usage</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, filters, init_normal_stddev=<span class="number">0.01</span>, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""Init</span></span><br><span class="line"><span class="string">        Parameters</span></span><br><span class="line"><span class="string">        ----------</span></span><br><span class="line"><span class="string">        filters : int</span></span><br><span class="line"><span class="string">            Number of channel of the input feature map</span></span><br><span class="line"><span class="string">        init_normal_stddev : float</span></span><br><span class="line"><span class="string">            Normal kernel initialization</span></span><br><span class="line"><span class="string">        **kwargs:</span></span><br><span class="line"><span class="string">            Pass to superclass. See Con2d layer in pytorch</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.filters = filters</span><br><span class="line">        self._grid_param = <span class="literal">None</span></span><br><span class="line">        super(ConvOffset2D, self).__init__(self.filters, self.filters * <span class="number">2</span>, <span class="number">3</span>, padding=<span class="number">1</span>, bias=<span class="literal">False</span>, **kwargs)</span><br><span class="line">        self.weight.data.copy_(self._init_weights(self.weight, init_normal_stddev))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""Return the deformed featured map"""</span></span><br><span class="line">        x_shape = x.size()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># (b, 2c, h, w)</span></span><br><span class="line">        offsets = super(ConvOffset2D, self).forward(x)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># (b*c, h, w, 2)表示共有b*c个图片，每个图片为h*w大小，每个像素对应2个方向</span></span><br><span class="line">        offsets = self._to_bc_h_w_2(offsets, x_shape)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># (b*c, h, w)</span></span><br><span class="line">        x = self._to_bc_h_w(x, x_shape)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># X_offset: (b*c, h*w)    grid:(b*c, h*w, 2)</span></span><br><span class="line">        x_offset = th_batch_map_offsets(x, offsets, grid=self._get_grid(self, x))</span><br><span class="line">        <span class="comment"># x_offset: (b, c, h, w)</span></span><br><span class="line">        x_offset = self._to_b_c_h_w(x_offset, x_shape)</span><br><span class="line">        <span class="keyword">return</span> x_offset</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get_grid</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        batch_size, input_size = x.size(<span class="number">0</span>), (x.size(<span class="number">1</span>), x.size(<span class="number">2</span>))</span><br><span class="line">        dtype, cuda = x.data.type(), x.data.is_cuda</span><br><span class="line">        <span class="keyword">if</span> self._grid_param == (batch_size, input_size, dtype, cuda):</span><br><span class="line">            <span class="keyword">return</span> self._grid</span><br><span class="line">        self._grid_param = (batch_size, input_size, dtype, cuda)</span><br><span class="line">        self._grid = th_generate_grid(batch_size, input_size, dtype, cuda)</span><br><span class="line">        <span class="keyword">return</span> self._grid</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_init_weights</span><span class="params">(weights, std)</span>:</span></span><br><span class="line">        fan_out = weights.size(<span class="number">0</span>)</span><br><span class="line">        fan_in = weights.size(<span class="number">1</span>) * weights.size(<span class="number">2</span>) * weights.size(<span class="number">3</span>)</span><br><span class="line">        w = np.random.normal(<span class="number">0.0</span>, std, (fan_out, fan_in))</span><br><span class="line">        <span class="keyword">return</span> torch.from_numpy(w.reshape(weights.size()))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_to_bc_h_w_2</span><span class="params">(x, x_shape)</span>:</span></span><br><span class="line">        <span class="string">"""(b, 2c, h, w) -&gt; (b*c, h, w, 2)"""</span></span><br><span class="line">        x = x.contiguous().view(<span class="number">-1</span>, int(x_shape[<span class="number">2</span>]), int(x_shape[<span class="number">3</span>]), <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_to_bc_h_w</span><span class="params">(x, x_shape)</span>:</span></span><br><span class="line">        <span class="string">"""(b, c, h, w) -&gt; (b*c, h, w)"""</span></span><br><span class="line">        x = x.contiguous().view(<span class="number">-1</span>, int(x_shape[<span class="number">2</span>]), int(x_shape[<span class="number">3</span>]))</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_to_b_c_h_w</span><span class="params">(x, x_shape)</span>:</span></span><br><span class="line">        <span class="string">"""(b*c, h, w) -&gt; (b, c, h, w)"""</span></span><br><span class="line">        x = x.contiguous().view(<span class="number">-1</span>, int(x_shape[<span class="number">1</span>]), int(x_shape[<span class="number">2</span>]), int(x_shape[<span class="number">3</span>]))</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p></p><h3 id="可变形卷积特征提取"><a href="#可变形卷积特征提取" class="headerlink" title="可变形卷积特征提取"></a>可变形卷积特征提取</h3><p><img src="/articles/874edf70.html/fig5.png" alt><br>通过对比可以明显的看出，可变形卷积的采样位置更符合物体本身的形状和尺寸，而标准卷积的形式却不能做到这一点。</p><h3 id="Deformable-ROI-Pooling"><a href="#Deformable-ROI-Pooling" class="headerlink" title="Deformable ROI Pooling"></a>Deformable ROI Pooling</h3><p>　　ROI pooling被用在目标检测中的region proposal中,它能将任意大小的矩形框转换成固定大小的输出特征.假设输入特征图是$\mathbf{x}$,$\mathbf{p_{0}}$是左上角位置并且ROI的大小是$w\times h$,ROI pooling会将ROI分成$k\times k$个小矩形框最后输出$k\times k$的特征图$\mathbf{y}$.对于第(i,j)个小矩形框($0\le i,j \le k$),我们有</p><script type="math/tex;mode=display">
\mathbf{y}(i, j)=\sum_{\mathbf{p} \in \operatorname{bin}(i, j)} \mathbf{x}\left(\mathbf{p}_{0}+\mathbf{p}\right) / n_{i j}\tag{5}</script><p>$n<em>{i j}$为第$i,j$个小矩形块中包含的像素的个数,第$i,j$个小矩形块$bin</em>{i,j}$的范围是$\left\lfloor i \frac{w}{k}\right\rfloor \leq p<em>{x}&lt;\left\lceil(i+1) \frac{w}{k}\right\rceil$和$\left\lfloor j \frac{h}{k}\right\rfloor \leq p</em>{y}&lt;\left\lceil(j+1) \frac{h}{k}\right\rceil$.<br>而对于Deformable ROI Pooling,会在每个小矩形块$bin<em>{i,j}$加上一个偏置$\left{\Delta \mathbf{p}</em>{i j} | 0 \leq i, j&lt;k\right}$,</p><script type="math/tex;mode=display">
\mathbf{y}(i, j)=\sum_{\mathbf{p} \in \text {bin}(i, j)} \mathbf{x}\left(\mathbf{p}_{0}+\mathbf{p}+\Delta \mathbf{p}_{i j}\right) / n_{i j}\tag{6}</script><p>通常$\Delta \mathbf{p}_{i j}$是小数,所以上式需要非线性插值公式(3)(4)来实现.</p><p><img src="/articles/874edf70.html/fig3.png" alt><br>　　具体操作为,首先,通过普通的ROI Pooling得到一个feature map,通过得到的这个feature map,加上一个全连接层,生成每一个位置的offset，然后按照上面的公式得到$\Delta \mathbf{p}_{i j}$,为了让offset的数据和ROI 的尺寸匹配，需要对offset进行微调。全连接层的参数可以通过反向传播进行学习。</p><p>　　原始的RoIPooling在操作过程中是将RoI划分为k×k个子区域。而Deformable RoIPooling的偏移量其实就是子区域的偏移，也就是说k×k个子区域不在紧挨在一起，而是每一个都有一个偏移，偏移量有k×k个。与可变形卷积不同的是，Deformable RoIPooling的偏移量是通过全连接层得到的。</p><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p><img src="/articles/874edf70.html/fig6.png" alt><br><img src="/articles/874edf70.html/res.png" alt></p></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> jackcywang</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://wangng.com/articles/874edf70.html/" title="DCN可变形卷积">https://wangng.com/articles/874edf70.html/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Object-Detection/" rel="tag"><i class="fa fa-tag"></i> Object Detection</a><a href="/tags/DCN/" rel="tag"><i class="fa fa-tag"></i> DCN</a></div><div class="post-nav"><div class="post-nav-item"><a href="/articles/fae94215.html/" rel="prev" title="目标跟踪之SiamFC:基于全卷积孪生网络的目标跟踪"><i class="fa fa-chevron-left"></i> 目标跟踪之SiamFC:基于全卷积孪生网络的目标跟踪</a></div><div class="post-nav-item"> <a href="/articles/e7ccb3bf.html/" rel="next" title="C++之类与对象">C++之类与对象<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div><div class="tabs tabs-comment"><ul class="nav-tabs"><li class="tab"><a href="#comment-gitalk">gitalk</a></li><li class="tab"><a href="#comment-valine">valine</a></li></ul><div class="tab-content"><div class="tab-pane gitalk" id="comment-gitalk"><div class="comments" id="gitalk-container"></div></div><div class="tab-pane valine" id="comment-valine"><div class="comments" id="valine-comments"></div></div></div></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#背景介绍"><span class="nav-number">1.</span> <span class="nav-text">背景介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简介"><span class="nav-number">2.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Deformable-Convolutional"><span class="nav-number">3.</span> <span class="nav-text">Deformable Convolutional</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可变形卷积特征提取"><span class="nav-number">4.</span> <span class="nav-text">可变形卷积特征提取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Deformable-ROI-Pooling"><span class="nav-number">5.</span> <span class="nav-text">Deformable ROI Pooling</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实验结果"><span class="nav-number">6.</span> <span class="nav-text">实验结果</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">jackcywang</p><div class="site-description" itemprop="description">不经一番彻骨寒,怎得梅花扑鼻香</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">66</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">15</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">66</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/jackcywang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jackcywang" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:yourname@gmail.com" title="E-Mail → mailto:yourname@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i> E-Mail</a></span><span class="links-of-author-item"><a href="https://blog.csdn.net/weixin_42631693" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_42631693" rel="noopener" target="_blank"><i class="fa fa-fw fa-CSDN"></i> CSDN</a></span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/hao-han-zhong-de-yipian-xie" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;hao-han-zhong-de-yipian-xie" rel="noopener" target="_blank"><i class="fa fa-fw fa-知乎"></i> 知乎</a></span></div></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; 2019 – <span itemprop="copyrightYear">2020</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">jackcywang</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-area-chart"></i></span> <span title="站点总字数">263k</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span title="站点阅读时长">3:59</span></div><span id="sitetime"></span><script language="javascript">function siteTime(){window.setTimeout("siteTime()",1e3);var e=36e5,t=24*e,o=new Date,i=o.getFullYear(),n=o.getMonth()+1,a=o.getDate(),r=o.getHours(),s=o.getMinutes(),g=o.getSeconds(),l=Date.UTC(2020,1,1,15,0,0),m=Date.UTC(i,n,a,r,s,g)-l,M=Math.floor(m/t),T=Math.floor((m-M*t)/e),u=Math.floor((m-M*t-T*e)/6e4),f=Math.floor((m-M*t-T*e-6e4*u)/1e3);document.getElementById("sitetime").innerHTML=" 在此已等候"+M+" 天 "+T+" 小时 "+u+" 分钟 "+f+" 秒"}siteTime()</script><div> <a href="http://www.miitbeian.gov.cn/" rel="noopener" target="_blank">陕ICP备19023518号-1</a> <span class="post-meta-divider">|</span> <span style="padding-left:25px;background:url(/images/beian.png) no-repeat left center" rel="nofollow"><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=61019002001038" rel="noopener" target="_blank">陕公网安备61019002001038号</a></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script><script async src="/js/cursor/fireworks.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/moment.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment-precise-range-plugin@1.3.0/moment-precise-range.min.js"></script><script>
    function timer() {
      var ages = moment.preciseDiff(moment(),moment(20191220,"YYYYMMDD"));
      //去除时分秒信息
      ages = ages.replace(/\s?\d{0,2}\s+hours?/, "");
      ages = ages.replace(/\s?\d{0,2}\s+minutes?/, "");
      ages = ages.replace(/\s?\d{0,2}\s+seconds?/, "");
      //将年月日转换为中文
      ages = ages.replace(/years?/, "年");
      ages = ages.replace(/months?/, "月");
      ages = ages.replace(/days?/, "天");
      ages = ages.replace(/\d+/g, '<span style="color:#1890ff">$&</span>');
      span.innerHTML = `footer.age ${ages}`;
    }
    var span = document.createElement("span");
    //插入到agesicon之后
    var agesicon = document.querySelector(".footer-ages-icon");
    document.querySelector(".copyright").insertBefore(span, agesicon.nextSibling);
    timer();
  </script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css"><script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '500094376d9d18a3ed06',
      clientSecret: '71db1de3f4d19d73479a0ad6887d90081e8b7ca1',
      repo        : 'MyGitalk',
      owner       : 'jackcywang',
      admin       : ['jackcywang'],
      id          : '8d038191c518a0d1fcb3c452d8172f32',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script><script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'qHl8YMnB0b5OHNGx0AO0fjIE-gzGzoHsz',
      appKey     : 'wN3c6hhMnkEwVWOSLF0xQ3In',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script><script src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><script src="https://player.lmih.cn/player/js/player.js" id="myhk" key="158704924834" m="1"></script></body></html>