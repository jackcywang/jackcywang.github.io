<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.2.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css"><script src="/lib/pace/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"wangng.com",root:"/",scheme:"Pisces",version:"7.7.2",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!1,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="使用new创建动态结构在运行时创建数组优于在编译时创建数组，对于结构也是如此。需要在程序运行时为结构分配所需的空间，这也可以使用new运算符来完成。通过使用new，可以创建动态结构。同样，“动态”意味着内存是在运行时，而不是编译时分配的。由于类与结构非常相似，因此这里介绍的有关结构的技术也适用于类。 将new用于结构由两步组成：创建结构和访问其成员。要创建结构，需要同时使用结构类型和new例如，要"><meta property="og:type" content="article"><meta property="og:title" content="C++之指针_3"><meta property="og:url" content="https://wangng.com/articles/869ca03d.html/index.html"><meta property="og:site_name" content="jackcywang&#39;s blog"><meta property="og:description" content="使用new创建动态结构在运行时创建数组优于在编译时创建数组，对于结构也是如此。需要在程序运行时为结构分配所需的空间，这也可以使用new运算符来完成。通过使用new，可以创建动态结构。同样，“动态”意味着内存是在运行时，而不是编译时分配的。由于类与结构非常相似，因此这里介绍的有关结构的技术也适用于类。 将new用于结构由两步组成：创建结构和访问其成员。要创建结构，需要同时使用结构类型和new例如，要"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://cdn.wangng.com/C++/C++%E4%B9%8B%E6%8C%87%E9%92%88_3/img1.png"><meta property="article:published_time" content="2019-07-05T10:49:52.000Z"><meta property="article:modified_time" content="2020-04-25T14:48:59.742Z"><meta property="article:author" content="jackcywang"><meta property="article:tag" content="C++"><meta property="article:tag" content="指针"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://cdn.wangng.com/C++/C++%E4%B9%8B%E6%8C%87%E9%92%88_3/img1.png"><link rel="canonical" href="https://wangng.com/articles/869ca03d.html/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>C++之指针_3 | jackcywang's blog</title><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?8ce866754ae6c95a7238894d36ad3ab0";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div> <a href="https://github.com/jackcywang" target="_blank" rel="noopener" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#64ceaa;color:#fff;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">jackcywang's blog</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">梦想与现实只在一念之间</p></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i> 关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i> 归档</a></li></ul></nav></div></header><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://wangng.com/articles/869ca03d.html/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="jackcywang"><meta itemprop="description" content="不经一番彻骨寒,怎得梅花扑鼻香"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="jackcywang's blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> C++之指针_3</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-07-05 18:49:52" itemprop="dateCreated datePublished" datetime="2019-07-05T18:49:52+08:00">2019-07-05</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i></span> <span class="post-meta-item-text">Valine：</span><a title="valine" href="/articles/869ca03d.html/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/articles/869ca03d.html/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">本文字数：</span> <span>5k</span></span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span>5 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="使用new创建动态结构"><a href="#使用new创建动态结构" class="headerlink" title="使用new创建动态结构"></a>使用new创建动态结构</h3><p><strong>在运行时创建数组优于在编译时创建数组，对于结构也是如此</strong>。需要在程序运行时为结构分配所需的空间，这也可以使用new运算符来完成。通过使用new，可以创建动态结构。同样，“动态”意味着内存是在运行时，而不是编译时分配的。由于类与结构非常相似，因此这里介绍的有关结构的技术也适用于类。</p><p>将new用于结构由两步组成：创建结构和访问其成员。要创建结构，需要同时使用结构类型和new例如，要创建一个未命名的 inflatable类型，并将其地址赋给一个指针，可以这样做：<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inflatable * ps = <span class="keyword">new</span> inflatable;</span><br></pre></td></tr></table></figure><br>这将把存储inflatable结构的一块可用内存的地址赋给ps。<strong>创建动态结构时，不能将成员运算符句点用于结构名，因为这种结构没有名称</strong>，只是知道它的地址。C++专门为这种情况提供了一个运算符：箭头成员运算符（-&gt;）。该运算符由连字符和大于号组成，可用于指向结构的指针，就像点运算符可用于结构名一样。例如，如果ps指向一个inflatable结构，则ps-&gt;price是被指向的结构的price成员。<p></p><div align="center"> <img src="http://cdn.wangng.com/C++/C++之指针_3/img1.png"></div><blockquote><p>提示：有时，C++新手在指定结构成员时，搞不清楚何时应使用句点运算符，何时应使用箭头运算符规则非常简单。如果结构标识符是结构名，如grubnose，则使用句点运算符；如果标识符是指向结构的指针，如pt，则使用箭头运算符</p></blockquote><p>另一种访问结构成员的方法是，如果ps是指向结构的指针，则<code>*ps</code>就是被指向的值—结构本身。由于<code>*ps</code>是一个结构，因此(<code>*ps</code>).price是该结构的price成员。C++的运算符优先规则要求使用括号。示例程序使用new创建了一个未命名的结构，并演示了两种访问结构成员的指针表示法。<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序4.21 newstrct.cpp  使用new创建结构体</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inflatable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">float</span> volume;</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    inflatable * ps = <span class="keyword">new</span> inflatable;   <span class="comment">//为inflatable结构分配内存</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter name of inflatable item: "</span>;</span><br><span class="line">    <span class="built_in">cin</span>.<span class="built_in">get</span>(ps-&gt;name,<span class="number">20</span>);   <span class="comment">//结构成员的方法一</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter volume in cubic feet: "</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; (*ps).volume;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter price: $"</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; ps-&gt;name;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Name: "</span> &lt;&lt; (*ps).name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Volume"</span> &lt;&lt; ps-&gt;volume &lt;&lt; <span class="string">"cubic feet\n"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Price: $"</span> &lt;&lt; ps-&gt;price &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> ps;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>程序输出<br>Enter name of inflatable item: Fabulous Frodo<br>Enter volume in cubic feet: 1.4<br>Enter price: 27.99<br>Name: Fabulous Frodo<br>Volume: 1.4 cubic feet<br>Price： 27.99</p></blockquote><h4 id="一个使用new和delete的示例"><a href="#一个使用new和delete的示例" class="headerlink" title="一个使用new和delete的示例"></a>一个使用new和delete的示例</h4><p>下面介绍一个使用new和 delete来存储通过键盘输入的字符串的示例，下面程序定义了一个函数getname()，该函数返回一个指向输入字符串的指针，该函数将输入读入到一个大型的临时数组中，然后使用new[]创建一个刚好能够存储该输入字符串的内存块，并返回一个指向该内存块的指针。对于读取大量字符串的程序，这种方法可以节省大量内存（实际编写程序时，使用 string类将更容易，因为这样可以使用内置的new和 delete）</p><p>假设程序要读取100个字符串，其中最大的字符串包含79个字符，而大多数字符串都短得多。如果用char数组来存储这些字符串，则需要1000个数组，其中每个数组的长度为80个字符。这总共需要80000个字节，而其中的很多内存没有被使用。另一种方法是，创建一个数组，它包含1000个指向char的指针,然后使用new根据每个字符串的需要分配相应数量的内存，这将节省几万个字节。<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序清单4.22 delete.cpp</span></span><br><span class="line"><span class="comment">//delete.cpp     使用删除操作</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;  //或者string.h</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">getname</span><span class="params">(<span class="keyword">void</span>)</span></span>;  <span class="comment">//函数声名</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * name;       <span class="comment">//创建一个未初始化的指针</span></span><br><span class="line">    name = getname();   <span class="comment">//将字符串的地址赋给name</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">" at "</span> &lt;&lt; (<span class="keyword">int</span>*)name &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">delete</span> [] name;    <span class="comment">//释放内存</span></span><br><span class="line"></span><br><span class="line">    name = getname();  <span class="comment">//重新使用释放的内存</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">" at "</span> &lt;&lt; (<span class="keyword">int</span>*) name &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">delete</span> [] name;    <span class="comment">//内存再次释放</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">getname</span><span class="params">()</span>      <span class="comment">//返回新字符串的地址</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> temp[<span class="number">80</span>];    <span class="comment">//临时存储</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter last name: "</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">    <span class="keyword">char</span> * pn = <span class="keyword">new</span> <span class="keyword">char</span> [<span class="built_in">strlen</span>(temp)+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(pn,temp);  <span class="comment">//赋值字符串到较小的空间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pn;       <span class="comment">//当函数结束时temp被丢失</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>程序输出<br>Enter last name: Fredeldumpkin<br>Fredeldumpkin at 0x12e1358<br>Enter last name: Pook<br>Pook at 0x12e1358</p></blockquote><p>函数getname()它使用cin将输入的单词放到temp数组中，然后使用new分配新内存，以存储该单词。程序需要strlen(temp)+1个字符（包括空字符）来存储该字符串，因此将这个值提供给new。获得空间后,getname()使用标准库函数 strcpy（将temp中的字符串复制到新的内存块中。该函数并不检查内存块是否能够容纳字符串，但 getname（）通过使用new请求合适的字节数来完成了这样的工作。最后，函数返回pn，这是字符串副本的地址。</p><p>在main()中，返回值（地址）被赋给指针name.该指针是在main()中定义的，但它指向 getname()函数中分配的内存块。然后，程序打印该字符串及其地址。</p><p>在这个例子中， getname()分配内存，而main()释放内存，将new和 delete放在不同的函数中通常井不是个好办法，因为这样很容易忘记使用 delete.不过这个例子确实把new和 delete分开放置了，只是为了说明这样做也是可以的。</p><h3 id="自动存储、静态存储和动态存储"><a href="#自动存储、静态存储和动态存储" class="headerlink" title="自动存储、静态存储和动态存储"></a>自动存储、静态存储和动态存储</h3><p>根据用于分配内存的方法，C+有3种管理数据内存的方式：自动存储、静态存储和动态存储（有时也叫作自由存储空间或堆）。在存在时间的长短方面，以这3种方式分配的数据对象各不相同。下面简要地介绍每种类型(C++11新增了第四种类型—-线性存储)</p><h4 id="自动存储"><a href="#自动存储" class="headerlink" title="自动存储"></a>自动存储</h4><p>在函数内部定义的常规变量使用自动存储空间，被称为自动变量,这意味着它们在所属函数被调用时自动产生，在该函数结束时消亡。如上面4.22程序中temp数组仅当getname()函数活动时存在，当程序控制权回到main()时，temp使用的内存被自动释放。如果getname()返回temp的地址,则main()中的name指针指向的内存将很快得到重新使用，这就是在getname()中使用new的原因。</p><p>实际上，自动变量是一个局部变量，其作用域为包含它的代码块。代码块是被包含在花括号中的一段代码。如果在其中的某个代码块定义了一个变量，则该变量仅在程序执行该代码块中的代码时存在。</p><p><strong>自动变量通常存储在栈中。这意味着执行代码块时，其中的变量将依次加入到栈中，而在离开代码块时，将按相反的顺序释放这些变量，这被称为后进先出（LIFO）</strong>。因此，在程序执行过程中，栈将不断地增大和缩小。</p><h4 id="静态存储"><a href="#静态存储" class="headerlink" title="静态存储"></a>静态存储</h4><p><strong>静态存储是整个程序执行期间都存在的存储方式</strong>。使变量成为静态的方式有两种：一种是在函数外面定义它；另一种是在声明变量时使用关键字 static：<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">double</span> fee = <span class="number">56.60</span>;</span><br></pre></td></tr></table></figure><p></p><h4 id="动态存储"><a href="#动态存储" class="headerlink" title="动态存储"></a>动态存储</h4><p>new和 delete运算符提供了一种比自动变量和静态变量更灵活的方法。它们管理了一个内存池，<strong>这在C++中被称为自由存储空间（ free store）或堆（heap）</strong>。该内存池中用于静态变量和自动变量的内存是分开的。程序4.22表明，new和 delete让我们能够在一个函数中分配内存，而在另一个函数中释放它。因此，数据的生命周期不完全受程序或函数的生存时间控制。与使用常规变量相比，使用new和 delete让程序员对程序如何使用内存有更大的控制权。然而，内存管理也更复杂了。在栈中，自动添加和删除机制使得占用的内存总是连续的，但new和delete的相互影响可能导致占用的自由存储区不连续，这使得跟踪新分配内存的位置更困难</p><h4 id="栈、堆和内存泄漏"><a href="#栈、堆和内存泄漏" class="headerlink" title="栈、堆和内存泄漏"></a>栈、堆和内存泄漏</h4><p>如果使用new运算符在自由存储空间（或堆）上创建变量后，没有调用delete,将发生什么情况呢？<br>如果没有调用delete,则即使包含指针的内存由于作用域规则和对象生命周期的原因而被释放，在自由存储空间上动态分配的变量或结构也将继续存在。实际上，将会无法访问自由存储空间中的结构，因为指向这些内存的指针无效。这将导致内存泄漏。被泄漏的内存将在程序的整个生命周期内都不可使用；这些内存被分配出去，但无法收回。极端情况（不过不常见）是，内存泄漏可能会非常严重，以致于应用程序可用的内存被耗尽，出现内存耗尽错误，导致程序崩溃。另外，这种泄漏还会给一些操作系统或在相同的内存空间中运行的应用程序带来负面影响，导致它们崩溃。</p><h3 id="类型组合"><a href="#类型组合" class="headerlink" title="类型组合"></a>类型组合</h3><p>我们学习了数组，结构和指针，其实还可以用各种方式组合他们。先从结构开始。<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">antarctica_year_end</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">    <span class="keyword">int</span> birthday;</span><br><span class="line">    <span class="comment">/*还有一些实际有趣的数据等*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><ul><li>可以创建这种类型的变量<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">antarctica_year_end s01, s02, s03; <span class="comment">//s01,s02,s03 是结构体</span></span><br></pre></td></tr></table></figure> 然后使用成员运算符访问其成员：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s01.year = <span class="number">1998</span>;</span><br></pre></td></tr></table></figure></li><li>可创建这种结构的指针：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">antarctica_year_end * pa = &amp;s02;</span><br></pre></td></tr></table></figure> 将该指针设置为有效地址后，就可使用间接成员运算符来访问成员：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pa-&gt;year = <span class="number">1999</span>;</span><br></pre></td></tr></table></figure></li><li>可创建结构数组:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">antarctica_year_end trio[<span class="number">3</span>];  <span class="comment">//包含3个结构体的数组</span></span><br></pre></td></tr></table></figure> 然后可以使用成员运算符访问元素的成员：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trio[<span class="number">0</span>].year = <span class="number">2003</span>;    <span class="comment">//trio[0]是一个结构体</span></span><br></pre></td></tr></table></figure> 其中tiro是一个数组，tiro[0]是一个结构，而 trio[0].year是该结构的一个成员，<strong>由于数组名是一个指针(数组名是第一个元素的地址)</strong>，因此也可使用间接成员运算符：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(trio+<span class="number">1</span>)-&gt;year = <span class="number">2004</span>;  <span class="comment">//等价于trio[1].year = 2004</span></span><br></pre></td></tr></table></figure></li><li>可创建指针数组:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">antarctica_year_end *arp[<span class="number">3</span>] = &#123;&amp;s01, $s02, &amp;s03&#125;;</span><br></pre></td></tr></table></figure> 既然arp是一个指针数组，arp[1]就是一个指针，可将间接成员运算符应用于它，以访问成员:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; arp[<span class="number">1</span>]-&gt;year &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li></ul></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> jackcywang</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://wangng.com/articles/869ca03d.html/" title="C++之指针_3">https://wangng.com/articles/869ca03d.html/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a><a href="/tags/%E6%8C%87%E9%92%88/" rel="tag"><i class="fa fa-tag"></i> 指针</a></div><div class="post-nav"><div class="post-nav-item"><a href="/articles/6892c111.html/" rel="prev" title="C++之指针_1"><i class="fa fa-chevron-left"></i> C++之指针_1</a></div><div class="post-nav-item"> <a href="/articles/c8047a06.html/" rel="next" title="C++之数组与指针传参">C++之数组与指针传参<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div><div class="tabs tabs-comment"><ul class="nav-tabs"><li class="tab"><a href="#comment-gitalk">gitalk</a></li><li class="tab"><a href="#comment-valine">valine</a></li></ul><div class="tab-content"><div class="tab-pane gitalk" id="comment-gitalk"><div class="comments" id="gitalk-container"></div></div><div class="tab-pane valine" id="comment-valine"><div class="comments" id="valine-comments"></div></div></div></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用new创建动态结构"><span class="nav-number">1.</span> <span class="nav-text">使用new创建动态结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一个使用new和delete的示例"><span class="nav-number">1.1.</span> <span class="nav-text">一个使用new和delete的示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自动存储、静态存储和动态存储"><span class="nav-number">2.</span> <span class="nav-text">自动存储、静态存储和动态存储</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#自动存储"><span class="nav-number">2.1.</span> <span class="nav-text">自动存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#静态存储"><span class="nav-number">2.2.</span> <span class="nav-text">静态存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态存储"><span class="nav-number">2.3.</span> <span class="nav-text">动态存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#栈、堆和内存泄漏"><span class="nav-number">2.4.</span> <span class="nav-text">栈、堆和内存泄漏</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型组合"><span class="nav-number">3.</span> <span class="nav-text">类型组合</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">jackcywang</p><div class="site-description" itemprop="description">不经一番彻骨寒,怎得梅花扑鼻香</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">66</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">15</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">65</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/jackcywang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jackcywang" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:yourname@gmail.com" title="E-Mail → mailto:yourname@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i> E-Mail</a></span><span class="links-of-author-item"><a href="https://blog.csdn.net/weixin_42631693" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_42631693" rel="noopener" target="_blank"><i class="fa fa-fw fa-CSDN"></i> CSDN</a></span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/hao-han-zhong-de-yipian-xie" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;hao-han-zhong-de-yipian-xie" rel="noopener" target="_blank"><i class="fa fa-fw fa-知乎"></i> 知乎</a></span></div></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; 2019 – <span itemprop="copyrightYear">2020</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">jackcywang</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-area-chart"></i></span> <span title="站点总字数">261k</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-coffee"></i></span> <span title="站点阅读时长">3:57</span></div><span id="sitetime"></span><script language="javascript">function siteTime(){window.setTimeout("siteTime()",1e3);var e=36e5,t=24*e,o=new Date,i=o.getFullYear(),n=o.getMonth()+1,a=o.getDate(),r=o.getHours(),s=o.getMinutes(),g=o.getSeconds(),l=Date.UTC(2020,1,1,15,0,0),m=Date.UTC(i,n,a,r,s,g)-l,M=Math.floor(m/t),T=Math.floor((m-M*t)/e),u=Math.floor((m-M*t-T*e)/6e4),f=Math.floor((m-M*t-T*e-6e4*u)/1e3);document.getElementById("sitetime").innerHTML=" 在此已等候"+M+" 天 "+T+" 小时 "+u+" 分钟 "+f+" 秒"}siteTime()</script><div> <a href="http://www.miitbeian.gov.cn/" rel="noopener" target="_blank">陕ICP备19023518号-1</a> <span class="post-meta-divider">|</span> <span style="padding-left:25px;background:url(/images/beian.png) no-repeat left center" rel="nofollow"><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=61019002001038" rel="noopener" target="_blank">陕公网安备61019002001038号</a></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script><script async src="/js/cursor/fireworks.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/moment.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment-precise-range-plugin@1.3.0/moment-precise-range.min.js"></script><script>
    function timer() {
      var ages = moment.preciseDiff(moment(),moment(20191220,"YYYYMMDD"));
      //去除时分秒信息
      ages = ages.replace(/\s?\d{0,2}\s+hours?/, "");
      ages = ages.replace(/\s?\d{0,2}\s+minutes?/, "");
      ages = ages.replace(/\s?\d{0,2}\s+seconds?/, "");
      //将年月日转换为中文
      ages = ages.replace(/years?/, "年");
      ages = ages.replace(/months?/, "月");
      ages = ages.replace(/days?/, "天");
      ages = ages.replace(/\d+/g, '<span style="color:#1890ff">$&</span>');
      span.innerHTML = `footer.age ${ages}`;
    }
    var span = document.createElement("span");
    //插入到agesicon之后
    var agesicon = document.querySelector(".footer-ages-icon");
    document.querySelector(".copyright").insertBefore(span, agesicon.nextSibling);
    timer();
  </script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css"><script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '500094376d9d18a3ed06',
      clientSecret: '71db1de3f4d19d73479a0ad6887d90081e8b7ca1',
      repo        : 'MyGitalk',
      owner       : 'jackcywang',
      admin       : ['jackcywang'],
      id          : '1ba7e6f7fdbbfd617a17695eb93cf433',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script><script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'qHl8YMnB0b5OHNGx0AO0fjIE-gzGzoHsz',
      appKey     : 'wN3c6hhMnkEwVWOSLF0xQ3In',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script><script src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><script src="https://player.lmih.cn/player/js/player.js" id="myhk" key="158704924834" m="1"></script></body></html>