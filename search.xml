<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++之static静态成员变量与static静态成员函数</title>
    <url>/articles/c71d2dd7.html/</url>
    <content><![CDATA[<h3 id="static静态成员变量"><a href="#static静态成员变量" class="headerlink" title="static静态成员变量"></a>static静态成员变量</h3><p>　　对象的内存中包含了成员变量，不同的对象占用不同的内存，这使得不同对象的成员变量相互独立，它们的值不受其他对象的影响。例如有两个相同类型的对象a、b,它们都有一个成员变量m_name,那么修改 a.m_name 的值不会影响 b.m_name 的值。</p>
<p>　　可是有时候我们希望在多个对象之间共享数据，对象a改变了某份数据后对象b可以检测到。共享数据的典型使用场景是计数，以前面的 Student 类为例,如果我们想知道班级中共有多少名学生,就可以设置一份共享的变量，每次创建对象时让该变量加 1。</p>
<p>　　在C++中，我们可以使用静态成员变量来实现多个对象共享数据的目标。<font color="red" size="3">静态成员变量是一种特殊的成员变量,它被关键字static修饰</font>,如<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">float</span> score);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_total;  <span class="comment">//静态成员变量</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">    <span class="keyword">float</span> m_score;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>　　这段代码声明了一个静态成员变量 m_total，用来统计学生的人数。<strong>static成员变量属于类，不属于某个具体的对象,即使创建多个对象,也只为m_total分配一份内存，所有对象使用的都是这份内存中的数据</strong>。当某个对象修改了m_total，也会影响到其他对象。</p>
<p>static成员变量必须在类声明的外部初始化,具体形式为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">type class::name = value;</span><br></pre></td></tr></table></figure><br>type 是变量的类型,class 是类名,name是变量名,value是初始值。将上面的 m_total 初始化：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> Student::m_total = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><br>静态成员变量在初始化时不能再加static,但必须要有数据类型。<strong>被private、protected、public修饰的静态成员变量都可以用这种方式初始化。</strong></p>
<font color="red" size="3">注意：static 成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是在（类外）初始化时分配。反过来说，没有在类外初始化的 static 成员变量不能使用。</font>

<p>static成员变量既可以通过对象来访问,也可以通过类来访问。请看下面的例子：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过类访问static成员变量</span></span><br><span class="line">Student::m_total = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//通过对象来访问 static 成员变量</span></span><br><span class="line"><span class="function">Student <span class="title">stu</span><span class="params">(<span class="string">"小明"</span>, <span class="number">15</span>, <span class="number">92.5f</span>)</span></span>;</span><br><span class="line">stu.m_total = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//通过对象指针来访问 static 成员变量</span></span><br><span class="line">Student *pstu = <span class="keyword">new</span> Student(<span class="string">"李华"</span>, <span class="number">16</span>, <span class="number">96</span>);</span><br><span class="line">pstu -&gt; m_total = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><br>这三种方式是等效的。注意：static 成员变量不占用对象的内存,而是在所有对象之外开辟内存,即使不创建对象也可以访问。具体来说，static成员变量和普通的static变量类似,都在内存分区中的全局数据区分配内存。</p>
<p>下面是整个完整例子:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">float</span> score);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_total;  <span class="comment">//静态成员变量</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">    <span class="keyword">float</span> m_score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化静态成员变量</span></span><br><span class="line"><span class="keyword">int</span> Student::m_total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Student::Student(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">float</span> score): m_name(name), m_age(age), m_score(score)&#123;</span><br><span class="line">    m_total++;  <span class="comment">//操作静态成员变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m_name&lt;&lt;<span class="string">"的年龄是"</span>&lt;&lt;m_age&lt;&lt;<span class="string">"，成绩是"</span>&lt;&lt;m_score&lt;&lt;<span class="string">"（当前共有"</span>&lt;&lt;m_total&lt;&lt;<span class="string">"名学生）"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建匿名对象</span></span><br><span class="line">    (<span class="keyword">new</span> Student(<span class="string">"小明"</span>, <span class="number">15</span>, <span class="number">90</span>)) -&gt; show();</span><br><span class="line">    (<span class="keyword">new</span> Student(<span class="string">"李磊"</span>, <span class="number">16</span>, <span class="number">80</span>)) -&gt; show();</span><br><span class="line">    (<span class="keyword">new</span> Student(<span class="string">"张华"</span>, <span class="number">16</span>, <span class="number">99</span>)) -&gt; show();</span><br><span class="line">    (<span class="keyword">new</span> Student(<span class="string">"王康"</span>, <span class="number">14</span>, <span class="number">60</span>)) -&gt; show();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">小明的年龄是<span class="number">15</span>，成绩是<span class="number">90</span>（当前共有<span class="number">1</span>名学生）</span><br><span class="line">李磊的年龄是<span class="number">16</span>，成绩是<span class="number">80</span>（当前共有<span class="number">2</span>名学生）</span><br><span class="line">张华的年龄是<span class="number">16</span>，成绩是<span class="number">99</span>（当前共有<span class="number">3</span>名学生）</span><br><span class="line">王康的年龄是<span class="number">14</span>，成绩是<span class="number">60</span>（当前共有<span class="number">4</span>名学生）</span><br></pre></td></tr></table></figure><br>本例中将 m_total 声明为静态成员变量,每次创建对象时,会调用构造函数使m_total的值加 1。之所以使用匿名对象,是因为每次创建对象后只会使用它的show()函数,不再进行其他操作。不过使用匿名对象无法回收内存,会导致内存泄露,在中大型程序中不建议使用。</p>
<h4 id="其他要点"><a href="#其他要点" class="headerlink" title="其他要点"></a>其他要点</h4><p>(1) 一个类中可以有一个或多个静态成员变量，所有的对象都共享这些静态成员变量，都可以引用它。</p>
<p>(2)static 成员变量和普通 static 变量一样，都在内存分区中的全局数据区分配内存，到程序结束时才释放。这就意味着，static 成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。而普通成员变量在对象创建时分配内存，在对象销毁时释放内存。</p>
<p>(3)静态成员变量必须初始化,而且只能在类体外进行。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> Student::m_total = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><br>初始化时可以赋初值，也可以不赋值。如果不赋值，那么会被默认初始化为 0。全局数据区的变量都有默认的初始值 0，而动态数据区（堆区、栈区）变量的默认值是不确定的，一般认为是垃圾值。</p>
<p>(4)静态成员变量既可以通过对象名访问，也可以通过类名访问，但要遵循 private、protected 和 public 关键字的访问权限限制。当通过对象名访问时，对于不同的对象，访问的是同一份内存。</p>
<h3 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h3><p>　　在类中,static 除了可以声明静态成员变量,还可以声明静态成员函数。普通成员函数可以访问所有成员(包括成员变量和成员函数),静态成员函数只能访问静态成员。</p>
<p>　　<strong>编译器在编译一个普通成员函数时,会隐式地增加一个形参this,并把当前对象的地址赋值给this,所以普通成员函数只能在创建对象后通过对象来调用，因为它需要当前对象的地址</strong>。而静态成员函数可以通过类来直接调用，编译器不会为它增加形参this,它不需要当前对象的地址，所以不管有没有创建对象,都可以调用静态成员函数。</p>
<p>　　普通成员变量占用对象的内存,静态成员函数没有this指针,不知道指向哪个对象,无法访问对象的成员变量,也就是说<strong>静态成员函数不能访问普通成员变量,只能访问静态成员变量</strong>。</p>
<p>　　普通成员函数必须通过对象才能调用，而静态成员函数没有this指针,无法在函数体内部访问某个对象，所以不能调用普通成员函数，只能调用静态成员函数.<font color="red" size="3">静态成员函数与普通成员函数的根本区别在于:普通成员函数有this指针，可以访问类中的任意成员；而静态成员函数没有this指针，只能访问静态成员(包括静态成员变量和静态成员函数)。</font></p>
<p>下面是一个完整的例子，该例通过静态成员函数来获得学生的总人数和总成绩：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">float</span> score);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//声明静态成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getTotal</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">float</span> <span class="title">getPoints</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_total;  <span class="comment">//总人数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">float</span> m_points;  <span class="comment">//总成绩</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">    <span class="keyword">float</span> m_score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Student::m_total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">float</span> Student::m_points = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">Student::Student(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">float</span> score): m_name(name), m_age(age), m_score(score)&#123;</span><br><span class="line">    m_total++;</span><br><span class="line">    m_points += score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m_name&lt;&lt;<span class="string">"的年龄是"</span>&lt;&lt;m_age&lt;&lt;<span class="string">"，成绩是"</span>&lt;&lt;m_score&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义静态成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Student::getTotal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_total;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">Student::getPoints</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_points;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    (<span class="keyword">new</span> Student(<span class="string">"小明"</span>, <span class="number">15</span>, <span class="number">90.6</span>)) -&gt; show();</span><br><span class="line">    (<span class="keyword">new</span> Student(<span class="string">"李磊"</span>, <span class="number">16</span>, <span class="number">80.5</span>)) -&gt; show();</span><br><span class="line">    (<span class="keyword">new</span> Student(<span class="string">"张华"</span>, <span class="number">16</span>, <span class="number">99.0</span>)) -&gt; show();</span><br><span class="line">    (<span class="keyword">new</span> Student(<span class="string">"王康"</span>, <span class="number">14</span>, <span class="number">60.8</span>)) -&gt; show();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> total = Student::getTotal();</span><br><span class="line">    <span class="keyword">float</span> points = Student::getPoints();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"当前共有"</span>&lt;&lt;total&lt;&lt;<span class="string">"名学生，总成绩是"</span>&lt;&lt;points&lt;&lt;<span class="string">"，平均分是"</span>&lt;&lt;points/total&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">小明的年龄是<span class="number">15</span>，成绩是<span class="number">90.6</span></span><br><span class="line">李磊的年龄是<span class="number">16</span>，成绩是<span class="number">80.5</span></span><br><span class="line">张华的年龄是<span class="number">16</span>，成绩是<span class="number">99</span></span><br><span class="line">王康的年龄是<span class="number">14</span>，成绩是<span class="number">60.8</span></span><br><span class="line">当前共有<span class="number">4</span>名学生，总成绩是<span class="number">330.9</span>，平均分是<span class="number">82.725</span></span><br></pre></td></tr></table></figure></p>
<p>　　总人数m_total和总成绩m_points由各个对象累加得到,必须声明为static才能共享;getTotal()、getPoints() 分别用来获取总人数和总成绩,为了访问static成员变量,我们将这两个函数也声明为static。</p>
<p>　　在C++中,静态成员函数的主要目的是访问静态成员。getTotal()、getPoints()当然也可以声明为普通成员函数,但是它们都只对静态成员进行操作,加上 static 语义更加明确。</p>
<p>　　和静态成员变量类似,<strong>静态成员函数在声明时要加 static，在定义时不能加static</strong>。<u>静态成员函数可以通过类来调用(一般都是这样做)，也可以通过对象来调用，上例仅仅演示了如何通过类来调用。</u></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>1.<a href="http://c.biancheng.net/cpp/biancheng/view/209.html" target="_blank" rel="noopener">C++ static静态成员变量</a><br>2.<a href="http://c.biancheng.net/cpp/biancheng/view/3260.html" target="_blank" rel="noopener">C++ static静态成员函数</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>static</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之字符串</title>
    <url>/articles/b186c0b4.html/</url>
    <content><![CDATA[<h3 id="1-字符串声名"><a href="#1-字符串声名" class="headerlink" title="1.字符串声名"></a>1.字符串声名</h3><p>字符串是存储在内存的连续字节中的一系列字符。C++处理字符串的方式有两种。第一种来自C语言，常被称为C风格字符串（C- style string）。另一种基于 string类库的方法。</p>
<a id="more"></a> 
<p>存储在连续字节中的一系列字符意味着可以将字符串存储在char数组中，其中每个字符都位于自己的数组元素中。C风格字符串具有一种特殊的性质：以空字符（ null character）结尾，空字符被写作\0，其 ASCII I码为0，用来标记字符串的结尾。例如，请看下面两个声明</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> dog[<span class="number">8</span>]=&#123;<span class="string">'b'</span>,<span class="string">'e'</span>,<span class="string">'a'</span>,<span class="string">'u'</span>,<span class="string">' '</span>,<span class="string">'I'</span>,<span class="string">'i'</span>&#125;;       <span class="comment">// not a string!</span></span><br><span class="line"><span class="keyword">char</span> dog[<span class="number">8</span>]=&#123;<span class="string">'f'</span>,<span class="string">'a'</span>,<span class="string">'t'</span>,<span class="string">'e'</span>,<span class="string">'s'</span>,<span class="string">'s'</span>,<span class="string">'a'</span>,<span class="string">'\0'</span>&#125;;   <span class="comment">// a string!</span></span><br></pre></td></tr></table></figure>
<p>这两个数组都是char数组，但只有第二个数组是字符串。空字符对C风格字符串而言至关重要。例如C++有很多处理字符串的函数，其中包括cout使用的那些函数。它们都逐个地处理字符串中的字符，直到达空字符为止。如果使用cout显示上面的cat这样的字符串，则将显示前7个字符，发现空字符后停止但是，如果使用cout显示上面的dog数组（它不是字符串），cout将打印出数组中的8个字母，并接着内存中随后的各个字节解释为要打印的字符，直到遇到空字符为止。由于空字符（实际上是被设置为0的字节）在内存中很常见，因此这一过程将很快停止。但尽管如此，还是不应将不是字符串的字符数组当作字符串处理。</p>
<ul>
<li>字符串的简化定义</li>
</ul>
<p>只需使用一个用引号括起的字符串即可，这种字符串被称为字符串常量（ string constant）或字符串字面值（ string literal），如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> bird[<span class="number">11</span>] = <span class="string">"Mr. Cheeps"</span>; </span><br><span class="line"><span class="keyword">char</span> fish[] = <span class="string">"Bubbles"</span>;</span><br></pre></td></tr></table></figure>
<p>用引号扩起的字符串隐式的包括了结尾的空字符(‘\0’),当然，应确保数组足够大，能够存储字符串中所有字符—包括空字符。使用字符串常量初始化字符数组是这样的一种情况，即让编译器计算元素数目更为安全。让数组比字符串长没有什么害处，只是会浪费一些空间而已。这是因为处理字符串的函数根据空字符的位置，而不是数组长度来进行处理。C++对字符串长度没有限制</p>
<p><img src="http://cdn.wangng.com/C++/C++之字符串/image1.png" alt></p>
<blockquote>
<p>注意，字符串常量（使用双引号）不能与字符常量（使用单引号）互换。字符常量（如’S’）是字符串编码的简写表示。在ASCⅡ系统上，’S’只是83的另一种写法，因此，下面的语句将83赋给shirt_size</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> shirt_size = <span class="string">'s'</span>;      <span class="comment">// that's fine</span></span><br></pre></td></tr></table></figure>
<p>但”S”不是字符常量，它表示的是两个字符(字符S和\0)组成的字符串。更糟糕的是，”S”实际表示是字符串所在的内存地址，因此下面的语句试图将一个内存地址赋给shirt_size;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> shirt_size = <span class="string">"S"</span>;  <span class="comment">// illegal type mismatch</span></span><br></pre></td></tr></table></figure>
<h3 id="2-面向行的输入"><a href="#2-面向行的输入" class="headerlink" title="2.面向行的输入"></a>2.面向行的输入</h3><p>1、cin.getline()</p>
<p>getline()函数读取整行，它使用通过回车键输入的换行符来确定输入结尾。要调用这种方法，可以使用 cin.getline()。该函数有两个参数。第一个参数是用来存储输入行的数组的名称，第二个参数是要读取的字符数。如果这个参数为20，则函数最多读取19个字符，余下的空间用于存储自动在结尾处添加的空字符。 getline（）成员函数在读取指定数目的字符或遇到换行符时停止读取。例如，假设要使用 getline()将姓名读入到一个包含20个元素的name数组中。可以使用这样的函数调用:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span>.getline(name,<span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<p><img src="http://cdn.wangng.com/C++/C++之字符串/image2.png" alt></p>
<p>getline()函数每次读取一行。它通过换行符来确定行尾，但不保存换行符。相反，在存储字符串时，它用空字符来替换换行符（参见图4.5）</p>
<p>2、cin.get()</p>
<p>我们来试试另一种方法。 Istream类有另一个名为get()的成员函数，该函数有几种变体。其中一种变体的工作方式与 getline()类似，它们接受的参数相同，解释参数的方式也相同，并且都读取到行尾。但get并不再读取并丢弃换行符，而是将其留在输入队列中。假设我们连续两次调用get():</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span>.<span class="built_in">get</span>(name,ArSize);</span><br><span class="line"><span class="built_in">cin</span>.<span class="built_in">get</span>(dessert,ArSize); <span class="comment">// a problem</span></span><br></pre></td></tr></table></figure>
<p>由于第一次调用后，换行符将留在输入队列中，因此第二次调用时看到的第一个字符便是换行符。因此get()认为已到达行尾，而没有发现任何可读取的内容。如果不借助于帮助，get()将不能跨过该换行符幸运的是，get()有另一种变体。使用不带任何参数的 cin.get()调用可读取下一个字符（即使是换行符），因此可以用它来处理换行符，为读取下一行输入做好准备。也就是说，可以采用下面的调用序列：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span>.<span class="built_in">get</span>(name,ArSize);        <span class="comment">//read first line</span></span><br><span class="line"><span class="built_in">cin</span>.<span class="built_in">get</span>()                    <span class="comment">//read new line</span></span><br><span class="line"><span class="built_in">cin</span>.<span class="built_in">get</span>(dessert,Arsize);     <span class="comment">// read second line</span></span><br></pre></td></tr></table></figure>
<p>另一种使用get()的方式是将两个类成员函数拼接起来（合并），如下所示:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span>.<span class="built_in">get</span>(name,ArSize).<span class="built_in">get</span>();   <span class="comment">//concatenate member functions</span></span><br></pre></td></tr></table></figure>
<p>之所以可以这样做，是由于 cin. get(name, AsSize)返回一个cin对象，该对象随后将被用来调用get()函数。同样，下面的语句将把输入中连续的两行分别读入到数组name1和name2中，其效果与两次调用cin.getline()相同</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span>.getline(naem1,ArSize).getline(name2,ArSize)</span><br></pre></td></tr></table></figure>
<h3 id="3-string类简介"><a href="#3-string类简介" class="headerlink" title="3.string类简介"></a>3.string类简介</h3><p>ISO/ANSI C++98标准通过添加 string类扩展了C++库，因此现在可以 string类型的变量（使用C+的话说是对象）而不是字符数组来存储字符串。您将看到， string类使用起来比数组简单，同时提供了将字符串作为一种数据类型的表示方法。要使用 string类，必须在程序中包含头文件 string。 string类位于名称空间std中，因此您必须提供一条using编译指令，或者使用std::string来引用它。 string类定义隐藏了字符串的数组性质，让您能够像处理普通变量那样处理字符串。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> str1;      <span class="comment">//creat an empty string object</span></span><br><span class="line"><span class="built_in">string</span> str2 = <span class="string">"panther"</span>;   <span class="comment">//creat an initialized string</span></span><br></pre></td></tr></table></figure>
<p>类设计让程序能够自动处理 string的大小。例如，strl的声明创建一个长度为0的 string对象，但程序将输入读取到sr1中时，将自动调整strl的长度：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; str1;    <span class="comment">//str1 resized to fit input</span></span><br></pre></td></tr></table></figure>
<p>这使得与使用数组相比，使用 string对象更方便，也更安全。从理论上说，可以将char数组视为一组用于存储一个字符串的char存储单元，而 string类变量是一个表示字符串的实体。</p>
<h4 id="3-1-C-11-字符串初始化"><a href="#3-1-C-11-字符串初始化" class="headerlink" title="3.1 C++11 字符串初始化"></a>3.1 C++11 字符串初始化</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> first_data[] = &#123;<span class="string">"le Charpin Dodu"</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> second_data[] &#123;<span class="string">"The Elegant Plate"</span>&#125;;</span><br><span class="line"><span class="built_in">string</span> third_data = &#123;<span class="string">"The Bread Bowl"</span>&#125;;</span><br><span class="line"><span class="built_in">string</span> fourth_data &#123;<span class="string">"Hank Fine Eats"</span>&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-赋值、拼接和附加"><a href="#3-2-赋值、拼接和附加" class="headerlink" title="3.2 赋值、拼接和附加"></a>3.2 赋值、拼接和附加</h4><p>使用 string类时，某些操作比使用数组时更简单。例如，不能将一个数组赋给另一个数组，但可以将一个 string对象赋给另一个 string对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> charrl[<span class="number">20</span>];     <span class="comment">//create an empty array </span></span><br><span class="line"><span class="keyword">char</span> charr2[<span class="number">20</span>]=<span class="string">"jaguar"</span>;  <span class="comment">//create an initialized array</span></span><br><span class="line"><span class="built_in">string</span> str1;         <span class="comment">//create an empty string object </span></span><br><span class="line"><span class="built_in">string</span> str2 =<span class="string">"panther"</span>;   <span class="comment">//create an initialized string </span></span><br><span class="line">charr1 = charr2;    <span class="comment">//INVALID, no array assignment</span></span><br><span class="line">strl = str2;       <span class="comment">//VALID, object assignment ok</span></span><br></pre></td></tr></table></figure>
<p>string类简化了字符串合并操作，可以使用运算符+将两个string对象合并起来，还可以使用运算符符串+=附加到 string对象的末尾。继续前面的代码，可以这样做：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sting str3;</span><br><span class="line">str3 = str1 + str2;     <span class="comment">//assign str3 the joined strings</span></span><br><span class="line">str1 += str2;         <span class="comment">// add str2 to the end of str1</span></span><br></pre></td></tr></table></figure>
<h4 id="3-3-string-其他操作"><a href="#3-3-string-其他操作" class="headerlink" title="3.3 string 其他操作"></a>3.3 string 其他操作</h4><p>在C++新增 string类之前，程序员也需要完成诸如给字符串赋值等工作。对于C风格字符串程序员使用C语言库中的函数来完成这些任务。头文件 cstring（以前为 string. h）提供了这些函数。例如，可以使用函数 strcpy()将字符串复制到字符数组中，使用函数 strcat()将字符串附加到字符数组末尾：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(charr1,charr2);   <span class="comment">//copy charr2 to charr1</span></span><br><span class="line"><span class="built_in">strcat</span>(charr1,charr2);   <span class="comment">//append contents of charr2 to charr1</span></span><br><span class="line"><span class="built_in">strlen</span>(charr1);          <span class="comment">// return the length of charr1</span></span><br></pre></td></tr></table></figure>
<p>string类提供了一系列针对字符串的操作</p>
<ol>
<li><p>append()— 在字符串的末尾添加字符</p>
</li>
<li><p>find()—在字符串中查找字符串</p>
</li>
<li><p>insert()—插入字符</p>
</li>
<li><p>length()—返回字符串的长度</p>
</li>
<li><p>replace()—替换字符串</p>
</li>
<li><p>substr()—返回某个字符串</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义一个string类对象</span></span><br><span class="line">    <span class="built_in">string</span> http = <span class="string">"www.runoob.com"</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//打印字符串长度</span></span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;http.length()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拼接</span></span><br><span class="line">    http.append(<span class="string">"/C++"</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;http&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//打印结果为：www.runoob.com/C++</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    <span class="keyword">int</span> pos = http.<span class="built_in">find</span>(<span class="string">"/C++"</span>); <span class="comment">//查找"C++"在字符串中的位置</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;pos&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    http.replace(pos, <span class="number">4</span>, <span class="string">""</span>);   <span class="comment">//从位置pos开始，之后的4个字符替换为空，即删除</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;http&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找子串runoob</span></span><br><span class="line">    <span class="keyword">int</span> first = http.find_first_of(<span class="string">"."</span>); <span class="comment">//从头开始寻找字符'.'的位置</span></span><br><span class="line">    <span class="keyword">int</span> last = http.find_last_of(<span class="string">"."</span>);   <span class="comment">//从尾开始寻找字符'.'的位置</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;http.substr(first+<span class="number">1</span>, last-first<span class="number">-1</span>)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//提取"runoob"子串并打印</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之指针_2</title>
    <url>/articles/f19b90ab.html/</url>
    <content><![CDATA[<h3 id="指针、数组和指针运算"><a href="#指针、数组和指针运算" class="headerlink" title="指针、数组和指针运算"></a>指针、数组和指针运算</h3><p>指针和数组基本等价的原因在于指针算术(pointer arithmetic)和C++内部处理数组的方式。首先，我们来看一看算术。将整数变量加1后，其值将增加1;但将指针变量加1后，增加的量等于它指向的类型的字节数。将指向 double的指针加1后，如果系统对 double使用8个字节存储，则数值将增加8：将指向short的指针加1后，如果系统对 short使用2个字节存储，则指针值将增加2。下面程序演示了这种令人吃惊的现象，它还说明了另一点：C++将数组名解释为地址。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// addpntrs.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">double</span> wages[<span class="number">3</span>] = &#123;<span class="number">10000.0</span>, <span class="number">20000.0</span>, <span class="number">30000.0</span>&#125;;</span><br><span class="line">    short stacks[<span class="number">3</span>] = &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span>* pw = wages;</span><br><span class="line">    short* ps = &amp;stacks[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pw = "</span> &lt;&lt; pw &lt;&lt;<span class="string">", *pw = "</span> &lt;&lt; *pw &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"add 1 to the pw pointer:\n"</span>;</span><br><span class="line">    pw = pw + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"pw = "</span> &lt;&lt; pw &lt;&lt;<span class="string">", *pw = "</span> &lt;&lt; *pw &lt;&lt;<span class="string">"\n\n"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ps = "</span> &lt;&lt; ps &lt;&lt; <span class="string">", *ps = "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"add 1 to the ps pointer:\n"</span></span><br><span class="line">    ps = ps + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ps = "</span> &lt;&lt; ps &lt;&lt;<span class="string">", *ps = "</span> &lt;&lt; *pw &lt;&lt;<span class="string">"\n\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"access two elements with array notation\n"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"stacks[0]= "</span> &lt;&lt; stacks[<span class="number">0</span>] &lt;&lt; <span class="string">", stacks[1] = "</span> &lt;&lt; stacks[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"access two elements with pointer notation\n"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"*stacks= "</span> &lt;&lt; *stacks &lt;&lt; <span class="string">", stacks[1] = "</span> &lt;&lt; *(stacks+<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//程序输出</span></span><br><span class="line">pw = <span class="number">0x28ccf0</span>,*pw = <span class="number">10000</span></span><br><span class="line">add <span class="number">1</span> to the pw pointer:</span><br><span class="line">pw = ox28ccf8,*pw = <span class="number">20000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ps = ox28ccea,*ps = <span class="number">3</span></span><br><span class="line">add <span class="number">1</span> to the ps pointer:</span><br><span class="line">ps = ox28ccec,*ps = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">access two elements with <span class="built_in">array</span> notation</span><br><span class="line">stacks[<span class="number">0</span>] = <span class="number">3</span>, stacks[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">access two elements with pointer notation</span><br><span class="line">*stacks = <span class="number">3</span>, *(stacks+<span class="number">1</span>) = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><strong>在多数情况下，C++将数组名解释为数组第1个元素的地址。因此，下面的语句将pw</strong>声名为指向double类型的指针，然后将它初始化为wages数组中的第1个元素的地址:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> * pw = wages;</span><br></pre></td></tr></table></figure><br>和所有数组一样，wages也存在下面的等式：<br><code>wages = &amp;wages[0] = address of first element of array</code></p>
<p>接下来，程序查看pw和$<em>$pw的值，前者是地址，后者是存储在该地址中的值。由于pw指向第1个元素，因此$</em>$pw显示的值为第1个元素的值，即10000接着，程序将pw加1.正如前面指出的，这样数字地址值将增加8，这使得pw的值为第2个元素的地址。因此，$*$pw现在的值是20000即第2个元素的值参见图4.10，为使改图更为清晰，对其中的地址值做了调整）。</p>
<p><div align="center"><br>&lt;img src=<a href="http://cdn.wangng.com/C++/C++之指针_2/img1.png" target="_blank" rel="noopener">http://cdn.wangng.com/C++/C++之指针_2/img1.png</a></div></p>
<blockquote>
<p>&lt;/div&gt;<br>此后，程序对ps执行相同的操作。这一次由于ps指向的是 shor t类型，而short占用2个字节，因此指针加1时，其值将增加2.结果是，指针也指向数组中下一个元素</p>
</blockquote>
<p>从该程序的输出可知，$<em>$（stacks+1）和 stacks[1]是等价的。同样，$</em>$（stacks+2）和 stacks[2]也是等价的。通常，使用数组表示法时，C++都执行下面的转换:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">arrayname[i] 变成 *(arrayname+i)</span><br></pre></td></tr></table></figure><br>如果使用的是指针，而不是数组名，则C++也执行同样的转换：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pointername[i] 变成 *(pointername + i)</span><br></pre></td></tr></table></figure><br>因此，在很多情况下，可以相同的方式使用指针名和数组名。对于它们，可以使用数组方括号表示法，也可以使用解除引用运算符（*）。在多数表达式中，它们都表示地址。区别之一是，可以修改指针的值而数组名是常量<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pointername = pointername + <span class="number">1</span>;  <span class="comment">//有效</span></span><br><span class="line">arrayname = arrayname + <span class="number">1</span>;      <span class="comment">//不允许</span></span><br></pre></td></tr></table></figure></p>
<h3 id="指针小结"><a href="#指针小结" class="headerlink" title="指针小结"></a>指针小结</h3><h4 id="1-声名指针"><a href="#1-声名指针" class="headerlink" title="1.声名指针"></a>1.声名指针</h4><p>要声名指向特定类型的指针，使用方式如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typeName * pointername</span><br></pre></td></tr></table></figure></p>
<h4 id="2-给指针赋值"><a href="#2-给指针赋值" class="headerlink" title="2.给指针赋值"></a>2.给指针赋值</h4><p>应将内存地址赋给指针。可以对变量名应用&amp;运算符，来获得被命名的内存的地址，new运算符返回未命名的内存的地址。示例<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> * pn;</span><br><span class="line"><span class="keyword">double</span> * pa;</span><br><span class="line"><span class="keyword">char</span> * pc;</span><br><span class="line"><span class="keyword">double</span> bubble = <span class="number">3.2</span>;</span><br><span class="line">pn = &amp;bubble;</span><br><span class="line">pc = <span class="keyword">new</span> <span class="keyword">char</span>;</span><br><span class="line">pa = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">30</span>];</span><br></pre></td></tr></table></figure></p>
<h4 id="3-对指针解除应用"><a href="#3-对指针解除应用" class="headerlink" title="3.对指针解除应用"></a>3.对指针解除应用</h4><p>对指针解除引用意味着获得指针指向的值。对指针应用解除引用或间接值运算符（$<em>$）来解除引用。因比，如果像上面的例子中那样，p是指向 bubble的指针，则$</em>$pn是指向的值，即3.2。示例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; *pn;   <span class="comment">//答应bubble的值</span></span><br><span class="line">*ps = <span class="string">'S'</span>;     <span class="comment">//将字符'S'存放到指针ps所指向的内存地址中。</span></span><br></pre></td></tr></table></figure><br>另一种对指针解除引用的方法是使用数组表示法，例如，pn[0]与*pn是一样的。绝不要对未被初始化为合适地址的指针解除引用。</p>
<h4 id="4-区分指针和指针所指向的值"><a href="#4-区分指针和指针所指向的值" class="headerlink" title="4.区分指针和指针所指向的值**"></a>4.区分指针和指针所指向的值**</h4><p>如果pt是指向int类型的指针，<strong>那*pt不是指向int类型的指针，而是完全等同于一个int类型的变量，pt才是指针</strong>。示例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> * pt = <span class="keyword">new</span> <span class="keyword">int</span>;  <span class="comment">// 分配一个地址给指针pt</span></span><br><span class="line">*pt = <span class="number">5</span>;             <span class="comment">//将5存放到那个地址中</span></span><br></pre></td></tr></table></figure></p>
<h4 id="5-数组名"><a href="#5-数组名" class="headerlink" title="5.数组名"></a>5.数组名</h4><p><strong>在多数情况下，C++将数组名视为数组的第一个元素的地址。</strong>示例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> tacos[<span class="number">10</span>];    <span class="comment">//tacos便是的含义等同于&amp;tacos[0]</span></span><br></pre></td></tr></table></figure><br>种例外情况是，将 sizeof运算符用于数组名用时，此时将返回整个数组的长度（单位为字节）</p>
<h4 id="6-指针算术"><a href="#6-指针算术" class="headerlink" title="6.指针算术"></a>6.指针算术</h4><p>C++允许将指针和整数相加。加1的结果等于原来的地址值加上指向的对象占用的总字节数。还可以将一个指针减去另一个指针，获得两个指针的差。后一种运算将得到一个整数，仅当两个指针指向同一个数组（也可以指向超出结尾的一个位置）时，这种运算才有意义；这将得到两个元素的间隔。示例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> tacos[<span class="number">5</span>] = &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *pt = tacos;   <span class="comment">//假设pt和tacos有相同的地址3000</span></span><br><span class="line">pt = pt + <span class="number">1</span>;       <span class="comment">//pt是3004(int占4个字节)</span></span><br><span class="line"><span class="keyword">int</span> *pe = &amp;tacos[<span class="number">3</span>] <span class="comment">//pe现在是3012(int占4个字节)</span></span><br><span class="line">pe = pe - <span class="number">1</span>;       <span class="comment">//pe等于3008,也是tacos[2]的地址</span></span><br><span class="line"><span class="keyword">int</span> diff = pe - pt  <span class="comment">//diiff是1，</span></span><br></pre></td></tr></table></figure></p>
<h4 id="7-数组的动态联编和静态联编"><a href="#7-数组的动态联编和静态联编" class="headerlink" title="7.数组的动态联编和静态联编"></a>7.数组的动态联编和静态联编</h4><p>使用数组声明来创建数组时，将采用静态联编，即数组的长度在编译时设置：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> tacos[<span class="number">10</span>];  <span class="comment">//静态联编，在编译时数组大小是固定的</span></span><br></pre></td></tr></table></figure><br>使用new[]运算符创建数组时，将采用动态联编（动态数组），即将在<strong>运行时为数组分配空间，其长度也将在运行时设置</strong>。使用完这种数组后，应使用 delete[]释放其占用的内存：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; <span class="built_in">size</span>;</span><br><span class="line"><span class="keyword">int</span> * pt = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="built_in">size</span>]; <span class="comment">//动态联编，大小在运行时设定;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> [] pt;      <span class="comment">//运行结束后释放内存</span></span><br></pre></td></tr></table></figure></p>
<h4 id="数组表示法和指针表示法"><a href="#数组表示法和指针表示法" class="headerlink" title="数组表示法和指针表示法"></a>数组表示法和指针表示法</h4><p>使用方括号数组表示法等同于对指针解除引用：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">tacos[<span class="number">0</span>] 等同于*tacos,tacos地址所在的值</span><br><span class="line">tacos[<span class="number">3</span>] 等同于*(tacos+<span class="number">3</span>),tacos[<span class="number">3</span>]地址所在的值</span><br></pre></td></tr></table></figure><br>数组名和指针变量都是如此，因此对于指针和数组名，既可以使用指针表示法，也可以使用数组表示法。示例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> * pt = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">10</span>];  <span class="comment">//pt指向大小为10的数组</span></span><br><span class="line">*pt = <span class="number">5</span>;         <span class="comment">//将位置0的值设置为5</span></span><br><span class="line">pt[<span class="number">0</span>] = <span class="number">6</span>;       <span class="comment">//将位置0值重置为6  </span></span><br><span class="line">pt[<span class="number">9</span>] = <span class="number">44</span>;      <span class="comment">//将位置9(第10个元素)置为44</span></span><br><span class="line"><span class="keyword">int</span> coats[<span class="number">10</span>];</span><br><span class="line">*(coats+<span class="number">4</span>) = <span class="number">12</span>;  <span class="comment">//将coats[4]置为12</span></span><br></pre></td></tr></table></figure></p>
<h3 id="指针和字符串"><a href="#指针和字符串" class="headerlink" title="指针和字符串"></a>指针和字符串</h3><p>数组和指针的特殊关系可以扩展到C风格字符串。请看下面的代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> flower[<span class="number">10</span>] = <span class="string">"rose"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; flower &lt;&lt; <span class="string">"s are red\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; flower[<span class="number">0</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//输出结果是；</span></span><br><span class="line">roses are red</span><br><span class="line">r</span><br></pre></td></tr></table></figure><br><strong>数组名是第一个元素的地址，因此cout语句中的 flower是包含字符r的char元素的地址。cout对象认为char的地址是字符串的地址，因此它打印该地址处的字符，然后继续打印后面的字符，直到遇到空字符0）为止</strong>。总之，<u>如果给cout提供一个字符的地址，则它将从该字符开始打印，直到遇到空字符为止。</u></p>
<p>前面的cout语句中最后一部分的情况如何呢？如果 flower是字符串第一个字符的地址，则表达式“<br>s are red\n”是什么呢？为了与cout对字符串输出的处理保持一致，这个用引号括起的字符串也应当是一个地址。</p>
<p><strong>在C++中，用引号括起的字符串像数组名一样，也是第一个元素的地址</strong>。上述代码不会将整个字符串发送给cout，而只是发送该字符串的地址。这意味着对于数组中的字符串、用引号括起的字符串常量以及指针所描述的字符串，处理的方式是一样的，都将传递它们的地址。</p>
<blockquote>
<p>注意：在cout和多数C+表达式中，char数组名、char指针以及用引号括起的字符串常量都被解释为符串第一个字符的地址。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ptrstr.cpp 使用string型的指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;   //声明strlen(),strcpy()</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">  <span class="keyword">char</span> animal[<span class="number">20</span>] = <span class="string">"bear"</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> * bird = <span class="string">"wren"</span>;  <span class="comment">//bird 指向string的地址</span></span><br><span class="line">  <span class="keyword">char</span> * ps;                   <span class="comment">//未初始化</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; animal &lt;&lt; <span class="string">" and "</span>;   </span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; bird &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//cout &lt;&lt; ps //不能这样做</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"enter a kind of animal: "</span>;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; animal;</span><br><span class="line">  ps = animal;         <span class="comment">//ps指向animal;</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; ps &lt;&lt; <span class="string">"!\n"</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Before using strcpy():\n"</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; animal &lt;&lt; <span class="string">" at "</span> &lt;&lt; (<span class="keyword">int</span>*)animal &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; ps &lt;&lt; <span class="string">" at "</span> &lt;&lt; (<span class="keyword">int</span>*)(ps) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  ps = <span class="keyword">new</span> <span class="keyword">char</span> [<span class="built_in">strlen</span>(animal) + <span class="number">1</span>];</span><br><span class="line">  <span class="built_in">strcpy</span>(ps,animal);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"After using strcpy():\n"</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; animal &lt;&lt; <span class="string">" at "</span> &lt;&lt; (<span class="keyword">int</span>*) animal &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; ps &lt;&lt; <span class="string">" at "</span> &lt;&lt; (<span class="keyword">int</span>*) ps &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">delete</span> [] ps;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//程序输出</span></span><br><span class="line">bear <span class="keyword">and</span> wren</span><br><span class="line">enter a kind of animal: monkey</span><br><span class="line">monkey!</span><br><span class="line"><span class="function">Before <span class="keyword">using</span> <span class="title">strcpy</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function">monkey at 0x61fef8</span></span><br><span class="line"><span class="function">monkey at 0x61fef8</span></span><br><span class="line"><span class="function">After <span class="keyword">using</span> <span class="title">strcpy</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function">monkey at 0x61fef8</span></span><br><span class="line"><span class="function">monkey at 0xfa1358</span></span><br></pre></td></tr></table></figure>
<p>记住，“wren”实际表示的是字符串的地址，因此这条语句将“wren”的地址赋给了bird指针。（一般来说，编译器在内存留出一些空间，以存储程序源代码中所有用引号括起的字符串，并将每个被存储的字符串与其地址关联起来。）这意味着可以像使用字符串“wen”那样使用指针bird，如下面的示例所示：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"A concerned "</span> &lt;&lt; bird &lt;&lt; <span class="string">" speaks\n"</span></span><br></pre></td></tr></table></figure><br>字符串字面值是常量，这就是为什么代码在声明中使用关键字 const的原因。以这种方式使用 const意味着可以用bird来访问字符串，但不能修改它。最后，指针ps未被初始化因此不指向任何字符串。打印它可能报错。</p>
<p>试图将信息读入ps指向的位置将更糟。由于ps没有被初始化，因此并不知道信息将被存储在哪里，这甚至可能改写内存中的信息。要避免这种问题很容易只要使用足够大的char数组来接收输入即可。请不要使用字符串常量或未被初始化的指针来接收输入。为避免这些问题，也可以使用 std:string对象，而不是数组。</p>
<blockquote>
<p>警告：在将字符串读入程序时，应使用已分配的内存地址。该地址可以是数组名，也可以是使用切始化过的指针。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ps = animal;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; animal &lt;&lt; <span class="string">" at "</span> &lt;&lt; (<span class="keyword">int</span>*)animal &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ps &lt;&lt; <span class="string">" at "</span> &lt;&lt; (<span class="keyword">int</span>*)(ps) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>一般来说，如果给cout提供一个指针，它将打印地址。但如果指针的类型为char$<em>$，则cout将显示指向的字符串。如果要显示的是字符串的地址，则必须将这种指针强制转换为另一种指针类型，如int</em>（上面的代码就是这样做的）。因此，ps显示为字符串“fox”，而（int$<em>$）ps显示为该字符串的地址。<em>*注意，将animal赋给ps并不会复制字符串，而只是复制地址。这样，这两个指针将指向相同的内存单元和字符串。</em></em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ps = <span class="keyword">new</span> <span class="keyword">char</span> [<span class="built_in">strlen</span>(animal)+<span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(ps,animal);    <span class="comment">//赋值字符串到新的地址</span></span><br></pre></td></tr></table></figure>
<p>strcpy()函数接收两个参数，第一个是目标地址，第二个是要复制的字符串的地址。除p（函数接受2个参数，第一个是目标地址。分配空间，需要有足够的空间来存储副本。在这里，我们用 strlen（）来确定所需的空间，并使用new获得可用的内存。</p>
<h4 id="字符串复制给数组"><a href="#字符串复制给数组" class="headerlink" title="字符串复制给数组"></a>字符串复制给数组</h4><p>我们经常需要将字符串放到数组中。<strong>初始化数组时，使用=运算符，其他时候使用strcpy()或 strncpy().</strong>示例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> food[<span class="number">20</span>] = <span class="string">"carrots"</span>;   <span class="comment">//初始化</span></span><br><span class="line"><span class="built_in">strcpy</span>(food,<span class="string">"flan"</span>);         <span class="comment">//其他时候</span></span><br></pre></td></tr></table></figure><br>但是类似下面这样的代码可能导致问题，因为food数组比字符串小：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>（food, <span class="string">"a picnic basket filled with many goodies"</span>）;</span><br></pre></td></tr></table></figure><br>在这种情况下，函数将字符串中剩余的部分复制到数组后面的内存字节中，这可能会覆盖程序正在使用的其他内存。要避兔这种问题，可使用strncpy()。该函数还接受第3个参数—要复制的最大字符数.<strong>要注意的是，如果该函数在到达字符串结尾之前，目标内存已经用完，则它将不会添加空字符</strong>。因此，应该这样使用该函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strncpy</span> （food, <span class="string">"a picnic basket filled with many goodies"</span>,<span class="number">19</span>）;</span><br><span class="line">food[<span class="number">19</span>]=<span class="string">'\0'</span>;</span><br></pre></td></tr></table></figure><br>这样最多将19个字符复制到数组中，然后将最后一个元素设置成空字符。如果该字符串少于19个字符，则 strncpy()将在复制完该字符串之后加上空字符，以标记该字符串的结尾。</p>
<p><strong>强调：应使用strcpy()或strncpy()，而不是赋值运算符来将字符串赋给数组。</strong></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之指针_1</title>
    <url>/articles/6892c111.html/</url>
    <content><![CDATA[<h3 id="1-指针简介"><a href="#1-指针简介" class="headerlink" title="1.指针简介"></a>1.指针简介</h3><p>计算机程序在存储数据时必须跟踪3种基本属性：</p>
<ul>
<li>信息存储在何处</li>
<li>存储的值为多少</li>
<li>存储的信息是什么类型</li>
</ul>
<a id="more"></a>
<p>一种策略是：定义一个简单变量。声明语句指出了值的类型和符号名，还让程序为值分配内存，并在内部跟踪该存储单元。</p>
<p>另外一种策略，它在开发C++类时非常重要，这种策略以指针为基础，指针是一个变量其存储的是值的地址，而不是值本身。在讨论指针之前，我们先看一看如何找到常规变量的地址。只需对变量应用地址运算符（&amp;），就可以获得它的位置：例如，如果home是一个变量，则&amp;home是它的地址。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">	<span class="keyword">int</span> donuts = <span class="number">6</span>;</span><br><span class="line">	<span class="keyword">double</span> cups = <span class="number">4.5</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"donuts value = "</span> &lt;&lt; donuts;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">" and donuts address = "</span> &lt;&lt; &amp;donuts &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"cups value = "</span> &lt;&lt; cups;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">" and cups address = "</span> &lt;&lt; &amp;cups &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;程序输出</span><br><span class="line">donuts value &#x3D; 6 and donuts address &#x3D; 0x0065fd40</span><br><span class="line">cups value &#x3D; 4.5 and cups address &#x3D; 0x0065fd44</span><br></pre></td></tr></table></figure>
<p>处理存储数据的新策略刚好相反，将地址视为指定的量，而将值视为派生量。一种特殊类型的变量—指针,用于存储值的地址。因此，指针名表示的是地址。<code>*</code>运算符被称为间接值(indirect value)或解除引用(dereferencing运算符，将其应用于指针，可以得到该地址处存储的值（这和乘法使用的符号相同；C++根据上下文来确定所指的是乘法还是解除引用）。例如，假设manyl是个指针，则 manly表示的是一个地址，而<code>*</code>manly表示存储在该地址处的值。<code>*</code>manly与常规int变量等效。</p>
<ul>
<li><p>指针示例pointer.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">	<span class="keyword">int</span> updates = <span class="number">6</span>;</span><br><span class="line">	<span class="keyword">int</span> * p_updates;</span><br><span class="line">	p_updates = &amp;updates;</span><br><span class="line">	<span class="comment">//显示值</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Values: updates = "</span> &lt;&lt; updates;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">", *p_updates = "</span> &lt;&lt; *p_updates &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//显示地址</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Address: &amp;updataes = "</span> &lt;&lt; &amp;updates;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">",p_updates = "</span> &lt;&lt; p_updates &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//使用指针更改值</span></span><br><span class="line">	*p_updates = *p_updates + <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Now updates = "</span> &lt;&lt; updates &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">Value: updates &#x3D; 6,*p_updates &#x3D; 6</span><br><span class="line">Address: &amp;updatas &#x3D; 0x0065fd48,p_updates &#x3D; 0x0065fd48</span><br><span class="line">Now updates &#x3D; 7</span><br></pre></td></tr></table></figure>
<p>从中可知，int变量updates和指针变量 p<em>updates只不过是同一枚硬币的两面，变量updates表示值,并使用&amp;运算符来获得地址：而变量p_updates表示地址，并使用运算符来获得值（参见图4.8）。由于p</em> updates指向 updates，因此<code>*</code>p<em>updates和 updates完全等价。可以像使用int变量那样使用 <code>*</code>p</em> updates，正如上述程序表明的，甚至可以将值赋给<code>*</code>p_updates，这样做将修改指向的值，即updates</p>
</li>
</ul>
<p><img src="http://cdn.wangng.com/C++/C++之指针_1/image_48.png" alt></p>
<h4 id="1-2指针声明和初始化"><a href="#1-2指针声明和初始化" class="headerlink" title="1.2指针声明和初始化"></a>1.2指针声明和初始化</h4><p>计算机需要跟踪指针指向的值的类型。例如，char的地址与 double的地址看上去没什么两样，但char和 double使用的字节数是不同的，它们存储值时使用的内部格式也不同。因此，指针声明必须指定指针指向的数据的类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> * p_udates;</span><br></pre></td></tr></table></figure>
<p>这表明，$<em>$ p_updates的类型为int。由于$</em>$运算符被用于指针，因此p_updates变量本身必须是指针。我们说p_updates指向int类型，我们还说p_updates的类型是指向int的指针，或int<em> 类型，可以这样说，p_updates是指针(地址)，而 </em> p_updates是int,而不是指针(见图4.9).</p>
<p><img src="http://cdn.wangng.com/C++/C++之指针_1/image_49.png" alt></p>
<p>顺便说一句，* 运算符两边的空格是可选的。传统上C程序员使用这种格式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptr</span><br></pre></td></tr></table></figure>
<p>这强调*ptr是一个int类型的值。而很多C++程序元使用这种格式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* ptr</span><br></pre></td></tr></table></figure>
<p>这强调int* 是一种类型—指向int的指针。</p>
<p>但要知道的是，下面的声明创建一个指针(p1)和一个int变量(p2)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* p1,p2;</span><br></pre></td></tr></table></figure>
<p>对每一个指针变量名，都需要使用一个*。</p>
<p>可以用同样的句法来声明指向其他类型的指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> * tax_ptr;  <span class="comment">//指向double类型的指针</span></span><br><span class="line"><span class="keyword">char</span> * str;        <span class="comment">//指向char类型的指针</span></span><br></pre></td></tr></table></figure>
<p>由于已将tax_ptr声明为一个指向 double的指针，因此编译器知道 <code>*</code>tax_ptr是一个 double类型的值。也就是说，它知道 <code>*</code>tax_ptr是一个以浮点格式存储的值，这个值（在大多数系统上）占据8个字节。指针变量不仅仅是指针，而且是指向特定类型的指针。 tax_ptr的类型是指向 double的指针(或 double <code>*</code>类型),str是指向char的指针类型(或char *)。尽管它们都是指针，却是不同类型的指针。和数组一样，指针都是基于其他类型的。</p>
<p>虽然tax_ptr和str指向两种长度不同的数据类型，但这两个变量本身的长度通常是相同的，也就是说， char的地址与 double的地址的长度相同，这就好比1016可能是超市的街道地址，而1024可以是小村庄的道地址一样。地址的长度或值既不能指示关于变量的长度或类型的任何信息，也不能指示该地址上有什么建筑物。一般来说，地址需要2个还是4个字节，取决于计算机系统(有些系统可能需要更大的地址,系统可以针对不同的类型使用不同长度的地址）。</p>
<p>可以在声明语句中初始化指针。在这种情况下，被初始化的是指针，而不是它指向的值。也就是说下面的语句将pt（而不是*pt）的值设置为&amp; higgens：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> higgens = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> * pt = &amp;higgens;</span><br></pre></td></tr></table></figure>
<h4 id="1-3指针和数字"><a href="#1-3指针和数字" class="headerlink" title="1.3指针和数字"></a>1.3指针和数字</h4><p>指针不是整型，虽然计算机通常把地址当作整数来处理。从概念上看，指针与整数是截然不同的类型。整数是可以执行加、减、除等运算的数字，而指针描述的是位置，将两个地址相乘没有任何意义。从可以对整数和指针执行的操作上看，它们也是彼此不同的。因此，不能简单地将整数赋给指针:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> * pt;</span><br><span class="line">pt = <span class="number">0xB8000000</span>;    <span class="comment">//类型不匹配;</span></span><br></pre></td></tr></table></figure>
<p>在这里，左边是指向int的指针，因此可以把它赋给地址，但右边是一个整数。你可能知道，0xB8000000是老式计算机系统中内存的组合段偏移地址，但这条语句并没有告诉程序，这个数字就是一个地址。在C99标准发布之前，C语言允许这样赋值。但C++在类型一致方面的要求更严格，编译器将显示一条错误消息，通告类型不匹配。要将数字值作为地址来使用，应通过强制类型转换将数字转换为适当的地址类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> * pt;</span><br><span class="line">pt = (<span class="keyword">int</span>*) <span class="number">0xB8000000</span>;  <span class="comment">//类型匹配</span></span><br></pre></td></tr></table></figure>
<h4 id="1-4使用new来分配内存"><a href="#1-4使用new来分配内存" class="headerlink" title="1.4使用new来分配内存"></a>1.4使用new来分配内存</h4><p>前面我们都将指针初始化为变量的地址;变量是在编译时分配的有名称的内存，而指针只是为可以通过名称直接访问的内存提供了 一个别名。指针真正的用武之地在于，在运行阶段分配未命名的内存以存储值。在这种情况下，只能通过指针来访问内存。</p>
<p>下面来试试这种新技术，在运行阶段为一个int值分配未命名的内存，并使用指针来访问这个值。这里的关键所在是C++的new运算符。程序员要告诉new，需要为哪种数据类型分配内存；new将找到一个长度正确的内存块，并返回该内存块的地址。程序员的责任是将该地址赋给一个指针。下面是一个这样的示例:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> * pn = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br></pre></td></tr></table></figure>
<p>new int告诉程序，需要适合存储int的内存。new运算符根据类型来确定需要多少字节的内存。然后它找到这样的内存，并返回其地址。接下来，将地址赋给pn,pn是被声明为指向int的指针，现在，pn是地址，而*pn是存储在那里的值。将这种方法与将变量的地址赋给指针进行比较：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> higgens;</span><br><span class="line"><span class="keyword">int</span> * pt = &amp;higgens;</span><br></pre></td></tr></table></figure>
<p>在这两种情况（pn和pt）下，都是将一个int变量的地址赋给了指针。在第二种情况下，可以通过名称 higgens来访问该int，在第一种情况下，则只能通过该指针进行访问，这引出了一个问题：pn指向的内存没有名称，如何称呼它呢？我们说pn指向一个数据对象，这里的“对象”不是“面向对象编程”中的对象，而是一样“东西”。术语“数据对象”比“变量”更通用，它指的是为数据项分配的内存块。因此，变量也是数据对象，但pn指向的内存不是变量。乍一看，处理数据对象的指针方法可能不太好用，但它使程序在管理内存方面有更大的控制权。</p>
<p>为一个数据对象（可以是结构，也可以是基本类型）获得并指定分配内存的通用格式如：</p>
<p>typeName * pointer_name = new typeName </p>
<p>需要在两个地方指定数据类型：用来指定需要什么样的内存和用来声明合适的指针。当然，如果已经声明了相应类型的指针，则可以使用该指针，而不用再声明一个新的指针。下面程序展示如何将new用于两种不同的类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ues_new.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">	<span class="keyword">int</span> nights = <span class="number">1001</span>;</span><br><span class="line">	<span class="keyword">int</span> * pt = <span class="keyword">new</span> <span class="keyword">int</span>;   <span class="comment">//分配一个int内存</span></span><br><span class="line">	*pt = <span class="number">1001</span>;           <span class="comment">//给该内存赋值</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"nights value = "</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; nights &lt;&lt; <span class="string">": location "</span> &lt;&lt; &amp;nights &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"int "</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"value = "</span> &lt;&lt; *pt &lt;&lt; <span class="string">": location = "</span> &lt;&lt; pt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">double</span> * pd = <span class="keyword">new</span> <span class="keyword">double</span>; <span class="comment">//分配一个double内存</span></span><br><span class="line">	*pd = <span class="number">10000001.0</span>;     <span class="comment">//给该内存赋double类型值</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"double "</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"value = "</span> &lt;&lt; *pd &lt;&lt; <span class="string">":location = "</span> &lt;&lt; pd &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"location of pointer pd： "</span> &lt;&lt; &amp;pd &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"size of pt = "</span> &lt;&lt; <span class="keyword">sizeof</span>(pt);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">": size of *pt = "</span> &lt;&lt; <span class="keyword">sizeof</span>(*pt) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"size of pd = "</span> &lt;&lt; <span class="keyword">sizeof</span> pd;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">": size of *pd = "</span> &lt;&lt; <span class="keyword">sizeof</span>(*pd) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//程序输出</span></span><br><span class="line">nights value = <span class="number">1001</span>: location = <span class="number">0028F</span>7F8;</span><br><span class="line"><span class="keyword">int</span> value = <span class="number">1001</span>: location = <span class="number">00033</span>A98</span><br><span class="line"><span class="keyword">double</span> value = <span class="number">1e+007</span>: location = <span class="number">000339B</span>8</span><br><span class="line">location of pointer pd: <span class="number">0028F</span>7FC</span><br><span class="line"><span class="built_in">size</span> of pt = <span class="number">4</span>: <span class="built_in">size</span> of *pt = <span class="number">4</span></span><br><span class="line"><span class="built_in">size</span> of pd = <span class="number">4</span>: <span class="built_in">size</span> of *pd = <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>当然,内存位置的准确值随系统而异。</p>
<p>对于指针，需要指出的另一点是，new分配的内存块通常与常规变量声明分配的内存块不同，变量和pd的值都存储在被称为栈（ stack）的内存区域中，而new从被称为堆（heap）或自由存储区（free store)的内存区域分配内存。</p>
<h4 id="1-5使用delete释放内存"><a href="#1-5使用delete释放内存" class="headerlink" title="1.5使用delete释放内存"></a>1.5使用delete释放内存</h4><p>当需要内存时，可以使用new来请求，这只是C++内存管理数据包中有魅力的一个方面。另一个方面是 delete运算符，它使得在使用完内存后，能够将其归还给内存池，这是通向最有效地使用内存的关键一步。归还或释放（free）的内存可供程序的其他部分使用。使用 delete时，后面要加上指向内存块的指针（这些内存块最初是用new分配的):</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> * ps = <span class="keyword">new</span> <span class="keyword">int</span>;   <span class="comment">//使用new分配一个内存</span></span><br><span class="line">...                   <span class="comment">//使用内存</span></span><br><span class="line"><span class="keyword">delete</span> ps;             <span class="comment">//使用完后释放内存</span></span><br></pre></td></tr></table></figure>
<p>这将释放ps指向的内存，但不会删除指针ps本身，例如，可以将ps重新指向另一个新分配的内存块定要配对地使用new和 delete否则将发生内存泄漏（ memory leak），也就是说，被分配的内存再也无法使用了。如果内存泄漏严重，则程序将由于不断寻找更多内存而终止。</p>
<p>不要尝试释放已经释放的内存块，C++标准指出，这样做的结果将是不确定的，这意味着什么情况都可能发生。另外，不能使用 delete来释放声明变量所获得的内存：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> * ps = <span class="keyword">new</span> <span class="keyword">int</span>;  <span class="comment">//ok</span></span><br><span class="line"><span class="keyword">delete</span> ps;            <span class="comment">//ok</span></span><br><span class="line"><span class="keyword">delete</span> ps;            <span class="comment">//not ok</span></span><br><span class="line"><span class="keyword">int</span> jugs = <span class="number">5</span>;        <span class="comment">//ok</span></span><br><span class="line"><span class="keyword">int</span> * pi = &amp;jugs     <span class="comment">//ok</span></span><br><span class="line"><span class="keyword">delete</span> pi             <span class="comment">//不允许；内存不是由new分配的</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：只能用 delete来释放使用new分配的内存。对空指针使用 delete是安全的。</strong></p>
<p>注意，使用 delete的关键在于，将它用于new分配的内存。这并不意味着要使用用于new的指针，而是用于new的地址：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> * ps = <span class="keyword">new</span> <span class="keyword">int</span>;   <span class="comment">//分配内存</span></span><br><span class="line"><span class="keyword">int</span> * pq = ps;        <span class="comment">//设置第二个指针指向同一个内存</span></span><br><span class="line"><span class="keyword">delete</span> pq;             <span class="comment">//删除第二个指针指向的内存</span></span><br></pre></td></tr></table></figure>
<p>般来说，不要创建两个指向同一个内存块的指针，因为这将增加错误地删除同一个内存块两次的可能性。但稍后你会看到，对于返回指针的函数，使用另一个指针是有道理的。</p>
<h4 id="1-6使用new创建动态数组"><a href="#1-6使用new创建动态数组" class="headerlink" title="1.6使用new创建动态数组"></a>1.6使用new创建动态数组</h4><p>如果程序只需要一个值，则可能会声明一个简单变量，因为对于管理一个小型数据对象来说，这样做比使用new和指针更简单，尽管给人留下的印象不那么深刻。通常，对于大型数据（如数组、字符串和结构），应使用new，这正是new的用武之地。例如，假设要编写一个程序，它是否需要数组取决于运行时用户提供的信息。如果通过声明来创建数组，则在程序被编译时将为它分配内存空间。不管程序最终是否使用数组，数组都在那里，它占用了内存。在编译时给数组分配内存被称为静态联编（ static binding），意味着数组是在编译时加入到程序中的。但使用new时，如果在运行阶段需要数组，则创建它；如果不需要则不创建。还可以在程序运行时选择数组的长度。这被称为动态联编（ dynamic binding），意味着数组是在程序运行时创建的。这种数组叫作动态数组（ dynamic array）。使用静态联编时，必须在编写程序时指定数组的长度；使用动态联编时，程序将在运行时确定数组的长度。</p>
<p><strong>使用new创建动态数组</strong></p>
<p>在C++中，创建动态数组很容易：只要将数组的元素类型和元素数目告诉new即可。必须在类型名后加上方括号，其中包含元素数目。例如，要创建一个包含10个int元素的数组，可以这样做：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> * psome = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p>new运算符返回第一个元素的地址。在这个例子中，该地址被赋给指针 psome</p>
<p>当程序使用完new分配的内存块时，应使用 delete释放它们。然而，对于使用new创建的数组，应使种格式的 delete来释放：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> [] psome;   <span class="comment">//释放一个动态数组</span></span><br></pre></td></tr></table></figure>
<p>方括号告诉程序，应释放整个数组，而不仅仅是指针指向的元素。请注意 delete和指针之间的方括号如果使用new时，不带方括号，则使用 delete时，也不应带方括号。如果使用new时带方括号，则使用 delete时也应带方括号。C++的早期版本无法识别方括号表示法。然而，对于 ANSIISO标准来说，new与delete的格式不匹配导致的后果是不确定的，这意味着程序员不能依赖于某种特定的行为。下面是一个例子:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> * pt = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">short * ps = <span class="keyword">new</span> short [<span class="number">500</span>];</span><br><span class="line"><span class="keyword">delete</span> [] pt;    <span class="comment">//不能这样做</span></span><br><span class="line"><span class="keyword">delete</span> ps;       <span class="comment">//不能这样做</span></span><br></pre></td></tr></table></figure>
<p>总之，使用new和delet时，应遵循以下规则。</p>
<ul>
<li>不要使用delet释放不是new分配的内存</li>
<li>不要使用delet释放同一个内存块两次。</li>
<li>如果使用new []为数组分配内存，则应使用delet[]释放</li>
<li>如果使用new[]为一个实体分配内存，则应使用delete(没有方括号)来释放。</li>
<li>对空指针应用delete时安全的。</li>
</ul>
<p>现在我们回过头来讨论动态数组。psome是指向一个int（数组第一个元素）的指针。你的责任是跟踪内存块中的元素个数。也就是说，由于编译器不能对 psome是指向10个整数中的第1个这种情况进行跟踪，因此编写程序时，必须让程序跟踪元素的数目。</p>
<p>实际上，程序确实跟踪了分配的内存量，以便以后使用 delete[]运算符时能够正确地释放这些内存，这种信息不是公用的，例如，不能使用 sizeof运算符来确定动态分配的数组包含的字节数。为数组分配内存的通用格式如下：</p>
<p>type_name * pointer_name = new type_name [num_elements];</p>
<p>使用new运算符可以确保内存块足以存储 num elements个类型为 type_name的元素，而pointer name将指向第1个元素。下面将会看到，可以以使用数组名的方式来使用 pointer_name。</p>
<p><strong>使用动态数组</strong></p>
<p>创建动态数组后，如何使用它呢？首先，从概念上考虑这个问题。下面的语句创建指针 psome，它指向包含10个int值的内存块中的第1个元素：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> * psome = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">10</span>]; <span class="comment">//得到占10个int大小的内存块</span></span><br></pre></td></tr></table></figure>
<p>可以将它看作是一根指向该元素的手指。假设int占4个字节，则将手指沿正确的方向移动4个字节，手指将指向第2个元素。总共有10个元素，这就是手指的移动范围。因此，new语句提供了识别内存块中每个元素所需的全部信息。</p>
<p>现在从实际角度考虑这个问题。如何访问其中的元素呢？第一个元素不成问题。由于 psome指向数组的第1个元素，因此<em> psome是第1个元素的值。这样，还有9个元素。如果没有使用过C语言，下面这种最简单的方法可能会令你大吃一惊：只要把指针当作数组名使用即可。也就是说，对于第1个元素，可以使用 psome[0]，而不是· </em> psome；对于第2个元素，可以使用 psome[1]，依此类推。这样，使用指针来访问动态数组就非常简单了，虽然还不知道为何这种方法管用。可以这样做的原因是，C和C++内部都使用指针来处理数组。数组和指针基本等价是C和C++的优点之一（这在有时候也是个问题，但这是另一码事）。首先，程序arraynew.cpp演示了如何使用new来创建动态数组以及使用数组表示法来访问元素；它还指出了指针和真正的数组名之间的根本差别。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">	<span class="keyword">double</span> * p3 = <span class="keyword">new</span> <span class="keyword">double</span> [<span class="number">3</span>];</span><br><span class="line">	p3[<span class="number">0</span>] = <span class="number">0.2</span>;</span><br><span class="line">	p3[<span class="number">1</span>] = <span class="number">0.5</span>;</span><br><span class="line">	p3[<span class="number">2</span>] = <span class="number">0.8</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"p3[1] is "</span> &lt;&lt; p3[<span class="number">1</span>] &lt;&lt; <span class="string">".\n"</span>;</span><br><span class="line">	p3 = p3 + <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Now p3[0] is"</span> &lt;&lt; p3[<span class="number">0</span>] &lt;&lt; <span class="string">" and "</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"p3[1] is "</span> &lt;&lt; p3[<span class="number">1</span>] &lt;&lt; <span class="string">".\n"</span>;</span><br><span class="line">	p3 = p3 - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">delete</span> [] p3;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;程序输出</span><br><span class="line">p3[1] is 0.5.</span><br><span class="line">Now p3[0] is 0.5 and p3[1] is 0.8.</span><br></pre></td></tr></table></figure>
<p>从中可知， arraynew.cpp将指针p3当作数组名来使用，p3[0]为第1个元素，依次类推。下面的代码行指出了数组名和指针之间的根本差别:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">p3 = p3 + <span class="number">1</span>;   <span class="comment">//对与指针可行，对于数组则是不可行</span></span><br></pre></td></tr></table></figure>
<p>不能修改数组名的值。但指针是变量，因此可以修改它的值。请注意将p3加1的效果。表达式p3[0]现在指的是数组的第2个值。因此，将p3加1导致它指向第2个元素而不是第1个。将它减1后，指针将指向原来的值，这样程序便可以给 delete[]提供正确的地址。相邻的int地址通常相差2个字节或4个字节，而将p3加1后，它将指向下一个元素的地址，这表明指针算术有一些特别的地方。情况确实如此。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之数组</title>
    <url>/articles/8f9a18b2.html/</url>
    <content><![CDATA[<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组（array）是一种数据格式，能够存储多个同类型的值。每个值都存储在一个独立的数组元素中，计算机在内存中依次存储数组的各个元素。要创建数组，可使用声明语句。数组声明应指出以下三点：</p>
<a id="more"></a>
<ul>
<li>存储在每个元素中的值的类型；</li>
<li>数组名</li>
<li>数组中的元素数</li>
</ul>
<p>在C++中，可以通过修改简单变量的声明，添加中括号（其中包含元素数目）来完成数组声明。例如，下面的声明创建一个名为 months的数组，该数组有12个元素，每个元素都可以存储一个 short类型:</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">short months[<span class="number">12</span>]</span><br></pre></td></tr></table></figure>
<p>声名数组的通用格式如下</p>
<p>​<em>typeName arrayName[arraySize];</em></p>
<p>​表达式 arraySize指定元素数目，它必须是整型常数（如10）或const值，也可以是常量表达式（如8·<br>sizeof（int），即其中所有的值在编译时都是已知的。具体地说， arraySize不能是变量，变量的值是在程序时设置的。</p>
<p>​数组的很多用途都是基于这样一个事实：可以单独访问数组元素，方法是使用下标或索引来对元素进行编号。C++数组从0开始编号。C++使用带索引的方括号表示法来指定数组元素，例如， months[0]是 months数组的第一个元素， months[11]是最后一个元素。注意，最后一个元素的索引比数组长度小1（参见图1）。因此，数组声明能够使用个声明创建大量的变量，然后便可以用索引来标识和访问各个元素</p>
<p><img src="http://cdn.wangng.com/C++/C++之数组/image1.png" alt></p>
<h4 id="数组的初始化规则"><a href="#数组的初始化规则" class="headerlink" title="数组的初始化规则"></a>数组的初始化规则</h4><p>只有定义数组时才能使用初始化，此后就不能使用了，也不能将一个数组赋给另一个数组：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cards[<span class="number">4</span>] = &#123;<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>&#125;;    <span class="comment">//okay</span></span><br><span class="line"><span class="keyword">int</span> hand[<span class="number">4</span>];                  <span class="comment">//okay</span></span><br><span class="line">hand[<span class="number">4</span>] = &#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;          <span class="comment">//not okay</span></span><br><span class="line">hand = cards;                 <span class="comment">// not okay</span></span><br></pre></td></tr></table></figure>
<p>也可以使用下标分别给数组中的元素赋值。</p>
<p>初始化数组时，提供的值可以少于数组的元素数目。例如，下面的语句只初始化hotelTips的前两个元素：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> hotelTips[<span class="number">5</span>] = &#123;<span class="number">5.0</span>,<span class="number">2.5</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>如果只对数组的一部分进行初始化，则编译器将把其他元素设置为0.因此，将数组中所有的元素都初始化为0非常简单—只要显式地将第一个元素初始化为0，然后让编译器将其他元素都初始化为0;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> totals[<span class="number">500</span>] = &#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>如果初始化为{1} 而不是{0}，则第一个元素设置为1，其他元素被设置为0。</p>
<p>如果初始化数组时方括号内([])为空，C++编译器将计算元素个数，例如，对于下面的声名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">short things[] &#x3D; &#123;1, 5, 3, 8&#125;</span><br></pre></td></tr></table></figure>
<p>编译器将使things数组包含4个元素。</p>
<h4 id="C-11初始化方法"><a href="#C-11初始化方法" class="headerlink" title="C++11初始化方法"></a>C++11初始化方法</h4><p>C++使用大括号的初始化(列表初始化)作为一种通用初始化方法，可用于所有类型。数组以前就可使用列表初始化，但C++中列表初始化新增了一些功能。</p>
<p>1.初始化数组时，可以省略等号(=)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> earnings[<span class="number">4</span>] &#123;<span class="number">1.2e4</span>,<span class="number">1.6e4</span>,<span class="number">1.1e4</span>,<span class="number">1.7e4</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>2.可在大括号内不包含任何东西，这将把所有元素都设置为零：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> counts[<span class="number">10</span>]=&#123;&#125;； <span class="comment">//all elements set to 0</span></span><br><span class="line"><span class="keyword">float</span> balances[<span class="number">100</span>] &#123;&#125;      <span class="comment">//all elements set to 0</span></span><br></pre></td></tr></table></figure>
<p>3.列表初始化禁止缩窄转换</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> plifs[] = &#123;<span class="number">25</span>,<span class="number">92</span>,<span class="number">3.0</span>&#125;   <span class="comment">// not allowed</span></span><br><span class="line"><span class="keyword">char</span> slifs[<span class="number">4</span>] &#123;<span class="string">'h'</span>,<span class="string">'i'</span>,<span class="number">1122011</span>,<span class="string">'\0'</span>&#125; <span class="comment">// not allowed</span></span><br><span class="line"><span class="keyword">char</span> tlifs[<span class="number">4</span>] &#123;<span class="string">'h'</span>,<span class="string">'i'</span>,<span class="number">112</span>,<span class="string">'\0'</span>&#125;   <span class="comment">//allowed</span></span><br></pre></td></tr></table></figure>
<p>在上述代码中，第一条语句不能通过编译，因为将浮点数转换为整型是缩窄操作，即使浮点数的小数点后面为零。第二条语句也不能通过编译，因为1122011超出了char变量的取值范围（这里假设char变量的长度为8位）。第三条语句可通过编译，因为虽然112是一个int值，但它在char变量的取值范围内。</p>
<h3 id="数组的替代品"><a href="#数组的替代品" class="headerlink" title="数组的替代品"></a>数组的替代品</h3><p>模板类vector和array是数组的替代品；这些替代品对于数组的创建和使用更加灵活简便。</p>
<h4 id="模板类vector"><a href="#模板类vector" class="headerlink" title="模板类vector"></a>模板类vector</h4><p>模板类 vector类似于 string类，也是一种动态数组。可以在运行阶段设置 vector对象的长度，可在末尾附加新数据，还可在中间插入新数据。基本上，它是使用new创建动态数组的替代品。实际上， vector类确实使用new和 delete来管理内存，但这种工作是自动完成的.</p>
<p>这里不深入探讨模板类意味着什么，而只介绍一些基本的实用知识。首先，要使用 vector对象，必须包含头文件 vector。其次， vector包含在名称空间std中，因此可使用 using编译指令、 using声明或std:vector e第三，模板使用不同的语法来指出它存储的数据类型。第四， vector类使用不同的语法来指定元素数。下面是一些示例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line">...</span><br><span class="line">usinga <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;   <span class="comment">//创建一个长度为零的int型数组</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">vd</span><span class="params">(n)</span></span>;  <span class="comment">//创建一个大小为n的double型数组</span></span><br></pre></td></tr></table></figure><br>其中，vi是一个 vector<int>对象，vd是一个 vector<double>对象。由于 vector对象在插入或添加值时自动调整长度，因此可以将vi的初始长度设置为零。但要调整长度，需要使用vector包中的各种方法。</double></int></p>
<p>一般而言，下面的声明创建一个名为vt的vector对象，它可存储n_elem个类型为type_Name的元素：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;typeName&gt; <span class="title">vt</span><span class="params">(n_elem)</span></span>;</span><br></pre></td></tr></table></figure><br>其中参数n_elem可以是整型常量，也可以是整型变量。</p>
<h4 id="模板类array-C-11"><a href="#模板类array-C-11" class="headerlink" title="模板类array(C++11)"></a>模板类array(C++11)</h4><p>vector类的功能比数组强大，但付出的代价是效率稍低。如果需要的是长度固定的数组，使用数组是更佳的选择，但代价是不那么方便和安全。有鉴于此，C++11新增了模板类aray，它也位于名称空间std中。与数组一样，aray对象的长度也是固定的，也使用栈（静态内存分配），而不是自由存储区，因此其效率与数组相同，但更方便，更安全。要创建aray对象，需要包含头文件array。array对象的创建语法与vector稍有不同：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; ai;   <span class="comment">//创建一个大小为5的array对象</span></span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">double</span>, 4&gt; ad = &#123;<span class="number">1.2</span>, <span class="number">2.1</span>, <span class="number">3.43</span>, <span class="number">4.3</span>&#125;;</span><br><span class="line"></span><br><span class="line">推而广之，下面的声名创建一个名为arr的<span class="built_in">array</span>的对象，它包含n_elem个类型为typeName的元素：</span><br><span class="line">```C++</span><br><span class="line"><span class="built_in">array</span>&lt;typeName, n_elem&gt; arr;</span><br></pre></td></tr></table></figure></p>
<p>与创建veto对象不同的是，n_elem不能是变量,在C++11中，可将列表初始化用于vector和array对象，但在C++98中，不能对vector对象这样做.</p>
<h4 id="比较数组、vector对象和array对象"><a href="#比较数组、vector对象和array对象" class="headerlink" title="比较数组、vector对象和array对象"></a>比较数组、vector对象和array对象</h4><p>要了解数组、 vector对象和aray对象的相似和不同之处，最简单的方式可能是看一个使用它们的简单示例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> iostream&gt;</span></span><br><span class="line">include &lt;<span class="built_in">vector</span>&gt; <span class="comment">//STL C++98</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt; //C++11</span></span></span><br><span class="line"><span class="keyword">int</span> main（）</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>；</span><br><span class="line">    <span class="comment">//C, original C++</span></span><br><span class="line">    <span class="keyword">double</span> a1[<span class="number">4</span>]=&#123;<span class="number">1.2</span>,<span class="number">2.4</span>,<span class="number">3.6</span>,<span class="number">4</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    <span class="comment">//C++98sTL </span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">a2</span><span class="params">(<span class="number">4</span>)</span></span>; <span class="comment">// create vector with 4 element</span></span><br><span class="line">    <span class="comment">// no simple way to initialize in C98</span></span><br><span class="line">    a2[<span class="number">0</span>]=<span class="number">1.0</span>/<span class="number">3.0</span>; </span><br><span class="line">    a2[<span class="number">1</span>]=<span class="number">1.0</span>/<span class="number">5.0</span>; </span><br><span class="line">    a2[<span class="number">2</span>]=<span class="number">1.0</span>/<span class="number">7.0</span>;</span><br><span class="line">    a2[<span class="number">3</span>]=<span class="number">1.0</span>/<span class="number">9.0</span>;</span><br><span class="line">    <span class="comment">// C++11-- create and initialize array object       </span></span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="keyword">double</span>，4&gt; a3 = &#123;<span class="number">3.14</span>,<span class="number">2.72</span>,<span class="number">1.62</span>,<span class="number">1</span>,<span class="number">41</span>&#125;;</span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="keyword">double</span>, 4&gt; a4;</span><br><span class="line">    a4=a3；  <span class="comment">//valid for array objects of same size</span></span><br><span class="line">    <span class="comment">// use array notation </span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"a1[2]："</span>&lt;&lt;a1[<span class="number">2</span>]&lt;&lt;<span class="string">"at"</span>&lt;&lt;&amp;a1[<span class="number">2</span>]&lt;&lt;end1;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"a2[2]："</span>&lt;&lt;a2[<span class="number">2</span>]&lt;&lt;<span class="string">"at"</span>&lt;&lt;&amp;a2[<span class="number">2l</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"a3[2]："</span>&lt;&lt;a[<span class="number">2</span>]&lt;&lt;<span class="string">"at"</span>&lt;&lt;&amp;a3[<span class="number">2</span>]&lt;&lt;<span class="built_in">endl</span>;<span class="built_in">cout</span>&lt;&lt;<span class="string">"a4[2]："</span>&lt;&lt;a4[<span class="number">2</span>]&lt;&lt;<span class="string">"at"</span>&lt;&lt;&amp;a4[<span class="number">2</span>]&lt;end1</span><br><span class="line">    <span class="comment">// misdeed </span></span><br><span class="line">    a1[<span class="number">-2</span>]=<span class="number">20.2</span>; </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"a1[-2]："</span>&lt;&lt;a1[<span class="number">2</span>]&lt;&lt;<span class="string">"at"</span>&lt;&amp;a1[<span class="number">-2</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"a3[2]："</span>&lt;&lt;a3[<span class="number">2l</span>&lt;&lt;<span class="string">"at"</span>&lt;&amp;a3[<span class="number">2</span>]&lt;&lt;<span class="built_in">endl</span>;<span class="built_in">cout</span>&lt;&lt;<span class="string">"a4[2]："</span>&lt;&lt;a4[<span class="number">2</span>]&lt;&lt;<span class="string">"at"</span>c&amp;a4[<span class="number">2</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    ruturn <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//程序输出</span></span><br><span class="line">a1[<span class="number">2</span>]：<span class="number">3</span>,<span class="number">6</span> at <span class="number">0x28cce8</span></span><br><span class="line">a2[<span class="number">2</span>]：<span class="number">0.142857</span> at <span class="number">0xca0328</span></span><br><span class="line">a3[<span class="number">2</span>]：<span class="number">1.62</span> at <span class="number">0x28ccc8</span></span><br><span class="line">a4[<span class="number">2</span>]：<span class="number">1.62</span> at <span class="number">0x28cca8</span></span><br><span class="line">a1[<span class="number">-2</span>]：<span class="number">20.2</span> at <span class="number">0x28ccc8</span></span><br><span class="line">a3[<span class="number">2</span>]：<span class="number">20.2</span> at <span class="number">0x2BcccB</span> </span><br><span class="line">a4[<span class="number">2</span>]：<span class="number">1.62</span> at <span class="number">0x28ccaB</span></span><br></pre></td></tr></table></figure></p>
<p>注意到无论是数组、 vector对象还是aray对象，都可使用标准数组表示法来访问各个元素。其次，从地址可知，aray对象和数组存储在相同的内存区域（即栈）中，而 vector对象存储在另一个区域（自由存储区或堆）中。第三，注意到可以将一个array对象赋给另一个aray对象：而对于数组，必须逐元素复制数据。</p>
<p>下面有一行代码需要特别注意：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a1[-2] &#x3D; 20.2;</span><br></pre></td></tr></table></figure><br>这个索引将被转换为如下代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*[a1-2] &#x3D; 20.2;</span><br></pre></td></tr></table></figure><br>其含义如下：找到a1指向的地方，向前移两个 double元素，并将20.2存储到目的地。也就是说将信息存储到数组的外面。与C语言一样，C++也不检查这种超界错误。在这个示例中，这个位置位于aray对象a3中。其他编译器可能将20.2放在a4中，甚至做出更糟糕的选择。这表明数组的行为是不安全的。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之指针_3</title>
    <url>/articles/869ca03d.html/</url>
    <content><![CDATA[<h3 id="使用new创建动态结构"><a href="#使用new创建动态结构" class="headerlink" title="使用new创建动态结构"></a>使用new创建动态结构</h3><p><strong>在运行时创建数组优于在编译时创建数组，对于结构也是如此</strong>。需要在程序运行时为结构分配所需的空间，这也可以使用new运算符来完成。通过使用new，可以创建动态结构。同样，“动态”意味着内存是在运行时，而不是编译时分配的。由于类与结构非常相似，因此这里介绍的有关结构的技术也适用于类。</p>
<p>将new用于结构由两步组成：创建结构和访问其成员。要创建结构，需要同时使用结构类型和new例如，要创建一个未命名的 inflatable类型，并将其地址赋给一个指针，可以这样做：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">inflatable * ps = <span class="keyword">new</span> inflatable;</span><br></pre></td></tr></table></figure><br>这将把存储inflatable结构的一块可用内存的地址赋给ps。<strong>创建动态结构时，不能将成员运算符句点用于结构名，因为这种结构没有名称</strong>，只是知道它的地址。C++专门为这种情况提供了一个运算符：箭头成员运算符（-&gt;）。该运算符由连字符和大于号组成，可用于指向结构的指针，就像点运算符可用于结构名一样。例如，如果ps指向一个inflatable结构，则ps-&gt;price是被指向的结构的price成员。</p>
<div align="center">
<img src="http://cdn.wangng.com/C++/C++之指针_3/img1.png"></div>

<blockquote>
<p>提示：有时，C++新手在指定结构成员时，搞不清楚何时应使用句点运算符，何时应使用箭头运算符规则非常简单。如果结构标识符是结构名，如grubnose，则使用句点运算符；如果标识符是指向结构的指针，如pt，则使用箭头运算符</p>
</blockquote>
<p>另一种访问结构成员的方法是，如果ps是指向结构的指针，则<code>*ps</code>就是被指向的值—结构本身。由于<code>*ps</code>是一个结构，因此(<code>*ps</code>).price是该结构的price成员。C++的运算符优先规则要求使用括号。示例程序使用new创建了一个未命名的结构，并演示了两种访问结构成员的指针表示法。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//程序4.21 newstrct.cpp  使用new创建结构体</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inflatable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">float</span> volume;</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    inflatable * ps = <span class="keyword">new</span> inflatable;   <span class="comment">//为inflatable结构分配内存</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter name of inflatable item: "</span>;</span><br><span class="line">    <span class="built_in">cin</span>.<span class="built_in">get</span>(ps-&gt;name,<span class="number">20</span>);   <span class="comment">//结构成员的方法一</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter volume in cubic feet: "</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; (*ps).volume;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter price: $"</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; ps-&gt;name;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Name: "</span> &lt;&lt; (*ps).name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Volume"</span> &lt;&lt; ps-&gt;volume &lt;&lt; <span class="string">"cubic feet\n"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Price: $"</span> &lt;&lt; ps-&gt;price &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> ps;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>程序输出<br>Enter name of inflatable item: Fabulous Frodo<br>Enter volume in cubic feet: 1.4<br>Enter price: 27.99<br>Name: Fabulous Frodo<br>Volume: 1.4 cubic feet<br>Price： 27.99</p>
</blockquote>
<h4 id="一个使用new和delete的示例"><a href="#一个使用new和delete的示例" class="headerlink" title="一个使用new和delete的示例"></a>一个使用new和delete的示例</h4><p>下面介绍一个使用new和 delete来存储通过键盘输入的字符串的示例，下面程序定义了一个函数getname()，该函数返回一个指向输入字符串的指针，该函数将输入读入到一个大型的临时数组中，然后使用new[]创建一个刚好能够存储该输入字符串的内存块，并返回一个指向该内存块的指针。对于读取大量字符串的程序，这种方法可以节省大量内存（实际编写程序时，使用 string类将更容易，因为这样可以使用内置的new和 delete）</p>
<p>假设程序要读取100个字符串，其中最大的字符串包含79个字符，而大多数字符串都短得多。如果用char数组来存储这些字符串，则需要1000个数组，其中每个数组的长度为80个字符。这总共需要80000个字节，而其中的很多内存没有被使用。另一种方法是，创建一个数组，它包含1000个指向char的指针,然后使用new根据每个字符串的需要分配相应数量的内存，这将节省几万个字节。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//程序清单4.22 delete.cpp</span></span><br><span class="line"><span class="comment">//delete.cpp     使用删除操作</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;  //或者string.h</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">getname</span><span class="params">(<span class="keyword">void</span>)</span></span>;  <span class="comment">//函数声名</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * name;       <span class="comment">//创建一个未初始化的指针</span></span><br><span class="line">    name = getname();   <span class="comment">//将字符串的地址赋给name</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">" at "</span> &lt;&lt; (<span class="keyword">int</span>*)name &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">delete</span> [] name;    <span class="comment">//释放内存</span></span><br><span class="line"></span><br><span class="line">    name = getname();  <span class="comment">//重新使用释放的内存</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">" at "</span> &lt;&lt; (<span class="keyword">int</span>*) name &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">delete</span> [] name;    <span class="comment">//内存再次释放</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">getname</span><span class="params">()</span>      <span class="comment">//返回新字符串的地址</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> temp[<span class="number">80</span>];    <span class="comment">//临时存储</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter last name: "</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">    <span class="keyword">char</span> * pn = <span class="keyword">new</span> <span class="keyword">char</span> [<span class="built_in">strlen</span>(temp)+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(pn,temp);  <span class="comment">//赋值字符串到较小的空间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pn;       <span class="comment">//当函数结束时temp被丢失</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>程序输出<br>Enter last name: Fredeldumpkin<br>Fredeldumpkin at 0x12e1358<br>Enter last name: Pook<br>Pook at 0x12e1358</p>
</blockquote>
<p>函数getname()它使用cin将输入的单词放到temp数组中，然后使用new分配新内存，以存储该单词。程序需要strlen(temp)+1个字符（包括空字符）来存储该字符串，因此将这个值提供给new。获得空间后,getname()使用标准库函数 strcpy（将temp中的字符串复制到新的内存块中。该函数并不检查内存块是否能够容纳字符串，但 getname（）通过使用new请求合适的字节数来完成了这样的工作。最后，函数返回pn，这是字符串副本的地址。</p>
<p>在main()中，返回值（地址）被赋给指针name.该指针是在main()中定义的，但它指向 getname()函数中分配的内存块。然后，程序打印该字符串及其地址。</p>
<p>在这个例子中， getname()分配内存，而main()释放内存，将new和 delete放在不同的函数中通常井不是个好办法，因为这样很容易忘记使用 delete.不过这个例子确实把new和 delete分开放置了，只是为了说明这样做也是可以的。</p>
<h3 id="自动存储、静态存储和动态存储"><a href="#自动存储、静态存储和动态存储" class="headerlink" title="自动存储、静态存储和动态存储"></a>自动存储、静态存储和动态存储</h3><p>根据用于分配内存的方法，C+有3种管理数据内存的方式：自动存储、静态存储和动态存储（有时也叫作自由存储空间或堆）。在存在时间的长短方面，以这3种方式分配的数据对象各不相同。下面简要地介绍每种类型(C++11新增了第四种类型—-线性存储)</p>
<h4 id="自动存储"><a href="#自动存储" class="headerlink" title="自动存储"></a>自动存储</h4><p>在函数内部定义的常规变量使用自动存储空间，被称为自动变量,这意味着它们在所属函数被调用时自动产生，在该函数结束时消亡。如上面4.22程序中temp数组仅当getname()函数活动时存在，当程序控制权回到main()时，temp使用的内存被自动释放。如果getname()返回temp的地址,则main()中的name指针指向的内存将很快得到重新使用，这就是在getname()中使用new的原因。</p>
<p>实际上，自动变量是一个局部变量，其作用域为包含它的代码块。代码块是被包含在花括号中的一段代码。如果在其中的某个代码块定义了一个变量，则该变量仅在程序执行该代码块中的代码时存在。</p>
<p><strong>自动变量通常存储在栈中。这意味着执行代码块时，其中的变量将依次加入到栈中，而在离开代码块时，将按相反的顺序释放这些变量，这被称为后进先出（LIFO）</strong>。因此，在程序执行过程中，栈将不断地增大和缩小。</p>
<h4 id="静态存储"><a href="#静态存储" class="headerlink" title="静态存储"></a>静态存储</h4><p><strong>静态存储是整个程序执行期间都存在的存储方式</strong>。使变量成为静态的方式有两种：一种是在函数外面定义它；另一种是在声明变量时使用关键字 static：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">double</span> fee = <span class="number">56.60</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="动态存储"><a href="#动态存储" class="headerlink" title="动态存储"></a>动态存储</h4><p>new和 delete运算符提供了一种比自动变量和静态变量更灵活的方法。它们管理了一个内存池，<strong>这在C++中被称为自由存储空间（ free store）或堆（heap）</strong>。该内存池中用于静态变量和自动变量的内存是分开的。程序4.22表明，new和 delete让我们能够在一个函数中分配内存，而在另一个函数中释放它。因此，数据的生命周期不完全受程序或函数的生存时间控制。与使用常规变量相比，使用new和 delete让程序员对程序如何使用内存有更大的控制权。然而，内存管理也更复杂了。在栈中，自动添加和删除机制使得占用的内存总是连续的，但new和delete的相互影响可能导致占用的自由存储区不连续，这使得跟踪新分配内存的位置更困难</p>
<h4 id="栈、堆和内存泄漏"><a href="#栈、堆和内存泄漏" class="headerlink" title="栈、堆和内存泄漏"></a>栈、堆和内存泄漏</h4><p>如果使用new运算符在自由存储空间（或堆）上创建变量后，没有调用delete,将发生什么情况呢？<br>如果没有调用delete,则即使包含指针的内存由于作用域规则和对象生命周期的原因而被释放，在自由存储空间上动态分配的变量或结构也将继续存在。实际上，将会无法访问自由存储空间中的结构，因为指向这些内存的指针无效。这将导致内存泄漏。被泄漏的内存将在程序的整个生命周期内都不可使用；这些内存被分配出去，但无法收回。极端情况（不过不常见）是，内存泄漏可能会非常严重，以致于应用程序可用的内存被耗尽，出现内存耗尽错误，导致程序崩溃。另外，这种泄漏还会给一些操作系统或在相同的内存空间中运行的应用程序带来负面影响，导致它们崩溃。</p>
<h3 id="类型组合"><a href="#类型组合" class="headerlink" title="类型组合"></a>类型组合</h3><p>我们学习了数组，结构和指针，其实还可以用各种方式组合他们。先从结构开始。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">antarctica_year_end</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">    <span class="keyword">int</span> birthday;</span><br><span class="line">    <span class="comment">/*还有一些实际有趣的数据等*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>可以创建这种类型的变量<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">antarctica_year_end s01, s02, s03; <span class="comment">//s01,s02,s03 是结构体</span></span><br></pre></td></tr></table></figure>
然后使用成员运算符访问其成员：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s01.year = <span class="number">1998</span>;</span><br></pre></td></tr></table></figure></li>
<li>可创建这种结构的指针：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">antarctica_year_end * pa = &amp;s02;</span><br></pre></td></tr></table></figure>
将该指针设置为有效地址后，就可使用间接成员运算符来访问成员：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pa-&gt;year = <span class="number">1999</span>;</span><br></pre></td></tr></table></figure></li>
<li>可创建结构数组:<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">antarctica_year_end trio[<span class="number">3</span>];  <span class="comment">//包含3个结构体的数组</span></span><br></pre></td></tr></table></figure>
然后可以使用成员运算符访问元素的成员：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">trio[<span class="number">0</span>].year = <span class="number">2003</span>;    <span class="comment">//trio[0]是一个结构体</span></span><br></pre></td></tr></table></figure>
其中tiro是一个数组，tiro[0]是一个结构，而 trio[0].year是该结构的一个成员，<strong>由于数组名是一个指针(数组名是第一个元素的地址)</strong>，因此也可使用间接成员运算符：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(trio+<span class="number">1</span>)-&gt;year = <span class="number">2004</span>;  <span class="comment">//等价于trio[1].year = 2004</span></span><br></pre></td></tr></table></figure></li>
<li>可创建指针数组:<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">antarctica_year_end *arp[<span class="number">3</span>] = &#123;&amp;s01, $s02, &amp;s03&#125;;</span><br></pre></td></tr></table></figure>
既然arp是一个指针数组，arp[1]就是一个指针，可将间接成员运算符应用于它，以访问成员:<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; arp[<span class="number">1</span>]-&gt;year &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之类与对象</title>
    <url>/articles/e7ccb3bf.html/</url>
    <content><![CDATA[<h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p>　　C++是一门面向对象的编程语言，而让C++具有这一特性的重要原因就是类和对象。类，通俗来说就是模板，一个模板可以创建很多的实例，也就是对象，比如人类就是一个类，而黄种人，白种人和黑种人就是这个类的对象。类包含属性和方法，比如身高，体重等是人类的属性，吃饭睡觉是人类的方法。我们在用类创建对象时，被称为类的实例化，而创建后的对象会继承类的属性和方法.</p>
<blockquote>
<p>和结构体一样,类只是一种复杂数据类型的声明,不占用内存.而对象是类这种数据类型的一个变量，或者说是通过类这种数据类型创建出来的一份实实在在的数据，所以占用内存空间。</p>
</blockquote>
<a id="more"></a>
<h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><p>我们以学生为例定义一个简单的类,该类包含学生的姓名,排名,总分等属性,还包含打印这些属性的方法.定义类,一般来说,类规范由两部分组成.</p>
<ol>
<li>类声明:以数据成员的方式描述类的属性,以类的成员函数原型定义类的方法</li>
<li>类方法的定义:定义类成员函数的具体操作<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//student1.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt; </span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> rank;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> grade;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setname</span><span class="params">(<span class="built_in">string</span> tname)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setrank</span><span class="params">(<span class="keyword">int</span> trank)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setscore</span><span class="params">(<span class="keyword">float</span> tscore)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; grade &lt;&lt; <span class="string">"的同学"</span> &lt;&lt;name &lt;&lt; <span class="string">"的总分是 "</span> &lt;&lt; score &lt;&lt; <span class="string">" ,排名是"</span>&lt;&lt; rank &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
C++用关键字class指出这些代码定义了一个类设计,Student是这个类的类型名,一般而言,类名要首字母大写.该声明让我们可以创建一个Student类型的变量-对象或实例.下面分别创建了连个名为xiaoming,xiaohong的对象.<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Student xiaoming;</span><br><span class="line">Student xiaohong;</span><br></pre></td></tr></table></figure>
另外这里有两个关键字<strong>private</strong>和<strong>puplic</strong>需注意,这两个关键字描述了<strong>类对象对类成员的访问权限</strong>,类对象可以直接访问公有部分,不可以访问私有部分,如需访问私有部分,可以通过访有公有部分间接来访问私有部分,如setname,setscore,setrank,print等.一般而言,private是默认存在的,定义在公有部分外面的成员变量或函数都属于私有部分.<blockquote>
<p>注意在类定义的最后有一个分号<code>;</code>，它是类定义的一部分，表示类定义结束了，不能省略。类只是一个模板（Template），编译后不占用内存空间，所以在定义类时不能对成员变量进行初始化，因为没有地方存储数据。只有在创建对象以后才会给成员变量分配内存，这个时候就可以赋值了。</p>
</blockquote>
</li>
</ol>
<h3 id="类成员函数"><a href="#类成员函数" class="headerlink" title="类成员函数"></a>类成员函数</h3><p>　　成员函数定义与常规函数定义非常相似，它们有函数头和函数体，也可以有返回类型和参数。但是它们还有两个特殊的特征：</p>
<ul>
<li><strong>定义成员函数时，使用作用域解析运算符(::)来标识函数所属的类；</strong></li>
<li>类方法可以访问类的 private组件。<br><strong>成员函数必须先在类体中作原型声明，然后在类外定义，也就是说类体的位置应在函数定义之前</strong>。例如成员函数setname()的函数头定义如下:<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vode <span class="title">Student::setname</span><span class="params">(<span class="built_in">string</span> name)</span></span></span><br></pre></td></tr></table></figure>
上述类成员函数的定义方法可以如下定义:<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//student2.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//类的声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:  <span class="comment">//私有的</span></span><br><span class="line">    <span class="built_in">string</span> m_name;</span><br><span class="line">    <span class="keyword">int</span> m_rank;</span><br><span class="line">    <span class="keyword">float</span> m_score;</span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//共有的</span></span><br><span class="line">    <span class="keyword">int</span> grade;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setname</span><span class="params">(<span class="built_in">string</span> name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setage</span><span class="params">(<span class="keyword">int</span> rank)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setscore</span><span class="params">(<span class="keyword">float</span> score)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//成员函数的定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::setname</span><span class="params">(<span class="built_in">string</span> name)</span></span>&#123;</span><br><span class="line">    m_name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::setrank</span><span class="params">(<span class="keyword">int</span> rank)</span></span>&#123;</span><br><span class="line">    m_rank = rank;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::setscore</span><span class="params">(<span class="keyword">float</span> score)</span></span>&#123;</span><br><span class="line">    m_score = score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; grade &lt;&lt; <span class="string">"的同学"</span> &lt;&lt;m_name &lt;&lt; <span class="string">"的成绩"</span> &lt;&lt;m_score&lt;&lt; <span class="string">"，排名是"</span> &lt;&lt; m_rank &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="内联类成员函数"><a href="#内联类成员函数" class="headerlink" title="内联类成员函数"></a>内联类成员函数</h4><p>其定义位于类声明中的函数都将自动成为内联函数,如student1.cpp中的print()函数,它在类内被定义了,将自动成为内联函数.类声明常将短小的成员函数作为内联函数.若将函数定义于类声明外,则须在函数前加上关键字inline;<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//student3.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt; </span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> rank;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> grade;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setname</span><span class="params">(<span class="built_in">string</span> tname)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setrank</span><span class="params">(<span class="keyword">int</span> trank)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setscore</span><span class="params">(<span class="keyword">float</span> tscore)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; grade &lt;&lt; <span class="string">"的同学"</span> &lt;&lt;name &lt;&lt; <span class="string">"的总分是 "</span> &lt;&lt; score &lt;&lt; <span class="string">" ,排名是"</span>&lt;&lt; rank &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">Student::setname</span><span class="params">(<span class="built_in">string</span> tname)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    name = tname;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>setname()就变成内联函数。这种在类体外定义 inline 函数的方式，必须将类的定义和成员函数的定义都放在同一个头文件中（或者同一个源文件中），否则编译时无法进行嵌入（将函数代码的嵌入到函数调用出）</p>
<h3 id="类成员函数的调用"><a href="#类成员函数的调用" class="headerlink" title="类成员函数的调用"></a>类成员函数的调用</h3><p>要想调用类的方法,首先要创建一个对象,然后对象使用<code>.</code>来调用类的成员函数.<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//student4.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类通常定义在函数外面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//类包含的变量</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line">    <span class="comment">//类包含的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;name&lt;&lt;<span class="string">"的年龄是"</span>&lt;&lt;age&lt;&lt;<span class="string">"，成绩是"</span>&lt;&lt;score&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建对象</span></span><br><span class="line">    Student stu;</span><br><span class="line">    stu.name = <span class="string">"小明"</span>;</span><br><span class="line">    stu.age = <span class="number">15</span>;</span><br><span class="line">    stu.score = <span class="number">92.5f</span>;</span><br><span class="line">    stu.say();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>stu 是一个对象，占用内存空间，可以对它的成员变量赋值，也可以读取它的成员变量。类通常定义在函数外面，当然也可以定义在函数内部，不过很少这样使用。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://c.biancheng.net/cpp/biancheng/view/185.html" target="_blank" rel="noopener">http://c.biancheng.net/cpp/biancheng/view/185.html</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>类</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之数组与指针传参</title>
    <url>/articles/c8047a06.html/</url>
    <content><![CDATA[<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>　　要使用C++函数，必须完成如下工作</p>
<ul>
<li>提供函数定义</li>
<li>提供函数原型(即函数声明)</li>
<li>调用函数</li>
</ul>
<p>库函数是已经定义和编译好的函数，同时可以使用标准库头文件提供其原型，因此只需正确地调用这种函数即可。然而，创建自己的函数时，必须自行处理这3个方面——定义、提供原型和调用。程序1示例<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// calling.cpp -- defining, prototyping, and calling a function</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simple</span><span class="params">()</span></span>;    <span class="comment">// 函数原型(声明)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"main() will call the simple() function:\n"</span>;</span><br><span class="line">    simple();     <span class="comment">// 函数调用</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"main() is finished with the simple() function.\n"</span>;</span><br><span class="line">    <span class="comment">// cin.get();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simple</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm but a simple function.\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="函数与数组"><a href="#函数与数组" class="headerlink" title="函数与数组"></a>函数与数组</h3><p>　　我们平时编写的函数都比较简单，参数基本上都是按值传递的，参数形式都是基本的int,float型的．现在来学习一种较为复杂的参数形式数组．将数组作为参数传入函数,函数需要知道要对哪个数组进行累计，因此需要将数组名作为参数传递给它。为使函数通用，而不限于特定长度的数组，还需要传递数组长度。这里唯一的新内容是，需要将一个形参声明为数组名。下面来看一看函数头及其其他部分：<br><code>int sum_arr(int arr[], int n)   //arr是数组名,n是数组大小</code></p>
<p>这看起来似乎合理。方括号指出arr是一个数组，而方括号为空则表明，可以将任何长度的数组传递给该函数。但实际情况并非如此：<strong>arr实际上并不是数组，而是一个指针！好消息是，在编写函数的其余部分时，可以将arr看作是数组</strong>。首先，通过一个示例验证这种方法可行，然后看看它为什么可行</p>
<p>程序演示如同使用数组名那样使用指针的情况。程序将数组初始化为某些值，并使用sum_arr()函数计算总数。<strong>注意到sum_arr()函数使用arr时，就像是使用数组名一样。</strong><br>程序2示例<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// arrfun1.cpp -- functions with an array argument</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ArSize = <span class="number">8</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_arr</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span>;        <span class="comment">// 原型</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">int</span> cookies[ArSize] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">16</span>,<span class="number">32</span>,<span class="number">64</span>,<span class="number">128</span>&#125;;</span><br><span class="line"><span class="comment">// some systems require preceding int with static to</span></span><br><span class="line"><span class="comment">// enable array initialization</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = sum_arr(cookies, ArSize);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Total cookies eaten: "</span> &lt;&lt; sum &lt;&lt;  <span class="string">"\n"</span>;</span><br><span class="line">    <span class="comment">// cin.get();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// return the sum of an integer array</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_arr</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        total = total + arr[i];</span><br><span class="line">    <span class="keyword">return</span> total; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>程序输出:<br>Total cookies eaten: 255</p>
<h4 id="函数如何使用指针来处理数组"><a href="#函数如何使用指针来处理数组" class="headerlink" title="函数如何使用指针来处理数组"></a>函数如何使用指针来处理数组</h4><p>　　在大多数情况下，C++和C语言一样，也将数组名视为指针。指针一文中介绍过，<strong>C++将数组名解释为其第一个元素的地址</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cookies == &amp;cookies[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><br>该规则有一些例外。首先，数组声明使用数组名来标记存储位置；其次，对数组名使用 sizeof将得到整个数组的长度（以字节为单位）；第三，正如指针那节指出的，将地址运算符&amp;用于数组名时，将返回整个数组的地址，例如&amp;cookies将返回一个32字节内存块的地址（如果int长4字节）。程序2示例中函数调用<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = sum_arr(cookies, ArSize)</span><br></pre></td></tr></table></figure><br>其中， cookies是数组名，而根据C++规则， cookies是其第一个元素的地址，因此函数传递的是地址,由于数组的元素的类型为int，因此 cookies的类型必须是int指针，即int<em>。这表明，正确的函数头应该是这样的：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_arr</span><span class="params">(<span class="keyword">int</span>* cookies, ArSize)</span></span></span><br></pre></td></tr></table></figure><br>其中用`int</em> arr<code>替换了</code>int arr[]<code>。这证明这两个函数头都是正确的，因为在C++中，当(且仅当)用于函数头或函数原型中，</code>int*ar<code>和</code>int arr[]`的含义才是相同的。它们都意味着arr是一个int指针.</p>
<p>鉴于变量ar实际上就是一个指针，函数的其余部分是合理的。同数组名或指针一样，也可以用方括号数组表示法来访问数组元素。<strong>无论rarr是指针还是数组名，表达式arr[3]都指的是数组的第4个元素</strong>。就目前而言,记住下面两个恒等式，将不会有任何坏处：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">arr[i] = *(arr+i)  <span class="comment">//数组第i个值得访问形式</span></span><br><span class="line">&amp;arr[i] = arr+i    <span class="comment">//数组第i个值地址访问形式</span></span><br></pre></td></tr></table></figure><br>记住，将指针（包括数组名）加1，实际上是加上了一个与指针指向的类型的长度（以字节为单位）相等的值。对于遍历数组而言，使用指针加法和数组下标时等效的。</p>
<h4 id="将数组作为参数意味着什么"><a href="#将数组作为参数意味着什么" class="headerlink" title="将数组作为参数意味着什么"></a>将数组作为参数意味着什么</h4><p>　　我们来看一看程序2暗示了什么。函数调用sum_arr(cookies, ArSize)将cookies数组第一个元素的地址和数组中的元素数目传递给sum_arr()函数。sum_arr()函数将cookies的地址赋给指针变量arr，将ArSize赋给int变量n。这意味着，程序2实际上并没有将数组内容传递给函数，而是将数组的位置（地址）、包含的元素种类（类型）以及元素数目（n变量）提交给函数。有了这些信息后，函数便可以使用原来的数组。<strong>传递常规变量时，函数将使用该变量的拷贝；但传递数组时，函数将使用原来的数组</strong>。</p>
<h3 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h3><p>可以用两种不同的方式将 const关键字用于指针。第一种方法是让指针指向一个常量对象，这样可以防止使用该指针来修改所指向的值，第二种方法是将指针本身声明为常量，这样可以防止改变指针指向的位置.</p>
<p>首先声明一个指向常量得指针<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">39</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * pt = &amp;age;</span><br></pre></td></tr></table></figure><br>该声明指出，pt指向一个 const int（这里为39），因此不能使用pt来修改这个值。换句话来说，*pt的值为 const，不能被修改.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*pt += <span class="number">1</span>       <span class="comment">// 无效</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; *pt     <span class="comment">// 无效</span></span><br></pre></td></tr></table></figure>
<p>现在来看一个微妙的问题。pt的声明并不意味着它指向的值实际上就是一个常量，而只是意味着对pt而言，这个值是常量。例如，pt指向age，而age不是 const。可以直接通过age变量来修改age的值，但不能使用pt指针来修改它<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*pt = <span class="number">20</span>      <span class="comment">//无效</span></span><br><span class="line">age = <span class="number">20</span>      <span class="comment">//有效</span></span><br></pre></td></tr></table></figure></p>
<p>以前我们将常规变量的地址赋给常规指针，而这里将常规变量的地址赋给指向 const的指针。因此还有两种可能：将 const变量的地址赋给指向 const的指针、将 const的地址赋给常规指针。这两种操作都可行吗？第一种可行，但第二种不可行：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> g_earth = <span class="number">9.80</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> * pe = &amp;g_earth   <span class="comment">//有效</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> g_moon = <span class="number">1.63</span></span><br><span class="line"><span class="keyword">float</span> * pm = &amp;g_moon          <span class="comment">//无效</span></span><br></pre></td></tr></table></figure><br>对于第一种情况来说，既不能使用 g earth来修改值9.80，也不能使用pe来修改。C++禁止第二种情况的原因很简单—如果将 moon的地址赋给pm，则可以使用pm来修改 moon的值，这使得 goon的 const状态很荒谬，因此C艹+禁止将 const的地址赋给非 const指针。如果非要这样做，可以使用强制类型转换来突破这种限制.</p>
<p><strong>注意：如果数据类型本身并不是指针，则可以将 const数据或非 const数据的地址赋给指向 const的指针，但只能将非 const数据的地址赋给非 const指针。</strong></p>
<p>假设有一个由 const数据组成的数组：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> months[<span class="number">12</span>]=&#123;<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;；</span><br></pre></td></tr></table></figure><br>则禁止将常量数组的地址赋给非常量指针将意味着不能将数组名作为参数传递给使用非常量形参的函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> arr[]， <span class="keyword">int</span> n)</span><span class="comment">// should have been const int arr[]</span></span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">int</span> j= sum(months, <span class="number">12</span>)；<span class="comment">// not allowed</span></span><br></pre></td></tr></table></figure><br>上述函数调用试图将 const指针(months)赋给非 const指针(arr)，编译器将禁止这种函数调用。</p>
<p>尽可能使用,const将指针参数声明为指向常量数据的指针有两条理由：</p>
<ul>
<li>这样可以避免由于无意间修改数据而导致的编程错误；</li>
<li>使用 const使得函数能够处理 const和非 const实参，否则将只能接受非 const数据。<br>如果条件允许，则应将指针形参声明为指向 const的指针。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>指针</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之类的构造函数与析构函数</title>
    <url>/articles/65a68211.html/</url>
    <content><![CDATA[<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>　　C++的目标之一就是让使用类和对象就像使用标准类型一样.然而前面所讲的内容我们还无法像初始化int,结构那样直接给成员属性进行初始化.C++类中有这样一个特殊函数,它的名字和类名相同,没有返回值,<strong>能在创建对象的时候为成员变量赋值</strong>,而不是用公有函数间接给成员变量赋值.这个函数就是构函数.</p>
<h4 id="构造函数的声明和定义"><a href="#构造函数的声明和定义" class="headerlink" title="构造函数的声明和定义"></a>构造函数的声明和定义</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">    <span class="keyword">float</span> m_score;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//声明构造函数</span></span><br><span class="line">    Student(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">float</span> score);</span><br><span class="line">    <span class="comment">//声明普通成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义构造函数</span></span><br><span class="line">Student::Student(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">float</span> score)&#123;</span><br><span class="line">    m_name = name;</span><br><span class="line">    m_age = age;</span><br><span class="line">    m_score = score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义普通成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m_name&lt;&lt;<span class="string">"的年龄是"</span>&lt;&lt;m_age&lt;&lt;<span class="string">"，成绩是"</span>&lt;&lt;m_score&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建对象时向构造函数传参</span></span><br><span class="line">    <span class="function">Student <span class="title">stu</span><span class="params">(<span class="string">"小明"</span>, <span class="number">15</span>, <span class="number">92.5f</span>)</span></span>;</span><br><span class="line">    <span class="comment">//或Student stu = Student("小明", 15, 92.5f);</span></span><br><span class="line">    stu.show();</span><br><span class="line">    <span class="comment">//创建对象时向构造函数传参</span></span><br><span class="line">    Student *pstu = <span class="keyword">new</span> Student(<span class="string">"李华"</span>, <span class="number">16</span>, <span class="number">96</span>);</span><br><span class="line">    pstu -&gt; show();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　构造函数的函数名与类名相同,且没有返回类型.在构造对象的时候,我们需直接对成员变量赋值.该例在Public中声明了Student(char *name, int age, float score)的构造函数,对Private中的三个类属性进行赋值.要想调用该构造函数，就得在创建对象的同时传递实参，并且实参由()包围，和普通的函数调用非常类似.</p>
<p>在栈上创建对象时，实参位于对象名后面，例如Student stu(“小明”, 15, 92.5f)；在堆上创建对象时，实参位于类名后面，例如new Student(“李华”, 16, 96)。</p>
<h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h4><p>默认构造函数是在程序员未重新定义构造函数时自动生成的构造函数,这个构造函数没有形参,不会对成员变量有任何操作.上例中的默认构造函数为:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类中默认构造函数声明</span></span><br><span class="line">Student();</span><br><span class="line"><span class="comment">//默认构造函数定义</span></span><br><span class="line">Student()&#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p><font color="red" size="3">一个类必须有构造函数，要么用户自己定义，要么编译器自动生成。一旦用户自己定义了构造函数，不管有几个，也不管形参如何，编译器都不再自动生成。</font>构造函数的调用是强制性的，一旦在类中定义了构造函数，那么创建对象时就一定要调用，不调用是错误的。如果有多个重载的构造函数，那么创建对象时提供的实参必须和其中的一个构造函数匹配；反过来说，创建对象时只有一个构造函数会被调用。</p>
<h4 id="构造函数的初始化参数列表"><a href="#构造函数的初始化参数列表" class="headerlink" title="构造函数的初始化参数列表"></a>构造函数的初始化参数列表</h4><p>构造函数除了可以用参数为成员变量一一赋值外,还可以用初始化的参数列表来初始化.<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">    <span class="keyword">float</span> m_score;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">float</span> score);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//采用参数初始化表</span></span><br><span class="line">Student::Student(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">float</span> score): m_name(name), m_age(age), m_score(score)&#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m_name&lt;&lt;<span class="string">"的年龄是"</span>&lt;&lt;m_age&lt;&lt;<span class="string">"，成绩是"</span>&lt;&lt;m_score&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">stu</span><span class="params">(<span class="string">"小明"</span>, <span class="number">15</span>, <span class="number">92.5f</span>)</span></span>;</span><br><span class="line">    stu.show();</span><br><span class="line">    Student *pstu = <span class="keyword">new</span> Student(<span class="string">"李华"</span>, <span class="number">16</span>, <span class="number">96</span>);</span><br><span class="line">    pstu -&gt; show();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如上面的代码所示,在构造函数后加入:,并紧跟m_name(name), m_age(age), m_score(score),后面的函数体为空,这个语句的意思相当于函数体内部的m_name = name; m_age = age; m_score = score语句，也是赋值的意思。</p>
<p>使用参数初始化表并没有效率上的优势，仅仅是书写方便，尤其是成员变量较多时，这种写法非常简明了。参数初始化表可以用于全部成员变量，也可以只用于部分成员变量。下面的示例只对 m_name 使用参数初始化表，其他成员变量还是一一赋值：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Student::Student(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">float</span> score): m_name(name)&#123;</span><br><span class="line">    m_age = age;</span><br><span class="line">    m_score = score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="初始化-const-成员变量"><a href="#初始化-const-成员变量" class="headerlink" title="初始化 const 成员变量"></a>初始化 const 成员变量</h4><p>参数初始化表还有一个很重要的作用，那就是初始化 const 成员变量。<strong>初始化 const 成员变量的唯一方法就是使用参数初始化表</strong>。例如 VS/VC 不支持变长数组（数组长度不能是变量），我们自己定义了一个 VLA 类，用于模拟变长数组，请看下面的代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VLA</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> m_len;</span><br><span class="line">    <span class="keyword">int</span> *m_arr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    VLA(<span class="keyword">int</span> len);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//必须使用参数初始化表来初始化 m_len</span></span><br><span class="line">VLA::VLA(<span class="keyword">int</span> len): m_len(len)&#123;</span><br><span class="line">    m_arr = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>VLA 类包含了两个成员变量，m_len 和 m_arr 指针，需要注意的是 m_len 加了 const 修饰，只能使用参数初始化表的方式赋值，如果写作下面的形式是错误的：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VLA</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> m_len;</span><br><span class="line">    <span class="keyword">int</span> *m_arr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    VLA(<span class="keyword">int</span> len);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">VLA::VLA(<span class="keyword">int</span> len)&#123;</span><br><span class="line">    m_len = len;</span><br><span class="line">    m_arr = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>析构函数（Destructor）也是一种特殊的成员函数，没有返回值，不需要程序员显式调用（程序员也没法显式调用），而是在销毁对象时自动执行。构造函数的名字和类名相同，而析构函数的名字是在类名前面加一个~符号</p>
<blockquote>
<p>注意：析构函数没有参数，不能被重载，因此一个类只能有一个析构函数。如果用户没有定义，编译器会自动生成一个默认的析构函数。</p>
</blockquote>
<p>我们前面定义了一个 VLA 类来模拟变长数组，它使用一个构造函数为数组分配内存，这些内存在数组被销毁后不会自动释放，所以非常有必要再添加一个析构函数，专门用来释放已经分配的内存。请看下面的完整示例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VLA</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    VLA(<span class="keyword">int</span> len);  <span class="comment">//构造函数</span></span><br><span class="line">    ~VLA();  <span class="comment">//析构函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span></span>;  <span class="comment">//从控制台输入数组元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;  <span class="comment">//显示数组元素</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> *<span class="title">at</span><span class="params">(<span class="keyword">int</span> i)</span></span>;  <span class="comment">//获取第i个元素的指针</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> m_len;  <span class="comment">//数组长度</span></span><br><span class="line">    <span class="keyword">int</span> *m_arr; <span class="comment">//数组指针</span></span><br><span class="line">    <span class="keyword">int</span> *m_p;  <span class="comment">//指向数组第i个元素的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">VLA::VLA(<span class="keyword">int</span> len): m_len(len)&#123;</span><br><span class="line">    <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123; m_arr = <span class="keyword">new</span> <span class="keyword">int</span>[len];  <span class="comment">/*分配内存*/</span> &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123; m_arr = <span class="literal">NULL</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line">VLA::~VLA()&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_arr;  <span class="comment">//释放内存</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VLA::input</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; m_p=at(i); i++)&#123; <span class="built_in">cin</span>&gt;&gt;*at(i); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VLA::show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; m_p=at(i); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == m_len - <span class="number">1</span>)&#123; <span class="built_in">cout</span>&lt;&lt;*at(i)&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="built_in">cout</span>&lt;&lt;*at(i)&lt;&lt;<span class="string">", "</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">VLA::at</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!m_arr || i&lt;<span class="number">0</span> || i&gt;=m_len)&#123; <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123; <span class="keyword">return</span> m_arr + i; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个有n个元素的数组（对象）</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Input array length: "</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    VLA *parr = <span class="keyword">new</span> VLA(n);</span><br><span class="line">    <span class="comment">//输入数组元素</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Input "</span>&lt;&lt;n&lt;&lt;<span class="string">" numbers: "</span>;</span><br><span class="line">    parr -&gt; input();</span><br><span class="line">    <span class="comment">//输出数组元素</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Elements: "</span>;</span><br><span class="line">    parr -&gt; show();</span><br><span class="line">    <span class="comment">//删除数组（对象）</span></span><br><span class="line">    <span class="keyword">delete</span> parr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>输出结果:<br>Input array length: 5<br>Input 5 numbers: 99 23 45 10 100<br>Elements: 99, 23, 45, 10, 100</p>
<p>~VLA()就是 VLA 类的析构函数，它的唯一作用就是在删除对象（第 53 行代码）后释放已经分配的内存。</p>
<p>函数名是标识符的一种，原则上标识符的命名中不允许出现~符号，在析构函数的名字中出现的~可以认为是一种特殊情况，目的是为了和构造函数的名字加以对比和区分。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://c.biancheng.net/cpp/biancheng/view/196.html" target="_blank" rel="noopener">http://c.biancheng.net/cpp/biancheng/view/196.html</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>类</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之结构</title>
    <url>/articles/6181e072.html/</url>
    <content><![CDATA[<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>假设要存储有关篮球运动员的信息，则可能需要存储他（她）的姓名、工资、身高、体重、平均得分、命中率、助攻次数等。希望有一种数据格式可以将所有这些信息存储在一个单元中。数组不能完成这项任务，因为虽然数组可以存储多个元素，但所有元素的类型必须相同。也就是说，一个数组可以存储20个int，另一个数组可以存储10个float，但同l一l个数组不能在一些元素中存储int，在另一些元素中存储float。</p>
<p>C++中的结构的可以满足要求（存储篮球运动员的信息）。结构是一种比数组更灵活的数据格式，因为同一个结构可以存储多种类型的数据，这使得能够将有关篮球运动员的信息放在一个结构中，从而将数据的表示合并到一起。如果要跟踪整个球队，则可以使用结构数组。结构也是C++ OOP堡垒（类）的基石学习有关结构的知识将使我们离C++的核心OOP更近。</p>
<p>结构是用户定义的类型，而结构声明定义了这种类型的数据属性。定义了类型后，便可以创建这种类型的变量。因此创建结构包括两步。首先，定义结构描述——它描述并标记了能够存储在结构中的各种数据类型。然后按描述创建结构变量(结构数据对象)。结构定义的示例如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inflatable</span>    //<span class="title">structure</span> <span class="title">declaration</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">float</span> volume;</span><br><span class="line">	<span class="keyword">double</span> price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键字struct表明，这些代码定义的十一结构的布局。标识符inflatables是这种数据格式的名称，因此新类型的名称为inflatable,,这样便可以像创建char,int类型的变量创建inflatable类型的变量了。接下来的大括号包含了的是结构存储的数据类型的列表，其中每个列表项都是一条声明语句。这个例子使用了一个适合用于存储字符串的char数组、一个float和一个 double。列表中的每一项都被称为结构成员，因此 inflatable结构有3个成员（参见图4.6）。总之，结构定义指出了新类型（这里是 inflatable）的特征。</p>
<p><img src="http://cdn.wangng.com/C++/C++之结构/image1.png" alt></p>
<p>定义结构后，便可以创建这种类型的变量了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">inflatable hat;   <span class="comment">//hat是inflatable类型的结构</span></span><br><span class="line">inflatable woopie_cushion;   <span class="comment">//inflatable类型</span></span><br></pre></td></tr></table></figure>
<p>如果你熟悉C语言的结构，则可能已经注意到，C++允许声明结构变量时省略关键字struct</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inflatable</span> <span class="title">goose</span>;</span>    <span class="comment">//C语言中不能省略struct关键字</span></span><br><span class="line">inflatable vincent;      <span class="comment">//C++中可省略struct关键字</span></span><br></pre></td></tr></table></figure>
<p>在C++中，结构标记的用法与基本类型名相同。这种变化强调的是，结构声明定义了一种新类型。在C++中，省略 struct不会出错。由于hat的类型为 inflatable，因此可以使用成员运算符(.)来访问各个成员。例如， hat.volume指是结构的 volume成员， hat. price指的是 price成员。同样， vincent.price是 vincent结构的 price成员。总之，通过成员名能够访问结构的成员，就像通过索引能够访问数组的元素一样。由于price成员被声明为 double类型，因此 hat. price和 vincent.price相当于是 double类型的变量，可以像使用常规 double变量那样来使用它们。总之，hat是一个结构，而 hat.price是一个doub变量顺便说一句，访问类成员函数（如 cin.getline())的方式是从访问结构成员变量(如 vincent.price)的方式衍生而来的。</p>
<ul>
<li><p>结构程序案例structur.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inflatable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">float</span> volume;</span><br><span class="line">	<span class="keyword">double</span> price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">	inflatable guest =</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">"Glorious Gloria"</span>,</span><br><span class="line">		<span class="number">1.88</span>,</span><br><span class="line">		<span class="number">29.99</span></span><br><span class="line">		</span><br><span class="line">	&#125;; <span class="comment">//guest被初始化为inflatable类型的结构,结构体成员被初始化为相应的值。</span></span><br><span class="line">	inflatabel pal = </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">"Audacious Arthur"</span>,</span><br><span class="line">		<span class="number">3.12</span>,</span><br><span class="line">		<span class="number">32.99</span></span><br><span class="line">	&#125;; </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Expand your guest list with "</span>&lt;&lt; guest.name;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt; <span class="string">" and "</span>&lt;&lt; pal.name &lt;&lt; <span class="string">"!\n"</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt; <span class="string">"You can have both for $"</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt; guest.price + pal.price &lt;&lt; <span class="string">"!\n"</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//程序输出</span></span><br><span class="line">Expand your guest <span class="built_in">list</span> with Glorious Gloria <span class="keyword">and</span> Audacious Arthur!</span><br><span class="line">You can have both <span class="keyword">for</span> $<span class="number">62.98</span>!</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>结构声明的位置很重要。对于 structur. cpp而言，有两种选择。可以将声明放在main()函数中，紧跟在开始括号的后面。另一种选择是将声明放到main())的前面，这里采用的便是这种方式，位于函数外面的声明被称为外部声明。对于这个程序来说，两种选择之间没有实际区别。但是对于那些包含两个或更多函数的程序来说，差别很大。外部声明可以被其后面的任何函数使用，而内部声明只能被该声明所属的函数使用。通常应使用外部声明，这样所有函数都可以使用这种类型的结构（参见图4.7）。</p>
<p><img src="http://cdn.wangng.com/C++/C++之结构/image2.png" alt></p>
<p>接下来，请注意初始化方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">inflatable guest =</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"Glorious Gloria"</span>,  <span class="comment">//name初始值</span></span><br><span class="line">	<span class="number">1.88</span>，              <span class="comment">//volume初始值</span></span><br><span class="line">	<span class="number">29.99</span>               <span class="comment">//price初始值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和数组一样，使用由逗号(,)分隔值列表，并将这些值用花括号括起来。</p>
<p>可将每个结构成员看作是相应类型的变量。因此， pal price是一个 double变量，而 pal.name是一个char数组。当程序使用cout显示 pal.name时，将把该成员显示为字符串。另外，由于 pal.name是一个字符数组，因此可以用下标来访问其中的各个字符。例如， pal .name[0]是字符A.不过pal[0]没有意义，因为pal是一个结构，而不是数组。</p>
<h3 id="C-11结构初始化"><a href="#C-11结构初始化" class="headerlink" title="C++11结构初始化"></a>C++11结构初始化</h3><p>与数组一样，C++11也支持将列表初始化用于结构，且等号(=)是可选的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">inflatable duck &#123;<span class="string">"Daphne"</span>,<span class="number">0.12</span>,<span class="number">9.98</span>&#125;; <span class="comment">//可以省略“=”</span></span><br></pre></td></tr></table></figure>
<p>其次，如果大括号内未包含任何东西，各个成员都将被设置为零。例如，下面的声明导致 mayor.volar和 mayor.price被设置为零，且 mayor.name的每个字节都被设置为零：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inflatable mayor &#123;&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="1-1使用-string类作为成员"><a href="#1-1使用-string类作为成员" class="headerlink" title="1.1使用 string类作为成员"></a>1.1使用 string类作为成员</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inflatable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="built_in">std</span>:: <span class="built_in">string</span> name;</span><br><span class="line">	<span class="keyword">float</span> volume;</span><br><span class="line">	<span class="keyword">double</span> price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一定要让结构定义能够访问名称空间std.为此，可以将编译指令 using移到结构定义之前：也可以像前面那样，将name的类型声明为std:：string</p>
<h4 id="1-2结构其他属性"><a href="#1-2结构其他属性" class="headerlink" title="1.2结构其他属性"></a>1.2结构其他属性</h4><p>C++使用户定义的类型与内置类型尽可能相似。例如，可以将结构作为参数传递给函数，也可以让函数返回一个结构。另外，还可以使用赋值运算符(=)将结构赋给另一个同类型的结构，这样结构中每个成员都将被设置为另一个结构中相应成员的值，即使成员是数组。这种赋值被称为成员赋值(memberwise assignment)。</p>
<ul>
<li><p>结构赋值案例 assgn_st.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inflatable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">float</span> volume;</span><br><span class="line">	<span class="keyword">double</span> price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">	inflatable bouquet =</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">"sunflowers"</span>,</span><br><span class="line">		<span class="number">0.20</span>,</span><br><span class="line">		<span class="number">12.49</span></span><br><span class="line">	&#125;;</span><br><span class="line">    inflatable choice;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"bouquet: "</span> &lt;&lt; bouquet.name &lt;&lt; <span class="string">" for $"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; bouquet.price &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    choice = bouquet;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"choice: "</span> &lt;&lt; choice.name &lt;&lt; <span class="string">" for $"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; choice.price &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//程序输出</span></span><br><span class="line">bouquet: sunflowers <span class="keyword">for</span> $<span class="number">12.49</span></span><br><span class="line">choice: sunflowrs <span class="keyword">for</span> $<span class="number">12.49</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>可以同时完成定义结构和创建结构变量的工作。为此，只需将变量名放在结束括号的后面即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">perks</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> key_number;</span><br><span class="line">	<span class="keyword">char</span> car[<span class="number">12</span>];</span><br><span class="line">&#125; mr_smith, ms_jones;   <span class="comment">//两个perks变量</span></span><br></pre></td></tr></table></figure>
<p>甚至可以以这种方式初始化创建的变量：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">perks</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> key_number;</span><br><span class="line">	<span class="keyword">char</span> car[<span class="number">12</span>];</span><br><span class="line">&#125; mr_glitz =</span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">7</span>,</span><br><span class="line">	<span class="string">"Packard"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然而，将结构定义和变量声明分开，可以使程序更易于阅读和理解。还可以声明没有名称的结构类型，方法是省略名称，同时定义一种结构类型和一个这种类型的变量：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">&#125; <span class="built_in">position</span>;</span><br></pre></td></tr></table></figure>
<p>这样将创建一个名为position的结构变量。可以使用成员运算符来访问它的成员(position.x)，但这种类型没有名称，因此以后无法创建这种类型的变量，因此不建议这样使用。</p>
<h4 id="1-3结构数组"><a href="#1-3结构数组" class="headerlink" title="1.3结构数组"></a>1.3结构数组</h4><p>inflatable结构包含一个数组（name）。也可以创建元素为结构的数组，方法和创建基本类型数组完全相同。例如，要创建一个包含100个 inflatable结构的数组，可以这样做：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">inflatable gifts[<span class="number">100</span>];   <span class="comment">//包含100个infatable结构的数组</span></span><br></pre></td></tr></table></figure>
<p>这样， gifts将是一个 inflatable数组，其中的每个元素（如 gifts[0]或gifts[99]）都是 inflatable对象，可以与成员运算符一起使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cin &gt;&gt; gifts[0].volume;</span><br><span class="line">cout &lt;&lt; gifts[99].price &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>记住， gifts本身是一个数组，而不是结构，因此像 gifts. price这样的表述是无效的。</p>
<p>要初始化结构数组，可以结合使用初始化数组的规则（用逗号分隔每个元素的值，并将这些值用花括号括起）和初始化结构的规则（用逗号分隔每个成员的值，并将这些值用花括号括起）。由于数组中的每个元素都是结构，因此可以使用结构初始化的方式来提供它的值。因此，最终结果为一个被括在花括号中、用逗号分隔的值列表，其中每个值本身又是一个被括在花括号中、用逗号分隔的值列表：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">inflatable guests[<span class="number">2</span>]</span><br><span class="line">&#123;</span><br><span class="line">	&#123;<span class="string">"Bambi"</span>,<span class="number">0.5</span>,<span class="number">21.99</span>&#125;,    <span class="comment">//guset数组中第一个结构</span></span><br><span class="line">	&#123;<span class="string">"Godzilla"</span>,<span class="number">2000</span>,<span class="number">565.99</span>&#125;  <span class="comment">//guest数组中第二个结构</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
<h4 id="1-4结构体指针"><a href="#1-4结构体指针" class="headerlink" title="1.4结构体指针"></a>1.4结构体指针</h4><p>结构体指针是指向结构体的指针,如<code>int* ps</code>表示指向int型的指针,结构体指针的定义和访问结构体成员方式如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Phone</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	<span class="keyword">int</span> price;</span><br><span class="line">&#125; iphone;</span><br><span class="line">iphone *ps;</span><br><span class="line">ps-&gt;data = <span class="number">2019</span>;</span><br><span class="line">ps-&gt;price = <span class="number">8888</span>;</span><br></pre></td></tr></table></figure><br>注意指针的访问方式和成员运算符(.)是不同的。</p>
<h3 id="结构体为参数"><a href="#结构体为参数" class="headerlink" title="结构体为参数"></a>结构体为参数</h3><p>1.传结构体<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *sex;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125; student;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changeMessage</span><span class="params">(student t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t.age += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The age is : "</span> &lt;&lt; t.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    student stu = &#123;<span class="string">"xiaobei"</span>, <span class="string">"man"</span>, <span class="number">99</span>&#125;;</span><br><span class="line">    changeMessage(stu);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The age is : "</span> &lt;&lt; stu.age);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The age is : 100</span><br><span class="line">The age is : 99</span><br></pre></td></tr></table></figure></p>
<p>2.传结构体指针<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *sex;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125; student;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changeMessage</span><span class="params">(student *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t-&gt;age += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The age is : "</span> &lt;&lt; t-&gt;age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    student stu = &#123;<span class="string">"xiaobei"</span>, <span class="string">"man"</span>, <span class="number">99</span>&#125;;</span><br><span class="line">    changeMessage(&amp;stu);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The age is : "</span> &lt;&lt; stu.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">The age is : <span class="number">100</span></span><br><span class="line">The age is : <span class="number">100</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>结构</tag>
      </tags>
  </entry>
  <entry>
    <title>abnd</title>
    <url>/articles/582cb35c.html/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Deeplearning</category>
      </categories>
      <tags>
        <tag>light model</tag>
        <tag>SqueezeNet</tag>
        <tag>Deeplearning</tag>
      </tags>
  </entry>
  <entry>
    <title>CNN中的Group&amp;&amp;Depthwise&amp;&amp;pointerwise卷积</title>
    <url>/articles/aa8d087f.html/</url>
    <content><![CDATA[<h3 id="分组卷积-Group-Convolusion"><a href="#分组卷积-Group-Convolusion" class="headerlink" title="分组卷积(Group Convolusion)"></a>分组卷积(Group Convolusion)</h3><p>提到分组卷积，我们最开始应该想到是大名鼎鼎的Alexnet.Alexnet最先用到了分组卷积，由于计算资源的有限，它将网络分成两部分，从而能够在两个GPU上并行运行。如图所示：<br><img src="http://cdn.wangng.com/deeplearning/CNN中的Group&amp;&amp;Depthwise&amp;&amp;pointerwise卷积/alexnet.png" alt></p>
<a id="more"></a>
<p>我们来具体看下,分组卷积是如何操作的。<br><img src="http://cdn.wangng.com/deeplearning/CNN中的Group&amp;&amp;Depthwise&amp;&amp;pointerwise卷积/分组卷积.png" alt></p>
<p>如上图所示，左边的是常规的卷积，右边就是分组卷积。它把输入的特征图分成了几个组,然后各个组分别进行常规的卷积，将分组卷积后得到的特征图进行concat拼接,最后得到新的特征图。</p>
<h4 id="常规卷积vs分组卷积"><a href="#常规卷积vs分组卷积" class="headerlink" title="常规卷积vs分组卷积"></a>常规卷积vs分组卷积</h4><p>从图中(线代表卷积操作)可以明显看出，分组卷积的计算量是明显低于常规卷积。这只是从图中判断而已,我们来具体分析下这个计算量到底少多少？</p>
<p>就以上面的图为例，假设输入特征图的大小是<code>H*W*N</code>,卷积核的数量大小是<code>M*k*k*N</code>,那么输出的特征图很快就能算出来就是<code>H*W*M</code>,另外假设分组大小是g组。我们来计算下两种卷积的参数量情况。</p>
<p>常规卷积的参数量是<code>M*k*k*N</code>。分组卷积我们仔细分析下，我们先计算一组的参数量,输入现在是<code>H * W * N/g</code>,输出是<code>H * W * M/s</code>,那么相应的卷积核数量大小就是<code>M/s * k * k * N/s</code>。所以分组卷积中一组的参数量就是<code>M/s * k * k * N/s</code>,一共有s组,最终的参数量为<code>M * k * k * N/s</code>,<strong>相比常规的卷积,分组卷积的参数量是它的<code>1/s</code>倍</strong>。这也是为什么人们会用分组卷积来代替常规卷积来降低模型的参数量。</p>
<h3 id="Depthwise卷积"><a href="#Depthwise卷积" class="headerlink" title="Depthwise卷积"></a>Depthwise卷积</h3><p>Depthwise卷积其实可以看做是分组卷积的极端情况。还是以上图为例，输入特征图为<code>H*W*N</code>,如果我们把分组大小s设成是输入特征图的深度(depth)N,输出特征图的大小也为<code>H*W*N</code>。那么这样的卷积方式就成为Depthwise卷积。<br><img src="http://cdn.wangng.com/deeplearning/CNN中的Group&amp;&amp;Depthwise&amp;&amp;pointerwise卷积/depthwise.png" alt></p>
<p>从图中我们可以看出,经过Depthwise卷积后,输出特征图的深度和输入特征图的深度保持一致。这种针对每个channel的卷积方式,没有有效的利用不同map对相同位置空间的信息，使得卷积后的效果大打折扣，虽然参数量进一步减少了。</p>
<p>Depthwise卷积的参数量为<code>k*k*N</code>。是常规卷积的<code>1/N</code></p>
<h3 id="Pointerwise卷积"><a href="#Pointerwise卷积" class="headerlink" title="Pointerwise卷积"></a>Pointerwise卷积</h3><p>Pointerwise卷积一般是紧跟Depthwise卷积的。Pointerwise卷积和常规卷积很相似,只不过卷积核的大小变成了<code>1*1*M</code>,M是上一层卷积的channl数。pointerwise卷积会对上一层的特征图在各个channel上进行线性加权就和,得到一个新的channel为1的特征图。<br><img src="http://cdn.wangng.com/deeplearning/CNN中的Group&amp;&amp;Depthwise&amp;&amp;pointerwise卷积/pointwise.png" alt></p>
<p>这里的pointerwise卷积就是我们所谓的<code>1*1</code>卷积。它会对上一层的特征图在channl维进行拓展。Pointerwise卷积的参数量是<code>N*1*1*M</code>,是常规卷积的<code>1/(k^2)</code></p>
<h3 id="深度可分离卷积"><a href="#深度可分离卷积" class="headerlink" title="深度可分离卷积"></a>深度可分离卷积</h3><p>说完Depthwise和pointwise卷积后,深度可分离卷积就很好理解了，深度可分离卷积就是这两种卷积的组合,它将常规卷积分成了两部分，输入特征图先经过Depthwise卷积,再经过pointerwise卷积。<br><img src="http://cdn.wangng.com/deeplearning/CNN中的Group&amp;&amp;Depthwise&amp;&amp;pointerwise卷积/seperate.png" alt></p>
<p>参数量方面我们来计算下:</p>
<script type="math/tex; mode=display">\frac{M*k*k+M*1*1*N}{M*k*k*N} = \frac{1}{N} + \frac{1}{K^2}</script><p>这和我们分别计算的结果是吻合的。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>1.<a href="https://blog.yani.io/filter-group-tutorial/" target="_blank" rel="noopener">A Tutorial on Filter Groups (Grouped Convolution)</a><br>2.<a href="https://www.cnblogs.com/shine-lee/p/10243114.html" target="_blank" rel="noopener">https://www.cnblogs.com/shine-lee/p/10243114.html</a><br>3.<a href="https://zhuanlan.zhihu.com/p/65377955" target="_blank" rel="noopener">理解分组卷积和深度可分离卷积如何降低参数量</a></p>
]]></content>
      <categories>
        <category>Deeplearning</category>
        <category>Convolution</category>
      </categories>
      <tags>
        <tag>Deeplearning</tag>
        <tag>Group Convolusion</tag>
        <tag>Depthwise Convolusion</tag>
        <tag>Pointerwise Convolusion</tag>
      </tags>
  </entry>
  <entry>
    <title>DCN可变形卷积</title>
    <url>/articles/874edf70.html/</url>
    <content><![CDATA[<p>论文：<a href="https://arxiv.org/pdf/1703.06211.pdf" target="_blank" rel="noopener">Deformable Convolutional Networks</a><br>代码：<a href="https://github.com/oeway/pytorch-deform-conv" target="_blank" rel="noopener">github</a></p>
<a id="more"></a>
<h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><p>　　由于卷积神经网络是通过卷积核这种固定的几何结构来提取特征的，比如$3\times3$、$5\times5$这种大小结构固定的卷积核，但是这种几何固定的提取特征的方式对目标物体的大小尺寸、姿态、视角、位置变化是不敏感的。通常应对这种情况的解决方式有两种：1)采用数据增强的方式来得到更大不同视角、不同几何变换后的数据集，如仿射变换；2)使用具有平移不变性的特征或算法等，如SIFT特征。事实这两种方式还是有各自缺陷的，方式1)由于数据更多了，训练变得困难了,而且对于不同数据集得采用不同得增强方式;方式2)则是人工很难设计这种有效特征或者设计的特征不具有适应性.<br>　　<br>　　还有池化层，池化层以固定的比例大小进行池化，即使是ROI pooling也是将ROI分割到固定的目标区域中去。这些特性是有影响的，例如，在同一Conv层中，所有的激活单元的感受野是一样的，但由于不同位置可能对应着不同尺度或形变的物体，因此对尺度或者感受野大小进行自适应是进行精确定位所需要的。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>　　论文针对上述两个问题分别提出了可变形卷积(Deformable Convolutional)和可变形感兴趣区域池化(deformable ROI Pooling)来提高目标不同形变的建模能力.<strong>这两种特征提取方式都是在各自原有的基础上加上可学习的偏置来实现变形卷积,变形池化.从而使得卷积核能集中于感兴趣的区域</strong>.</p>
<p><img src="/articles/874edf70.html/img1.png" alt><br>(a)是常见的3x3卷积核的采样方式，(b)是采样可变形卷积，加上偏移量之后的采样点的变化，其中(c)(d)是可变形卷积的特殊形式</p>
<h3 id="Deformable-Convolutional"><a href="#Deformable-Convolutional" class="headerlink" title="Deformable Convolutional"></a>Deformable Convolutional</h3><p>　　CNN中的特征映射和卷积是3D的。可变形卷积和RoI池化模块都在2D空间域上运行。在整个通道维度上的操作保持不变。常规的2D卷积包含两个步骤:1)使用一个规则的栅格$\mathcal{R}$对输入特征进行采样;2)对采样的值用权重w线性求和.栅格$\mathcal{R}$定义的是感受野大小和空洞率,如下表示的是感受野大小是$3\times3$,空洞率是1的栅格$\mathcal{R}$.</p>
<script type="math/tex; mode=display">
\mathcal{R}=\{(-1,-1),(-1,0), \ldots,(0,1),(1,1)\}</script><p>对于输出特征$\mathbf{y}$中每个位置$\mathbf{p}_{0}$,我们有</p>
<script type="math/tex; mode=display">
\mathbf{y}\left(\mathbf{p}_{0}\right)=\sum_{\mathbf{p}_{n} \in \mathcal{R}} \mathbf{w}\left(\mathbf{p}_{n}\right) \cdot \mathbf{x}\left(\mathbf{p}_{0}+\mathbf{p}_{n}\right)\tag{1}</script><p>这里$\mathbf{p}_{n}$是$\mathcal{R}$中所有位置.(这里我的理解是p表示postion,以$p_0$为基准,$p_n$相对于$p_0$的位置是$p_0+p_n$)</p>
<p>　　而在可变形卷积中，栅格$\mathcal{R}$还增加了不同位置的偏置$\left{\Delta \mathbf{p}_{n} | n=1, \ldots, N\right}$,所以(1)式变成了</p>
<script type="math/tex; mode=display">
\mathbf{y}\left(\mathbf{p}_{0}\right)=\sum_{\mathbf{p}_{n} \in \mathcal{R}} \mathbf{w}\left(\mathbf{p}_{n}\right) \cdot \mathbf{x}\left(\mathbf{p}_{0}+\mathbf{p}_{n}+\Delta \mathbf{p}_{n}\right)\tag{2}</script><p>也就是说<strong>可变形卷积在原本卷积的基础上加了一个偏移量</strong>，需要注意的是，这个偏移量是位置的偏移量.通俗一点讲，某个点位于原图的（0,0）位置，有了偏移量之后，可能位于（1.1,2.3）的位置。通常$\Delta \mathbf{p}_{n}$是小数,所以(2)式的实现是通过非线性插值来实现的</p>
<script type="math/tex; mode=display">
\mathbf{x}(\mathbf{p})=\sum_{\mathbf{q}} G(\mathbf{q}, \mathbf{p}) \cdot \mathbf{x}(\mathbf{q})\tag{3}</script><p>其中$\mathbf{p}=\mathbf{p}<em>{0}+\mathbf{p}</em>{n}+\Delta \mathbf{p}_{n}$,而$\mathbf{q}$是特征图$\mathbf{x}$中所有空间位置点的集合,$G(\cdot, \cdot)$是<strong>非线性插值核</strong>并且$G$是二维的,它能分解成两个一维的核.</p>
<script type="math/tex; mode=display">
G(\mathbf{q}, \mathbf{p})=g\left(q_{x}, p_{x}\right) \cdot g\left(q_{y}, p_{y}\right)\tag{4}</script><p>并且有$g(a, b)=\max (0,1-|a-b|)$</p>
<p><img src="/articles/874edf70.html/fig2.png" alt></p>
<p>上图演示了一个$3\times3$变形卷积的过程.输入特征图是$H\times W\times N$,经过一个普通卷积,填充为same,得到$H\times W\times 2N$的offset field,由于偏移量有x,y两个方向,所有通道数为2N.offset field里的偏移量是卷积得到的，可能是浮点数，所以需要通过双向性插值计算偏移位置的特征值。在偏移量的学习中，梯度是通过双线性插值来进行反向传播的。</p>
<p>具体的:<br>1、原始图片batch（大小为$b\times h\times w\times c$），记为U，经过一个普通卷积，卷积填充为same，即输出输入大小不变，对应的输出结果为($b\times h\times w\times 2c$)，记为V，输出的结果是指原图片batch中每个像素的偏移量（x偏移与y偏移，因此为2c）。<br>2、将U中图片的像素索引值(位置$\mathbf{p}<em>{0}+\mathbf{p}</em>{n}$)与V(偏移量$\Delta \mathbf{p}<em>{n}$)相加，得到偏移后的position(即在原始图片U中的坐标值$\mathbf{p}</em>{0}+\mathbf{p}<em>{n}+\Delta \mathbf{p}</em>{n}$)，需要将position值限定为图片大小以内。position的大小为($b\times h\times w\times 2c$)，但position只是一个坐标值，而且还是float类型的，我们需要这些float类型的坐标值获取像素。<br>3、例如position中一个坐标值(a,b)，将其转换为四个整数，floor(a), ceil(a), floor(b), ceil(b)，将这四个整数进行整合，得到四对坐标（floor(a),floor(b)),  ((floor(a),ceil(b)),  ((ceil(a),floor(b)),  ((ceil(a),ceil(b))。这四对坐标每个坐标都对应U中的一个像素值，而我们需要得到(a,b)的像素值，这里采用双线性差值的方式计算（一方面得到的像素准确，另一方面可以进行反向传播）。<br>4、在得到position的所有像素后，即得到了一个新图片M，将这个新图片M作为输入数据输入到别的层中，如普通卷积。</p>
<p>代码如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConvOffset2D</span><span class="params">(nn.Conv2d)</span>:</span></span><br><span class="line">    <span class="string">"""ConvOffset2D</span></span><br><span class="line"><span class="string">    Convolutional layer responsible for learning the 2D offsets and output the</span></span><br><span class="line"><span class="string">    deformed feature map using bilinear interpolation</span></span><br><span class="line"><span class="string">    Note that this layer does not perform convolution on the deformed feature</span></span><br><span class="line"><span class="string">    map. See get_deform_cnn in cnn.py for usage</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, filters, init_normal_stddev=<span class="number">0.01</span>, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""Init</span></span><br><span class="line"><span class="string">        Parameters</span></span><br><span class="line"><span class="string">        ----------</span></span><br><span class="line"><span class="string">        filters : int</span></span><br><span class="line"><span class="string">            Number of channel of the input feature map</span></span><br><span class="line"><span class="string">        init_normal_stddev : float</span></span><br><span class="line"><span class="string">            Normal kernel initialization</span></span><br><span class="line"><span class="string">        **kwargs:</span></span><br><span class="line"><span class="string">            Pass to superclass. See Con2d layer in pytorch</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.filters = filters</span><br><span class="line">        self._grid_param = <span class="literal">None</span></span><br><span class="line">        super(ConvOffset2D, self).__init__(self.filters, self.filters * <span class="number">2</span>, <span class="number">3</span>, padding=<span class="number">1</span>, bias=<span class="literal">False</span>, **kwargs)</span><br><span class="line">        self.weight.data.copy_(self._init_weights(self.weight, init_normal_stddev))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""Return the deformed featured map"""</span></span><br><span class="line">        x_shape = x.size()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># (b, 2c, h, w)</span></span><br><span class="line">        offsets = super(ConvOffset2D, self).forward(x)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># (b*c, h, w, 2)表示共有b*c个图片，每个图片为h*w大小，每个像素对应2个方向</span></span><br><span class="line">        offsets = self._to_bc_h_w_2(offsets, x_shape)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># (b*c, h, w)</span></span><br><span class="line">        x = self._to_bc_h_w(x, x_shape)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># X_offset: (b*c, h*w)    grid:(b*c, h*w, 2)</span></span><br><span class="line">        x_offset = th_batch_map_offsets(x, offsets, grid=self._get_grid(self, x))</span><br><span class="line">        <span class="comment"># x_offset: (b, c, h, w)</span></span><br><span class="line">        x_offset = self._to_b_c_h_w(x_offset, x_shape)</span><br><span class="line">        <span class="keyword">return</span> x_offset</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get_grid</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        batch_size, input_size = x.size(<span class="number">0</span>), (x.size(<span class="number">1</span>), x.size(<span class="number">2</span>))</span><br><span class="line">        dtype, cuda = x.data.type(), x.data.is_cuda</span><br><span class="line">        <span class="keyword">if</span> self._grid_param == (batch_size, input_size, dtype, cuda):</span><br><span class="line">            <span class="keyword">return</span> self._grid</span><br><span class="line">        self._grid_param = (batch_size, input_size, dtype, cuda)</span><br><span class="line">        self._grid = th_generate_grid(batch_size, input_size, dtype, cuda)</span><br><span class="line">        <span class="keyword">return</span> self._grid</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_init_weights</span><span class="params">(weights, std)</span>:</span></span><br><span class="line">        fan_out = weights.size(<span class="number">0</span>)</span><br><span class="line">        fan_in = weights.size(<span class="number">1</span>) * weights.size(<span class="number">2</span>) * weights.size(<span class="number">3</span>)</span><br><span class="line">        w = np.random.normal(<span class="number">0.0</span>, std, (fan_out, fan_in))</span><br><span class="line">        <span class="keyword">return</span> torch.from_numpy(w.reshape(weights.size()))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_to_bc_h_w_2</span><span class="params">(x, x_shape)</span>:</span></span><br><span class="line">        <span class="string">"""(b, 2c, h, w) -&gt; (b*c, h, w, 2)"""</span></span><br><span class="line">        x = x.contiguous().view(<span class="number">-1</span>, int(x_shape[<span class="number">2</span>]), int(x_shape[<span class="number">3</span>]), <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_to_bc_h_w</span><span class="params">(x, x_shape)</span>:</span></span><br><span class="line">        <span class="string">"""(b, c, h, w) -&gt; (b*c, h, w)"""</span></span><br><span class="line">        x = x.contiguous().view(<span class="number">-1</span>, int(x_shape[<span class="number">2</span>]), int(x_shape[<span class="number">3</span>]))</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_to_b_c_h_w</span><span class="params">(x, x_shape)</span>:</span></span><br><span class="line">        <span class="string">"""(b*c, h, w) -&gt; (b, c, h, w)"""</span></span><br><span class="line">        x = x.contiguous().view(<span class="number">-1</span>, int(x_shape[<span class="number">1</span>]), int(x_shape[<span class="number">2</span>]), int(x_shape[<span class="number">3</span>]))</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure></p>
<h3 id="可变形卷积特征提取"><a href="#可变形卷积特征提取" class="headerlink" title="可变形卷积特征提取"></a>可变形卷积特征提取</h3><p><img src="/articles/874edf70.html/fig5.png" alt><br>通过对比可以明显的看出，可变形卷积的采样位置更符合物体本身的形状和尺寸，而标准卷积的形式却不能做到这一点。</p>
<h3 id="Deformable-ROI-Pooling"><a href="#Deformable-ROI-Pooling" class="headerlink" title="Deformable ROI Pooling"></a>Deformable ROI Pooling</h3><p>　　ROI pooling被用在目标检测中的region proposal中,它能将任意大小的矩形框转换成固定大小的输出特征.假设输入特征图是$\mathbf{x}$,$\mathbf{p_{0}}$是左上角位置并且ROI的大小是$w\times h$,ROI pooling会将ROI分成$k\times k$个小矩形框最后输出$k\times k$的特征图$\mathbf{y}$.对于第(i,j)个小矩形框($0\le i,j \le k$),我们有</p>
<script type="math/tex; mode=display">
\mathbf{y}(i, j)=\sum_{\mathbf{p} \in \operatorname{bin}(i, j)} \mathbf{x}\left(\mathbf{p}_{0}+\mathbf{p}\right) / n_{i j}\tag{5}</script><p>$n<em>{i j}$为第$i,j$个小矩形块中包含的像素的个数,第$i,j$个小矩形块$bin</em>{i,j}$的范围是$\left\lfloor i \frac{w}{k}\right\rfloor \leq p<em>{x}&lt;\left\lceil(i+1) \frac{w}{k}\right\rceil$和$\left\lfloor j \frac{h}{k}\right\rfloor \leq p</em>{y}&lt;\left\lceil(j+1) \frac{h}{k}\right\rceil$.<br>而对于Deformable ROI Pooling,会在每个小矩形块$bin<em>{i,j}$加上一个偏置$\left{\Delta \mathbf{p}</em>{i j} | 0 \leq i, j&lt;k\right}$,</p>
<script type="math/tex; mode=display">
\mathbf{y}(i, j)=\sum_{\mathbf{p} \in \text {bin}(i, j)} \mathbf{x}\left(\mathbf{p}_{0}+\mathbf{p}+\Delta \mathbf{p}_{i j}\right) / n_{i j}\tag{6}</script><p>通常$\Delta \mathbf{p}_{i j}$是小数,所以上式需要非线性插值公式(3)(4)来实现.</p>
<p><img src="/articles/874edf70.html/fig3.png" alt><br>　　具体操作为,首先,通过普通的ROI Pooling得到一个feature map,通过得到的这个feature map,加上一个全连接层,生成每一个位置的offset，然后按照上面的公式得到$\Delta \mathbf{p}_{i j}$,为了让offset的数据和ROI 的尺寸匹配，需要对offset进行微调。全连接层的参数可以通过反向传播进行学习。</p>
<p>　　原始的RoIPooling在操作过程中是将RoI划分为k×k个子区域。而Deformable RoIPooling的偏移量其实就是子区域的偏移，也就是说k×k个子区域不在紧挨在一起，而是每一个都有一个偏移，偏移量有k×k个。与可变形卷积不同的是，Deformable RoIPooling的偏移量是通过全连接层得到的。</p>
<h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p><img src="/articles/874edf70.html/fig6.png" alt><br><img src="/articles/874edf70.html/res.png" alt></p>
]]></content>
      <categories>
        <category>Deeplearning</category>
        <category>Object Detection</category>
      </categories>
      <tags>
        <tag>Object Detection</tag>
        <tag>DCN</tag>
      </tags>
  </entry>
  <entry>
    <title>“华为云杯”2019人工智能创新应用大赛</title>
    <url>/articles/13a21032.html/</url>
    <content><![CDATA[<h2 id="“华为云杯”2019人工智能创新应用大赛"><a href="#“华为云杯”2019人工智能创新应用大赛" class="headerlink" title="“华为云杯”2019人工智能创新应用大赛"></a>“华为云杯”2019人工智能创新应用大赛</h2><p>链接:<a href="https://competition.huaweicloud.com/information/1000021526/introduction" target="_blank" rel="noopener">官网</a></p>
<p>比赛介绍：“华为云杯”2019人工智能创新应用大赛，由西安国家民用航天产业基地管理委员会主办、华为公司承办，以“AI在航天，鸿图华构”为主题，是面向全国的人工智能交流赛事。大赛目标是服务以及培养AI人才，构建“用得起、用的好、用得放心”的普惠AI生态，为AI开发者提供一个交流学习、创新挑战的平台。参赛者基于华为云人工智能开发平台ModelArts，根据组委会提供的西安景点、美食、民俗、特产、工艺品等图像数据，进行图像分类模型的开发。</p>
<a id="more"></a>
<p>比赛结果 线上测试97.7 (top 5%),共1775人参加</p>
<h3 id="数据介绍"><a href="#数据介绍" class="headerlink" title="数据介绍"></a>数据介绍</h3><p>数据总共3731张，其中线上测试数据为1000张<br><img src="http://cdn.wangng.com/Competition/“华为云杯”2019人工智能创新应用大赛/image.png" alt><br>从数据分布上来看，可以看出每一类的数据都特别少，最多的一类有115张，最少的一类只有19张，而且每类的数据量都不是很均衡，对于模型来说，很容易造成过拟合现象。因而在泛化性能无法得到有效提升的情况下，考虑使用数据扩充的方法，从百度爬取了一万多张图片，使用伪标签法（Pseudo label)来扩充图片，使用训练好的模型来预测，阈值选择为97，将预测结果大于97的数据加入到训练数据中（该方法相当于是半监督的方法）</p>
<h3 id="模型选择及线上得分节点"><a href="#模型选择及线上得分节点" class="headerlink" title="模型选择及线上得分节点"></a>模型选择及线上得分节点</h3><p>densenet201<br>efficientnet_b2<br>efficientnet_b3<br>efficientnet_b4<br>…<br>densenet201 95.0 densenet201 95.4<br>efficientnet_b2 96.6 efficientnet_b2 97.6 efficinetnet_b2 97.7<br>efficientnet_b3 95.6 efficientnet_b3 96.0 efficientnet_b3 97.0<br>efficientnet_b4 97.5  </p>
<h3 id="训练技巧"><a href="#训练技巧" class="headerlink" title="训练技巧"></a>训练技巧</h3><p>数据增强部分：<br>1.随机裁剪 randomresizedcrop<br>2.随机擦除 random erase<br>3.mixup<br>4.水平翻转<br>5.归一化<br>训练策略：<br>学习率使用warmup+CosineAnnealingLR<br>采用多尺度训练，分为三段式，图像大小依次递增<br>优化器： sgd<br>损失函数：<br>SmoothCrossEntropyloss+mixup_loss </p>
<p>涨分点：加大图片分辨率，标签平滑(能抑制过拟合)，mixup(在模型上进行正则)，随机擦除，多尺度训练(增加的模型的泛化能力)，数据清洗（数据是最重要的，一个好的数据集意味着你的起点比别人高很多）  </p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>1.EfficientNet: Rethinking Model Scaling for Convolutional Neural Networks<br>2.mixup: Beyond Empirical Risk Minimization<br>3.CutMix: Regularization Strategy to Train Strong Classifiers with Localizable Features<br>4.Bag of Tricks for Image Classification with Convolutional Neural Networks<br>5.<a href="https://juejin.im/post/5be5b0d7e51d4543b365da51" target="_blank" rel="noopener">https://juejin.im/post/5be5b0d7e51d4543b365da51</a><br>6.<a href="https://www.zhihu.com/question/59201590" target="_blank" rel="noopener">https://www.zhihu.com/question/59201590</a></p>
<h3 id="代码地址：github"><a href="#代码地址：github" class="headerlink" title="代码地址：github"></a>代码地址：<a href="https://github.com/jackcywang/Xian-Huawei-Al-competion" target="_blank" rel="noopener">github</a></h3>]]></content>
      <categories>
        <category>Deeplearning</category>
        <category>Competition</category>
      </categories>
      <tags>
        <tag>华为云杯</tag>
      </tags>
  </entry>
  <entry>
    <title>分类网络之ResNext解读</title>
    <url>/articles/34f2d837.html/</url>
    <content><![CDATA[<p>论文:<a href="https://arxiv.org/abs/1611.05431" target="_blank" rel="noopener">Aggregated Residual Transformations for Deep Neural Networks</a><br>代码:<a href="https://github.com/miraclewkf/ResNeXt-PyTorch" target="_blank" rel="noopener">https://github.com/miraclewkf/ResNeXt-PyTorch</a></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>　　ResNext是ResNet的升级版本,相比ResNet来说,<strong>ResNext借鉴了InceptionNet中的split-transform-merge策略,也即多支路</strong>,使网络结构变得更”宽了”,ResNext依然沿用了VGG/ResNet堆叠block的形式,只是在每个block中进行改进,增加block中的分支数.作者通过实验也指出,增加网络支路能有效增加网络性能,ResNext在<em>ILVSRC2016</em>赛道中取得了第二名的成绩.</p>
<a id="more"></a>
<h3 id="网络结构分析"><a href="#网络结构分析" class="headerlink" title="网络结构分析"></a>网络结构分析</h3><p>作者使用VGG/ResNet那种堆叠block主要是这种形式有两种简单的规则:</p>
<ol>
<li>产生同样大小的特征图时,每个block都共享相同的参数:卷积核大小和模型宽度(卷积核大小)</li>
<li>每次特征图降采样2倍时,模型宽度(卷积核大小)就扩大两倍.<br>这两种简单规则的定义可以使得减少对模型超参数的重新设计,这样我们就只需要设计一个模板block,然后使用block进行堆叠即可.这极大地减少了模型的搜索空间,使得我们只用关注几个关键的模型参数.</li>
</ol>
<h4 id="ResNext的block"><a href="#ResNext的block" class="headerlink" title="ResNext的block"></a>ResNext的block</h4><p><img src="/articles/34f2d837.html/resnext1.png" alt><br>上图就是ResNext和ResNet中的block对比,作者将网络支路数称为cardinality(原文的解释为<em>the size of the set of transformations</em>),将输入split成32条支路,然后将32条支路的结果相加输出,channels数量未变.</p>
<h4 id="ResNext-block的恒等变形"><a href="#ResNext-block的恒等变形" class="headerlink" title="ResNext block的恒等变形"></a>ResNext block的恒等变形</h4><p><img src="/articles/34f2d837.html/resnext2.png" alt><br>作者指出这三个结构是等价的,且结果是一样的.作者用代码实现ResNext结构的的是fig3(c),也就是用分组卷积来扩充支路.我在前面的<a href="https://www.wangng.com/articles/aa8d087f.html/" target="_blank" rel="noopener">分组卷积</a>也讲过,分组卷积能有效的减少模型参数.</p>
<h4 id="block的实现代码"><a href="#block的实现代码" class="headerlink" title="block的实现代码"></a>block的实现代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bottleneck</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    expansion = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, inplanes, planes, stride=<span class="number">1</span>, downsample=None, num_group=<span class="number">32</span>)</span>:</span></span><br><span class="line">        super(Bottleneck, self).__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(inplanes, planes*<span class="number">2</span>, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">        self.bn1 = nn.BatchNorm2d(planes*<span class="number">2</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(planes*<span class="number">2</span>, planes*<span class="number">2</span>, kernel_size=<span class="number">3</span>, stride=stride,</span><br><span class="line">                               padding=<span class="number">1</span>, bias=<span class="literal">False</span>, groups=num_group) <span class="comment"># 使用了大小为32的组卷积</span></span><br><span class="line">        self.bn2 = nn.BatchNorm2d(planes*<span class="number">2</span>)</span><br><span class="line">        self.conv3 = nn.Conv2d(planes*<span class="number">2</span>, planes * <span class="number">4</span>, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">        self.bn3 = nn.BatchNorm2d(planes * <span class="number">4</span>)</span><br><span class="line">        self.relu = nn.ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">        self.downsample = downsample</span><br><span class="line">        self.stride = stride</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        residual = x</span><br><span class="line"></span><br><span class="line">        out = self.conv1(x)</span><br><span class="line">        out = self.bn1(out)</span><br><span class="line">        out = self.relu(out)</span><br><span class="line"></span><br><span class="line">        out = self.conv2(out)</span><br><span class="line">        out = self.bn2(out)</span><br><span class="line">        out = self.relu(out)</span><br><span class="line"></span><br><span class="line">        out = self.conv3(out)</span><br><span class="line">        out = self.bn3(out)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.downsample <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            residual = self.downsample(x)</span><br><span class="line"></span><br><span class="line">        out += residual</span><br><span class="line">        out = self.relu(out)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure>
<h4 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h4><p><img src="/articles/34f2d837.html/resnext50.png" alt><br>上图是ResNext50和ResNet50中的结构对比,和ResNet50一样,包含了4个stage,每个stage由若干个相同的block堆叠成.这里每个block都用分组卷积分成32个组,每个卷积核大小都是1x1和3x3.基本上ResNext50和ResNet50的参数量和浮点运算量差不多.</p>
<p>这里作者介绍了cardinality和每条支路宽度的关系,cardinality的大小C和条支路宽度d的乘积就是分组卷积总的宽度(通道数)<br><img src="/articles/34f2d837.html/resnext3.png" alt></p>
<h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p><strong>１.ResNext与ResNet结果对比</strong></p>
<p>fig5是ResNext-50(32x4d)与ResNet-50(1x64d),ResNext-101(32x4d)与ResNet-101(1x64d)在ImageNet-1K数据集上的训练验证结果.<br><img src="/articles/34f2d837.html/result1.png" alt></p>
<p><strong>２.深度宽度与增大cardinality对此</strong><br>作者指出增加cardinality的显示出的效果要明显优于增加网络的深度或宽度.<br><img src="/articles/34f2d837.html/result2.png" alt></p>
<p><strong>３.有无shortcut连接对比</strong><br><img src="/articles/34f2d837.html/result3.png" alt></p>
<p><strong>４.与其他网络结构对比</strong><br><img src="/articles/34f2d837.html/result4.png" alt></p>
]]></content>
      <categories>
        <category>Deeplearning</category>
        <category>Classification</category>
      </categories>
      <tags>
        <tag>Deeplearning</tag>
        <tag>ResNext</tag>
      </tags>
  </entry>
  <entry>
    <title>分类网络之EfficientNet解读</title>
    <url>/articles/d1d853bc.html/</url>
    <content><![CDATA[<p>论文:<a href="https://arxiv.org/pdf/1905.11946.pdf" target="_blank" rel="noopener">EfficientNet: Rethinking Model Scaling for Convolutional Neural Networks</a><br>代码:<a href="https://github.com/tensorflow/tpu/tree/master/models/official/efficientnet" target="_blank" rel="noopener">github</a></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>　　增大卷积神经网络规模被广泛用来提高识别精度，一般而言，会从三个方面来增大网络模型，分别是网络深度(ResNet)、网络宽度(WideResNet)和图片的分辨率.此前的工作一般都是在其中的一两个方面来增大网络规模,EfficientNet则是从这三个方面来综合考虑增大网络模型。EfficientNet使用了NAS技术以一个固定的系数来统一搜索这三个维度的大小。<br><img src="/articles/d1d853bc.html/fig2.png" alt></p>
<a id="more"></a>
<p>事实上,从这三个方面来增大网络模型是可以解释的,输入较大的图像,我们需要更深的网络来增加感受野的大小,需要更宽的网络来提取更多细粒度的模式信息。</p>
<h3 id="网络结构分析"><a href="#网络结构分析" class="headerlink" title="网络结构分析"></a>网络结构分析</h3><p><strong>1.增大网络深度</strong><br>　　增大网络深度是是卷积神经网络的通用做法,因为更深的网络意味着可以获取更丰富更复杂的特征,并且还能很好的迁移到其他任务,然而更深的网络会使得训练变得困难,同时还有梯度消失的风险,虽然skip connections和batchnorm能减缓这个问题,但无法避免。非常深的网络精度还是会降低,如ResNet-1000和ResNet-101的精度相差不多,所以不能盲目增加网络深度。</p>
<p><strong>2.增大网络宽度</strong><br>　　增大网络宽度通常用在以下小模型中,更宽的模型(更多的通道数)往往能获得更多细粒度的特征,并且更容易训练。然而非常宽但是比较浅的网络却很难获得更高层的特征,所以不能盲目增加宽度。</p>
<p><strong>3.增大输入分辨率</strong><br>　　更大的输入图像,意味着卷积神经网络能潜在的获得更多细粒度信息,但是更大输入图像,意味着更大的计算开销,同时更大分辨率也会带来精度的降低,所以不能盲目增加图片的分辨率。</p>
<p><strong>4.复合增大网络模型</strong><br>　　实际上,卷积神经网络会由多个stage组成,stage中所有层共享相同的结构,如ResNet网络,包含5个stage,每个stage包含若干个相同的block。因此我们可以定义网络结构为:</p>
<script type="math/tex; mode=display">
\mathcal{N}=\bigodot_{i=1 \ldots s} \mathcal{F}_{i}^{L_{i}}\left(X_{\left\langle H_{i}, W_{i}, C_{i}\right\rangle}\right)\tag{1}</script><p>其中$\mathcal{F}<em>{i}^{L</em>{i}}$表示第$i$个stage中的第$\mathcal{F}<em>{i}$层的block重复$L</em>{i}$次.$X<em>{\left\langle H</em>{i}, W<em>{i}, C</em>{i}\right\rangle}$表示第$i$的特征.传统的模型架构更多关注如何找到最优的结构$\mathcal{F}<em>{i}$,EfficientNet则是在固定$\mathcal{F}</em>{i}$的情况下,平衡$L<em>{i}$,$C</em>{i}$和$(H<em>{i},W</em>{i})$这三者的关系,找到这三者的最优值从而使得整个模型最优。因此模型的优化目标变成了:</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\max _{d, w, r} \quad \text { Accuracy }(\mathcal{N}(d, w, r))\\
&\text {s.t.} \quad \mathcal{N}(d, w, r)=\bigodot_{i=1 . . . s} \hat{\mathcal{F}}_{i}^{d \cdot \hat{L}_{i}}\left(X_{\left\langle r \cdot \hat{H}_{i}, r \cdot \hat{W}_{i}, w \cdot \hat{C}_{i}\right\rangle}\right)\\
&\begin{array}{l}
\text { Memory }(\mathcal{N}) \leq \text { targetmemory} \\
\text { FLOPS }(\mathcal{N}) \leq \text { targetflops }
\end{array}
\end{aligned}\tag{2}</script><p>其中$d,w,r$代表了网络深度,宽度和分辨率增大系数.$\mathcal{F<em>{i}},L</em>{i},C<em>{i},(H</em>{i},W_{i})$的所定义的baseline网络如下表所示:<br><img src="/articles/d1d853bc.html/table1.png" alt><br>　　这里的baseline网络EfficientNet-B0作者借鉴了MnasNet的思路,也是由网络架构搜索技术搜索得到的.这里的MBConv实际上就是MobileNetV3的中的Mobile Inverted Residual Bottleneck Block.随后作者分别比较了三个参数变化对模型精度的影响.<br><img src="/articles/d1d853bc.html/fig3.png" alt></p>
<h3 id="超参数搜索"><a href="#超参数搜索" class="headerlink" title="超参数搜索"></a>超参数搜索</h3><p>上面定义的$d,w,r$是一个很大的搜索空间,作者为了减少搜索空间,定义了一个复合放大因子$\phi$来平衡$d,w,r$的大小并减小搜索空间.</p>
<script type="math/tex; mode=display">
depth: d=\alpha^{\phi},
width: w=\beta^{\phi},
resolution: r=\gamma^{\phi},
s.t. \alpha \cdot \beta^{2} \cdot \gamma^{2} \approx 2,
\alpha \geq 1, \beta \geq 1, \gamma \geq 1\tag{3}</script><p>这样做的原因是因为计算量(FLOPs)是和$d\times w^{2}\times r^{2}$成正比的.论文了将$\phi$设为2是假设有两倍计算资源可以使用.<br>搜索步骤如下:</p>
<ol>
<li>固定$\phi=1$,根据公式2,3在一个小的范围内搜索$\alpha,\beta,\gamma$,在$\alpha \cdot \beta^{2} \cdot \gamma^{2} \approx 2$的限制下,最终对于B0来说这三个参数的最优值为$\alpha=1.2,\beta=1.1,\gamma=1.5$,</li>
<li>固定$\alpha,\beta,\gamma$,然后使用公式3来改变$\phi$,最终得到B1~B7.</li>
</ol>
<h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p><strong>1.不同增大模型方法对比</strong><br><img src="/articles/d1d853bc.html/fig7.png" alt><br><img src="/articles/d1d853bc.html/fig8.png" alt></p>
<p><strong>2.不同模型对比结果</strong><br><img src="/articles/d1d853bc.html/fig1.png" alt><br><img src="/articles/d1d853bc.html/table2.png" alt></p>
]]></content>
      <categories>
        <category>Deeplearning</category>
        <category>Classification</category>
      </categories>
      <tags>
        <tag>Deeplearning</tag>
        <tag>EfficientNet</tag>
      </tags>
  </entry>
  <entry>
    <title>基于vgg16的迁移学习,训练自己的数据集(含预测结果)</title>
    <url>/articles/64ee13ab.html/</url>
    <content><![CDATA[<h2 id="1-vggNet简介"><a href="#1-vggNet简介" class="headerlink" title="1.vggNet简介"></a>1.vggNet简介</h2><p>vgg16是2014年由牛津大学提出的一个深度神经网络模型，该模型在2014年的ILSVRC分类比赛中，取得了第二名的成绩，而第一名当属大名鼎鼎的googleNet,vggNet包含5种网络类型，如下图所示：</p>
<a id="more"></a>
<p><img src="http://cdn.wangng.com/Deeplearning/基于vgg16的迁移学习-训练自己的数据集-含预测结果/vgg16.png" alt="vgg16"><br>常见的有vgg16和vgg19。顾名思义vgg16有16层，包含13层卷积池化层和3层全连接层。而vgg19包含16层卷积池化层和3层全连接层。vggNet全部使用1x1,3x3的卷积核，而且vggNet证明了两个3x3的卷积核可以等效为一个5x5的卷积核，下图示<br><img src="http://cdn.wangng.com/Deeplearning/基于vgg16的迁移学习-训练自己的数据集-含预测结果/5x5.png" alt="5x5"><br>一张5x5的图经两个3x3的卷积核卷积后得到一张1x1的特征图，等效为一个5x5的卷积核。同时在参数量上可以发现，5x5的卷积核的参数量是5x5=25，两个3x3的卷积核是2x3x3=18,参数量是减少了的28%，同时由于与一个5x5的卷积核卷积只需一次非线性激活，而与两个卷积核卷积可以进行两次非线性激活变换，非线性表征加强了，增加了CNN对特征的学习能力。另外1x1卷积核能实现降维，增加非线性。</p>
<h2 id="2-vgg16实现迁移学习"><a href="#2-vgg16实现迁移学习" class="headerlink" title="2.vgg16实现迁移学习"></a>2.vgg16实现迁移学习</h2><p>1.数据集准备，我使用8类数据，分别是truck,tiger,flower,kittycat,guitar,houses,plane,person,数据每类训练集500张，验证集300张</p>
<p>2.vgg16预训练权重下载，我把它放在我的<a href="https://pan.baidu.com/s/1zasR4Vgw2awn2O1V2X9g-A" target="_blank" rel="noopener">百度网盘</a>里了，密码fwi4</p>
<p>3.生成train.txt,val.txt,label.txt<br><em>create_labels_files.py</em><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*-coding:utf-8-*-</span><br><span class="line"> </span><br><span class="line">import os</span><br><span class="line">import os.path</span><br><span class="line"> </span><br><span class="line">def write_txt(content, filename, mode&#x3D;&#39;w&#39;):</span><br><span class="line">    &quot;&quot;&quot;保存txt数据</span><br><span class="line">    :param content:需要保存的数据,type-&gt;list</span><br><span class="line">    :param filename:文件名</span><br><span class="line">    :param mode:读写模式:&#39;w&#39; or &#39;a&#39;</span><br><span class="line">    :return: void</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    with open(filename, mode) as f:</span><br><span class="line">        for line in content:</span><br><span class="line">            str_line &#x3D; &quot;&quot;</span><br><span class="line">            for col, data in enumerate(line):</span><br><span class="line">                if not col &#x3D;&#x3D; len(line) - 1:</span><br><span class="line">                    # 以空格作为分隔符</span><br><span class="line">                    str_line &#x3D; str_line + str(data) + &quot; &quot;</span><br><span class="line">                else:</span><br><span class="line">                    # 每行最后一个数据用换行符“\n”</span><br><span class="line">                    str_line &#x3D; str_line + str(data) + &quot;\n&quot;</span><br><span class="line">            f.write(str_line)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def get_files_list(dir):</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    实现遍历dir目录下,所有文件(包含子文件夹的文件)</span><br><span class="line">    :param dir:指定文件夹目录</span><br><span class="line">    :return:包含所有文件的列表-&gt;list</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    # parent:父目录, filenames:该目录下所有文件夹,filenames:该目录下的文件名</span><br><span class="line">    files_list &#x3D; []</span><br><span class="line">    for parent, dirnames, filenames in os.walk(dir):</span><br><span class="line">        for filename in filenames:</span><br><span class="line">            print(&quot;parent is: &quot; + parent)</span><br><span class="line">            print(&quot;filename is: &quot; + filename)</span><br><span class="line">            # print(os.path.join(parent, filename))  # 输出rootdir路径下所有文件（包含子文件）信息</span><br><span class="line">            curr_file &#x3D; parent.split(os.sep)[-1]</span><br><span class="line">            if curr_file &#x3D;&#x3D; &#39;flower&#39;:</span><br><span class="line">                labels &#x3D; 0</span><br><span class="line">            elif curr_file &#x3D;&#x3D; &#39;guitar&#39;:</span><br><span class="line">                labels &#x3D; 1</span><br><span class="line">            elif curr_file &#x3D;&#x3D; &#39;person&#39;:</span><br><span class="line">                labels &#x3D; 2</span><br><span class="line">            elif curr_file &#x3D;&#x3D; &#39;houses&#39;:</span><br><span class="line">                labels &#x3D; 3</span><br><span class="line">            elif curr_file &#x3D;&#x3D; &#39;plane&#39;:</span><br><span class="line">                labels &#x3D; 4</span><br><span class="line">            elif curr_file &#x3D;&#x3D; &#39;tiger&#39;:</span><br><span class="line">                labels &#x3D; 5</span><br><span class="line">            elif curr_file &#x3D;&#x3D; &#39;kittycat&#39;:</span><br><span class="line">                labels &#x3D; 6</span><br><span class="line">            elif curr_file &#x3D;&#x3D; &#39;truck&#39;:</span><br><span class="line">                labels &#x3D; 7</span><br><span class="line">            files_list.append([os.path.join(curr_file, filename), labels])</span><br><span class="line">            print(files_list)</span><br><span class="line">    return files_list</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    train_dir &#x3D; &#39;dataset&#x2F;train&#39;</span><br><span class="line">    train_txt &#x3D; &#39;dataset&#x2F;train.txt&#39;</span><br><span class="line">    train_data &#x3D; get_files_list(train_dir)</span><br><span class="line">    write_txt(train_data, train_txt, mode&#x3D;&#39;w&#39;)</span><br><span class="line"> </span><br><span class="line">    val_dir &#x3D; &#39;dataset&#x2F;val&#39;</span><br><span class="line">    val_txt &#x3D; &#39;dataset&#x2F;val.txt&#39;</span><br><span class="line">    val_data &#x3D; get_files_list(val_dir)</span><br><span class="line">    write_txt(val_data, val_txt, mode&#x3D;&#39;w&#39;)</span><br></pre></td></tr></table></figure><br>4.制作tf.record文件<br><em>create_tf_record.py</em><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*-coding: utf-8 -*-</span><br><span class="line"> </span><br><span class="line">import tensorflow as tf</span><br><span class="line">import numpy as np</span><br><span class="line">import os</span><br><span class="line">import cv2</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import random</span><br><span class="line">from PIL import Image</span><br><span class="line"> </span><br><span class="line">def _int64_feature(value):</span><br><span class="line">    return tf.train.Feature(int64_list&#x3D;tf.train.Int64List(value&#x3D;[value]))</span><br><span class="line"># 生成字符串型的属性</span><br><span class="line">def _bytes_feature(value):</span><br><span class="line">    return tf.train.Feature(bytes_list&#x3D;tf.train.BytesList(value&#x3D;[value]))</span><br><span class="line"># 生成实数型的属性</span><br><span class="line">def float_list_feature(value):</span><br><span class="line">  return tf.train.Feature(float_list&#x3D;tf.train.FloatList(value&#x3D;value))</span><br><span class="line"> </span><br><span class="line">def get_example_nums(tf_records_filenames):</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    统计tf_records图像的个数(example)个数</span><br><span class="line">    :param tf_records_filenames: tf_records文件路径</span><br><span class="line">    :return:</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    nums&#x3D; 0</span><br><span class="line">    for record in tf.python_io.tf_record_iterator(tf_records_filenames):</span><br><span class="line">        nums +&#x3D; 1</span><br><span class="line">    return nums</span><br><span class="line"> </span><br><span class="line">def show_image(title,image):</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    显示图片</span><br><span class="line">    :param title: 图像标题</span><br><span class="line">    :param image: 图像的数据</span><br><span class="line">    :return:</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    # plt.figure(&quot;show_image&quot;)</span><br><span class="line">    # print(image.dtype)</span><br><span class="line">    plt.imshow(image)</span><br><span class="line">    plt.axis(&#39;on&#39;)    # 关掉坐标轴为 off</span><br><span class="line">    plt.title(title)  # 图像题目</span><br><span class="line">    plt.show()</span><br><span class="line"> </span><br><span class="line">def load_labels_file(filename,labels_num&#x3D;1,shuffle&#x3D;False):</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    载图txt文件，文件中每行为一个图片信息，且以空格隔开：图像路径 标签1 标签2，如：test_image&#x2F;1.jpg 0 2</span><br><span class="line">    :param filename:</span><br><span class="line">    :param labels_num :labels个数</span><br><span class="line">    :param shuffle :是否打乱顺序</span><br><span class="line">    :return:images type-&gt;list</span><br><span class="line">    :return:labels type-&gt;list</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    images&#x3D;[]</span><br><span class="line">    labels&#x3D;[]</span><br><span class="line">    with open(filename) as f:</span><br><span class="line">        lines_list&#x3D;f.readlines()</span><br><span class="line">        if shuffle:</span><br><span class="line">            random.shuffle(lines_list)</span><br><span class="line"> </span><br><span class="line">        for lines in lines_list:</span><br><span class="line">            line&#x3D;lines.rstrip().split(&#39; &#39;)</span><br><span class="line">            label&#x3D;[]</span><br><span class="line">            for i in range(labels_num):</span><br><span class="line">                label.append(int(line[i+1]))</span><br><span class="line">            images.append(line[0])</span><br><span class="line">            labels.append(label)</span><br><span class="line">    return images,labels</span><br><span class="line"> </span><br><span class="line">def read_image(filename, resize_height, resize_width,normalization&#x3D;False):</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    读取图片数据,默认返回的是uint8,[0,255]</span><br><span class="line">    :param filename:</span><br><span class="line">    :param resize_height:</span><br><span class="line">    :param resize_width:</span><br><span class="line">    :param normalization:是否归一化到[0.,1.0]</span><br><span class="line">    :return: 返回的图片数据</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line"> </span><br><span class="line">    bgr_image &#x3D; cv2.imread(filename)</span><br><span class="line">    if None is bgr_image:</span><br><span class="line">        pass</span><br><span class="line">    elif len(bgr_image.shape)&#x3D;&#x3D;2:#若是灰度图则转为三通道</span><br><span class="line">        print(&quot;Warning:gray image&quot;,filename)</span><br><span class="line">        bgr_image &#x3D; cv2.cvtColor(bgr_image, cv2.COLOR_GRAY2BGR)</span><br><span class="line">    print(filename)</span><br><span class="line">    rgb_image &#x3D; cv2.cvtColor(bgr_image, cv2.COLOR_BGR2RGB)#将BGR转为RGB</span><br><span class="line">    # show_image(filename,rgb_image)</span><br><span class="line">    # rgb_image&#x3D;Image.open(filename)</span><br><span class="line">    if resize_height&gt;0 and resize_width&gt;0:</span><br><span class="line">        rgb_image&#x3D;cv2.resize(rgb_image,(resize_width,resize_height))</span><br><span class="line">    rgb_image&#x3D;np.asanyarray(rgb_image)</span><br><span class="line">    if normalization:</span><br><span class="line">        # 不能写成:rgb_image&#x3D;rgb_image&#x2F;255</span><br><span class="line">        rgb_image&#x3D;rgb_image&#x2F;255.0</span><br><span class="line">    # show_image(&quot;src resize image&quot;,image)</span><br><span class="line">    return rgb_image</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def get_batch_images(images,labels,batch_size,labels_nums,one_hot&#x3D;False,shuffle&#x3D;True,num_threads&#x3D;1):</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    :param images:图像</span><br><span class="line">    :param labels:标签</span><br><span class="line">    :param batch_size:</span><br><span class="line">    :param labels_nums:标签个数</span><br><span class="line">    :param one_hot:是否将labels转为one_hot的形式</span><br><span class="line">    :param shuffle:是否打乱顺序,一般train时shuffle&#x3D;True,验证时shuffle&#x3D;False</span><br><span class="line">    :return:返回batch的images和labels</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    min_after_dequeue &#x3D; 200</span><br><span class="line">    capacity &#x3D; min_after_dequeue + 3 * batch_size  # 保证capacity必须大于min_after_dequeue参数值</span><br><span class="line">    if shuffle:</span><br><span class="line">        images_batch, labels_batch &#x3D; tf.train.shuffle_batch([images,labels],</span><br><span class="line">                                                                    batch_size&#x3D;batch_size,</span><br><span class="line">                                                                    capacity&#x3D;capacity,</span><br><span class="line">                                                                    min_after_dequeue&#x3D;min_after_dequeue,</span><br><span class="line">                                                                    num_threads&#x3D;num_threads)</span><br><span class="line">    else:</span><br><span class="line">        images_batch, labels_batch &#x3D; tf.train.batch([images,labels],</span><br><span class="line">                                                        batch_size&#x3D;batch_size,</span><br><span class="line">                                                        capacity&#x3D;capacity,</span><br><span class="line">                                                        num_threads&#x3D;num_threads)</span><br><span class="line">    if one_hot:</span><br><span class="line">        labels_batch &#x3D; tf.one_hot(labels_batch, labels_nums, 1, 0)</span><br><span class="line">    return images_batch,labels_batch</span><br><span class="line"> </span><br><span class="line">def read_records(filename,resize_height, resize_width,type&#x3D;None):</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    解析record文件:源文件的图像数据是RGB,uint8,[0,255],一般作为训练数据时,需要归一化到[0,1]</span><br><span class="line">    :param filename:</span><br><span class="line">    :param resize_height:</span><br><span class="line">    :param resize_width:</span><br><span class="line">    :param type:选择图像数据的返回类型</span><br><span class="line">         None:默认将uint8-[0,255]转为float32-[0,255]</span><br><span class="line">         normalization:归一化float32-[0,1]</span><br><span class="line">         centralization:归一化float32-[0,1],再减均值中心化</span><br><span class="line">    :return:</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    # 创建文件队列,不限读取的数量</span><br><span class="line">    filename_queue &#x3D; tf.train.string_input_producer([filename])</span><br><span class="line">    # create a reader from file queue</span><br><span class="line">    reader &#x3D; tf.TFRecordReader()</span><br><span class="line">    # reader从文件队列中读入一个序列化的样本</span><br><span class="line">    _, serialized_example &#x3D; reader.read(filename_queue)</span><br><span class="line">    # get feature from serialized example</span><br><span class="line">    # 解析符号化的样本</span><br><span class="line">    features &#x3D; tf.parse_single_example(</span><br><span class="line">        serialized_example,</span><br><span class="line">        features&#x3D;&#123;</span><br><span class="line">            &#39;image_raw&#39;: tf.FixedLenFeature([], tf.string),</span><br><span class="line">            &#39;height&#39;: tf.FixedLenFeature([], tf.int64),</span><br><span class="line">            &#39;width&#39;: tf.FixedLenFeature([], tf.int64),</span><br><span class="line">            &#39;depth&#39;: tf.FixedLenFeature([], tf.int64),</span><br><span class="line">            &#39;label&#39;: tf.FixedLenFeature([], tf.int64)</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    tf_image &#x3D; tf.decode_raw(features[&#39;image_raw&#39;], tf.uint8)#获得图像原始的数据</span><br><span class="line"> </span><br><span class="line">    tf_height &#x3D; features[&#39;height&#39;]</span><br><span class="line">    tf_width &#x3D; features[&#39;width&#39;]</span><br><span class="line">    tf_depth &#x3D; features[&#39;depth&#39;]</span><br><span class="line">    tf_label &#x3D; tf.cast(features[&#39;label&#39;], tf.int32)</span><br><span class="line">    # PS:恢复原始图像数据,reshape的大小必须与保存之前的图像shape一致,否则出错</span><br><span class="line">    # tf_image&#x3D;tf.reshape(tf_image, [-1])    # 转换为行向量</span><br><span class="line">    tf_image&#x3D;tf.reshape(tf_image, [resize_height, resize_width, 3]) # 设置图像的维度</span><br><span class="line"> </span><br><span class="line">    # 恢复数据后,才可以对图像进行resize_images:输入uint-&gt;输出float32</span><br><span class="line">    # tf_image&#x3D;tf.image.resize_images(tf_image,[224, 224])</span><br><span class="line"> </span><br><span class="line">    # 存储的图像类型为uint8,tensorflow训练时数据必须是tf.float32</span><br><span class="line">    if type is None:</span><br><span class="line">        tf_image &#x3D; tf.cast(tf_image, tf.float32)</span><br><span class="line">    elif type&#x3D;&#x3D;&#39;normalization&#39;:# [1]若需要归一化请使用:</span><br><span class="line">        # 仅当输入数据是uint8,才会归一化[0,255]</span><br><span class="line">        # tf_image &#x3D; tf.image.convert_image_dtype(tf_image, tf.float32)</span><br><span class="line">        tf_image &#x3D; tf.cast(tf_image, tf.float32) * (1. &#x2F; 255.0)  # 归一化</span><br><span class="line">    elif type&#x3D;&#x3D;&#39;centralization&#39;:</span><br><span class="line">        # 若需要归一化,且中心化,假设均值为0.5,请使用:</span><br><span class="line">        tf_image &#x3D; tf.cast(tf_image, tf.float32) * (1. &#x2F; 255) - 0.5 #中心化</span><br><span class="line"> </span><br><span class="line">    # 这里仅仅返回图像和标签</span><br><span class="line">    # return tf_image, tf_height,tf_width,tf_depth,tf_label</span><br><span class="line">    return tf_image,tf_label</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def create_records(image_dir,file, output_record_dir, resize_height, resize_width,shuffle,log&#x3D;5):</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    实现将图像原始数据,label,长,宽等信息保存为record文件</span><br><span class="line">    注意:读取的图像数据默认是uint8,再转为tf的字符串型BytesList保存,解析请需要根据需要转换类型</span><br><span class="line">    :param image_dir:原始图像的目录</span><br><span class="line">    :param file:输入保存图片信息的txt文件(image_dir+file构成图片的路径)</span><br><span class="line">    :param output_record_dir:保存record文件的路径</span><br><span class="line">    :param resize_height:</span><br><span class="line">    :param resize_width:</span><br><span class="line">    PS:当resize_height或者resize_width&#x3D;0是,不执行resize</span><br><span class="line">    :param shuffle:是否打乱顺序</span><br><span class="line">    :param log:log信息打印间隔</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    # 加载文件,仅获取一个label</span><br><span class="line">    images_list, labels_list&#x3D;load_labels_file(file,1,shuffle)</span><br><span class="line"> </span><br><span class="line">    writer &#x3D; tf.python_io.TFRecordWriter(output_record_dir)</span><br><span class="line">    for i, [image_name, labels] in enumerate(zip(images_list, labels_list)):</span><br><span class="line">        image_path&#x3D;os.path.join(image_dir,images_list[i])</span><br><span class="line">        if not os.path.exists(image_path):</span><br><span class="line">            print(&#39;Err:no image&#39;,image_path)</span><br><span class="line">            continue</span><br><span class="line">        image &#x3D; read_image(image_path, resize_height, resize_width)</span><br><span class="line">        image_raw &#x3D; image.tostring()</span><br><span class="line">        if i%log&#x3D;&#x3D;0 or i&#x3D;&#x3D;len(images_list)-1:</span><br><span class="line">            print(&#39;------------processing:%d-th------------&#39; % (i))</span><br><span class="line">            print(&#39;current image_path&#x3D;%s&#39; % (image_path),&#39;shape:&#123;&#125;&#39;.format(image.shape),&#39;labels:&#123;&#125;&#39;.format(labels))</span><br><span class="line">        # 这里仅保存一个label,多label适当增加&quot;&#39;label&#39;: _int64_feature(label)&quot;项</span><br><span class="line">        label&#x3D;labels[0]</span><br><span class="line">        example &#x3D; tf.train.Example(features&#x3D;tf.train.Features(feature&#x3D;&#123;</span><br><span class="line">            &#39;image_raw&#39;: _bytes_feature(image_raw),</span><br><span class="line">            &#39;height&#39;: _int64_feature(image.shape[0]),</span><br><span class="line">            &#39;width&#39;: _int64_feature(image.shape[1]),</span><br><span class="line">            &#39;depth&#39;: _int64_feature(image.shape[2]),</span><br><span class="line">            &#39;label&#39;: _int64_feature(label)</span><br><span class="line">        &#125;))</span><br><span class="line">        writer.write(example.SerializeToString())</span><br><span class="line">    writer.close()</span><br><span class="line"> </span><br><span class="line">def disp_records(record_file,resize_height, resize_width,show_nums&#x3D;4):</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    解析record文件，并显示show_nums张图片，主要用于验证生成record文件是否成功</span><br><span class="line">    :param tfrecord_file: record文件路径</span><br><span class="line">    :return:</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    # 读取record函数</span><br><span class="line">    tf_image, tf_label &#x3D; read_records(record_file,resize_height,resize_width,type&#x3D;&#39;normalization&#39;)</span><br><span class="line">    # 显示前4个图片</span><br><span class="line">    init_op &#x3D; tf.initialize_all_variables()</span><br><span class="line">    with tf.Session() as sess:</span><br><span class="line">        sess.run(init_op)</span><br><span class="line">        coord &#x3D; tf.train.Coordinator()</span><br><span class="line">        threads &#x3D; tf.train.start_queue_runners(sess&#x3D;sess, coord&#x3D;coord)</span><br><span class="line">        for i in range(show_nums):</span><br><span class="line">            image,label &#x3D; sess.run([tf_image,tf_label])  # 在会话中取出image和label</span><br><span class="line">            # image &#x3D; tf_image.eval()</span><br><span class="line">            # 直接从record解析的image是一个向量,需要reshape显示</span><br><span class="line">            # image &#x3D; image.reshape([height,width,depth])</span><br><span class="line">            print(&#39;shape:&#123;&#125;,tpye:&#123;&#125;,labels:&#123;&#125;&#39;.format(image.shape,image.dtype,label))</span><br><span class="line">            # pilimg &#x3D; Image.fromarray(np.asarray(image_eval_reshape))</span><br><span class="line">            # pilimg.show()</span><br><span class="line">            show_image(&quot;image:%d&quot;%(label),image)</span><br><span class="line">        coord.request_stop()</span><br><span class="line">        coord.join(threads)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def batch_test(record_file,resize_height, resize_width):</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    :param record_file: record文件路径</span><br><span class="line">    :param resize_height:</span><br><span class="line">    :param resize_width:</span><br><span class="line">    :return:</span><br><span class="line">    :PS:image_batch, label_batch一般作为网络的输入</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    # 读取record函数</span><br><span class="line">    tf_image,tf_label &#x3D; read_records(record_file,resize_height,resize_width,type&#x3D;&#39;normalization&#39;)</span><br><span class="line">    image_batch, label_batch&#x3D; get_batch_images(tf_image,tf_label,batch_size&#x3D;4,labels_nums&#x3D;5,one_hot&#x3D;False,shuffle&#x3D;False)</span><br><span class="line"> </span><br><span class="line">    init &#x3D; tf.global_variables_initializer()</span><br><span class="line">    with tf.Session() as sess:  # 开始一个会话</span><br><span class="line">        sess.run(init)</span><br><span class="line">        coord &#x3D; tf.train.Coordinator()</span><br><span class="line">        threads &#x3D; tf.train.start_queue_runners(coord&#x3D;coord)</span><br><span class="line">        for i in range(4):</span><br><span class="line">            # 在会话中取出images和labels</span><br><span class="line">            images, labels &#x3D; sess.run([image_batch, label_batch])</span><br><span class="line">            # 这里仅显示每个batch里第一张图片</span><br><span class="line">            show_image(&quot;image&quot;, images[0, :, :, :])</span><br><span class="line">            print(&#39;shape:&#123;&#125;,tpye:&#123;&#125;,labels:&#123;&#125;&#39;.format(images.shape,images.dtype,labels))</span><br><span class="line"> </span><br><span class="line">        # 停止所有线程</span><br><span class="line">        coord.request_stop()</span><br><span class="line">        coord.join(threads)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    # 参数设置</span><br><span class="line"> </span><br><span class="line">    resize_height &#x3D; 224  # 指定存储图片高度</span><br><span class="line">    resize_width &#x3D; 224  # 指定存储图片宽度</span><br><span class="line">    shuffle&#x3D;True</span><br><span class="line">    log&#x3D;5</span><br><span class="line">    # 产生train.record文件</span><br><span class="line">    image_dir&#x3D;&#39;dataset&#x2F;train&#39;</span><br><span class="line">    train_labels &#x3D; &#39;dataset&#x2F;train.txt&#39;  # 图片路径</span><br><span class="line">    train_record_output &#x3D; &#39;dataset&#x2F;record&#x2F;train&#123;&#125;.tfrecords&#39;.format(resize_height)</span><br><span class="line">    create_records(image_dir,train_labels, train_record_output, resize_height, resize_width,shuffle,log)</span><br><span class="line">    train_nums&#x3D;get_example_nums(train_record_output)</span><br><span class="line">    print(&quot;save train example nums&#x3D;&#123;&#125;&quot;.format(train_nums))</span><br><span class="line"> </span><br><span class="line">    # 产生val.record文件</span><br><span class="line">    image_dir&#x3D;&#39;dataset&#x2F;val&#39;</span><br><span class="line">    val_labels &#x3D; &#39;dataset&#x2F;val.txt&#39;  # 图片路径</span><br><span class="line">    val_record_output &#x3D; &#39;dataset&#x2F;record&#x2F;val&#123;&#125;.tfrecords&#39;.format(resize_height)</span><br><span class="line">    create_records(image_dir,val_labels, val_record_output, resize_height, resize_width,shuffle,log)</span><br><span class="line">    val_nums&#x3D;get_example_nums(val_record_output)</span><br><span class="line">    print(&quot;save val example nums&#x3D;&#123;&#125;&quot;.format(val_nums))</span><br><span class="line"> </span><br><span class="line">    # 测试显示函数</span><br><span class="line">    # disp_records(train_record_output,resize_height, resize_width)</span><br><span class="line">    batch_test(train_record_output,resize_height, resize_width)</span><br></pre></td></tr></table></figure><br>5.训练模型</p>
<p><em>vgg16.py</em><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#vgg16_train_and_val</span><br><span class="line">import tensorflow as tf</span><br><span class="line">import numpy as np</span><br><span class="line">import pdb</span><br><span class="line">import os</span><br><span class="line">from datetime import datetime</span><br><span class="line">from create_tf_record import *</span><br><span class="line">import tensorflow.contrib.slim as slim</span><br><span class="line"> </span><br><span class="line">print(&quot;Tensorflow version:&#123;&#125;&quot;.format(tf.__version__))</span><br><span class="line">labels_nums &#x3D; 8  # 类别个数</span><br><span class="line">batch_size &#x3D; 1  #</span><br><span class="line">resize_height &#x3D; 224  # 指定存储图片高度</span><br><span class="line">resize_width &#x3D; 224  # 指定存储图片宽度</span><br><span class="line">depths &#x3D; 3</span><br><span class="line">data_shape &#x3D; [batch_size, resize_height, resize_width, depths]</span><br><span class="line"> </span><br><span class="line"># 定义input_images为图片数据</span><br><span class="line">input_images &#x3D; tf.placeholder(dtype&#x3D;tf.float32, shape&#x3D;[None, resize_height, resize_width, depths], name&#x3D;&#39;input&#39;)</span><br><span class="line"># 定义input_labels为labels数据</span><br><span class="line"># input_labels &#x3D; tf.placeholder(dtype&#x3D;tf.int32, shape&#x3D;[None], name&#x3D;&#39;label&#39;)</span><br><span class="line">input_labels &#x3D; tf.placeholder(dtype&#x3D;tf.int32, shape&#x3D;[None, labels_nums], name&#x3D;&#39;label&#39;)</span><br><span class="line"> </span><br><span class="line"># 定义dropout的概率</span><br><span class="line">keep_prob &#x3D; tf.placeholder(tf.float32,name&#x3D;&#39;keep_prob&#39;)</span><br><span class="line">is_training &#x3D; tf.placeholder(tf.bool, name&#x3D;&#39;is_training&#39;)</span><br><span class="line">def net_evaluation(sess,loss,accuracy,val_images_batch,val_labels_batch,val_nums):</span><br><span class="line">    val_max_steps &#x3D; int(val_nums &#x2F; batch_size)</span><br><span class="line">    val_losses &#x3D; []</span><br><span class="line">    val_accs &#x3D; []</span><br><span class="line">    for _ in range(val_max_steps):</span><br><span class="line">        val_x, val_y &#x3D; sess.run([val_images_batch, val_labels_batch])</span><br><span class="line">        # print(&#39;labels:&#39;,val_y)</span><br><span class="line">        # val_loss &#x3D; sess.run(loss, feed_dict&#x3D;&#123;x: val_x, y: val_y, keep_prob: 1.0&#125;)</span><br><span class="line">        # val_acc &#x3D; sess.run(accuracy,feed_dict&#x3D;&#123;x: val_x, y: val_y, keep_prob: 1.0&#125;)</span><br><span class="line">        val_loss,val_acc &#x3D; sess.run([loss,accuracy], feed_dict&#x3D;&#123;input_images: val_x, input_labels: val_y, keep_prob:1.0, is_training: False&#125;)</span><br><span class="line">        val_losses.append(val_loss)</span><br><span class="line">        val_accs.append(val_acc)</span><br><span class="line">    mean_loss &#x3D; np.array(val_losses, dtype&#x3D;np.float32).mean()</span><br><span class="line">    mean_acc &#x3D; np.array(val_accs, dtype&#x3D;np.float32).mean()</span><br><span class="line">    return mean_loss, mean_acc</span><br><span class="line"> </span><br><span class="line">class Vgg16:</span><br><span class="line">    vgg_mean &#x3D; [103.939, 116.779, 123.68]   </span><br><span class="line"> </span><br><span class="line">    def __init__(self, vgg16_npy_path&#x3D;None,input&#x3D;None, restore_from&#x3D;None):</span><br><span class="line">        # pre-trained parameters</span><br><span class="line">        try:</span><br><span class="line">            self.data_dict &#x3D; np.load(vgg16_npy_path, encoding&#x3D;&#39;latin1&#39;).item()</span><br><span class="line">        except FileNotFoundError:</span><br><span class="line">            print(&#39;Please download VGG16 parameters from here https:&#x2F;&#x2F;mega.nz&#x2F;#!YU1FWJrA!O1ywiCS2IiOlUCtCpI6HTJOMrneN-Qdv3ywQP5poecM\nOr from my Baidu Cloud: https:&#x2F;&#x2F;pan.baidu.com&#x2F;s&#x2F;1Spps1Wy0bvrQHH2IMkRfpg&#39;)</span><br><span class="line"> </span><br><span class="line">        # self.tfx &#x3D; tf.placeholder(tf.float32, [None, 224, 224, 3])</span><br><span class="line">        self.sess &#x3D; tf.Session()</span><br><span class="line">        self.tfx &#x3D; input</span><br><span class="line">        self.tfy &#x3D; tf.placeholder(tf.float32, [None, 1])</span><br><span class="line"> </span><br><span class="line">        # Convert RGB to BGR</span><br><span class="line">        red, green, blue &#x3D; tf.split(axis&#x3D;3, num_or_size_splits&#x3D;3, value&#x3D;self.tfx * 255.0)</span><br><span class="line">        bgr &#x3D; tf.concat(axis&#x3D;3, values&#x3D;[</span><br><span class="line">            blue - self.vgg_mean[0],</span><br><span class="line">            green - self.vgg_mean[1],</span><br><span class="line">            red - self.vgg_mean[2],</span><br><span class="line">        ])</span><br><span class="line"> </span><br><span class="line">        # pre-trained VGG layers are fixed in fine-tune</span><br><span class="line">        conv1_1 &#x3D; self.conv_layer(bgr, &quot;conv1_1&quot;)</span><br><span class="line">        conv1_2 &#x3D; self.conv_layer(conv1_1, &quot;conv1_2&quot;)</span><br><span class="line">        pool1 &#x3D; self.max_pool(conv1_2, &#39;pool1&#39;)</span><br><span class="line"> </span><br><span class="line">        conv2_1 &#x3D; self.conv_layer(pool1, &quot;conv2_1&quot;)</span><br><span class="line">        conv2_2 &#x3D; self.conv_layer(conv2_1, &quot;conv2_2&quot;)</span><br><span class="line">        pool2 &#x3D; self.max_pool(conv2_2, &#39;pool2&#39;)</span><br><span class="line"> </span><br><span class="line">        conv3_1 &#x3D; self.conv_layer(pool2, &quot;conv3_1&quot;)</span><br><span class="line">        conv3_2 &#x3D; self.conv_layer(conv3_1, &quot;conv3_2&quot;)</span><br><span class="line">        conv3_3 &#x3D; self.conv_layer(conv3_2, &quot;conv3_3&quot;)</span><br><span class="line">        pool3 &#x3D; self.max_pool(conv3_3, &#39;pool3&#39;)</span><br><span class="line"> </span><br><span class="line">        conv4_1 &#x3D; self.conv_layer(pool3, &quot;conv4_1&quot;)</span><br><span class="line">        conv4_2 &#x3D; self.conv_layer(conv4_1, &quot;conv4_2&quot;)</span><br><span class="line">        conv4_3 &#x3D; self.conv_layer(conv4_2, &quot;conv4_3&quot;)</span><br><span class="line">        pool4 &#x3D; self.max_pool(conv4_3, &#39;pool4&#39;)</span><br><span class="line"> </span><br><span class="line">        conv5_1 &#x3D; self.conv_layer(pool4, &quot;conv5_1&quot;)</span><br><span class="line">        conv5_2 &#x3D; self.conv_layer(conv5_1, &quot;conv5_2&quot;)</span><br><span class="line">        conv5_3 &#x3D; self.conv_layer(conv5_2, &quot;conv5_3&quot;)</span><br><span class="line">        pool5 &#x3D; self.max_pool(conv5_3, &#39;pool5&#39;)</span><br><span class="line"> </span><br><span class="line">        # detach original VGG fc layers and</span><br><span class="line">        # reconstruct your own fc layers serve for your own purpose</span><br><span class="line">        pool5_shape &#x3D; pool5.get_shape().as_list()</span><br><span class="line">        nodes &#x3D; pool5_shape[1] * pool5_shape[2] * pool5_shape[3]</span><br><span class="line">        self.flatten &#x3D; tf.reshape(pool5, [-1, nodes])</span><br><span class="line">        self.fc6 &#x3D; tf.layers.dense(self.flatten, 256, tf.nn.relu, name&#x3D;&#39;fc6&#39;)</span><br><span class="line">        self.out &#x3D; tf.layers.dense(self.fc6, labels_nums, name&#x3D;&#39;out&#39;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    def max_pool(self, bottom, name):</span><br><span class="line">        return tf.nn.max_pool(bottom, ksize&#x3D;[1, 2, 2, 1], strides&#x3D;[1, 2, 2, 1], padding&#x3D;&#39;SAME&#39;, name&#x3D;name)</span><br><span class="line"> </span><br><span class="line">    def conv_layer(self, bottom, name):</span><br><span class="line">        with tf.variable_scope(name):   # CNN&#39;s filter is constant, NOT Variable that can be trained</span><br><span class="line">            conv &#x3D; tf.nn.conv2d(bottom, self.data_dict[name][0], [1, 1, 1, 1], padding&#x3D;&#39;SAME&#39;)</span><br><span class="line">            lout &#x3D; tf.nn.relu(tf.nn.bias_add(conv, self.data_dict[name][1]))</span><br><span class="line">            return lout</span><br><span class="line"> </span><br><span class="line">    def train(self, x, y):</span><br><span class="line">        loss, _ &#x3D; self.sess.run([self.loss, self.train_op], &#123;self.tfx: x, self.tfy: y&#125;)</span><br><span class="line">        return loss</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    def save(self, path&#x3D;&#39;.&#x2F;model&#x2F;&#39;):</span><br><span class="line">        saver &#x3D; tf.train.Saver()</span><br><span class="line">        saver.save(self.sess, path, write_meta_graph&#x3D;False)</span><br><span class="line"> </span><br><span class="line">def train(train_record_file,</span><br><span class="line">          train_log_step,</span><br><span class="line">          train_param,</span><br><span class="line">          val_record_file,</span><br><span class="line">          val_log_step,</span><br><span class="line">          labels_nums,</span><br><span class="line">          data_shape,</span><br><span class="line">          snapshot,</span><br><span class="line">          snapshot_prefix):</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    :param train_record_file: 训练的tfrecord文件</span><br><span class="line">    :param train_log_step: 显示训练过程log信息间隔</span><br><span class="line">    :param train_param: train参数</span><br><span class="line">    :param val_record_file: 验证的tfrecord文件</span><br><span class="line">    :param val_log_step: 显示验证过程log信息间隔</span><br><span class="line">    :param val_param: val参数</span><br><span class="line">    :param labels_nums: labels数</span><br><span class="line">    :param data_shape: 输入数据shape</span><br><span class="line">    :param snapshot: 保存模型间隔</span><br><span class="line">    :param snapshot_prefix: 保存模型文件的前缀名</span><br><span class="line">    :return:</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    [base_lr,max_steps]&#x3D;train_param</span><br><span class="line">    [batch_size,resize_height,resize_width,depths]&#x3D;data_shape</span><br><span class="line"> </span><br><span class="line">    # 获得训练和测试的样本数</span><br><span class="line">    train_nums&#x3D;get_example_nums(train_record_file)</span><br><span class="line">    val_nums&#x3D;get_example_nums(val_record_file)</span><br><span class="line">    print(&#39;train nums:%d,val nums:%d&#39;%(train_nums,val_nums))</span><br><span class="line"> </span><br><span class="line">    # 从record中读取图片和labels数据</span><br><span class="line">    # train数据,训练数据一般要求打乱顺序shuffle&#x3D;True</span><br><span class="line">    train_images, train_labels &#x3D; read_records(train_record_file, resize_height, resize_width, type&#x3D;&#39;normalization&#39;)</span><br><span class="line">    train_images_batch, train_labels_batch &#x3D; get_batch_images(train_images, train_labels,</span><br><span class="line">                                                              batch_size&#x3D;batch_size, labels_nums&#x3D;labels_nums,</span><br><span class="line">                                                              one_hot&#x3D;True, shuffle&#x3D;False)</span><br><span class="line">    # val数据,验证数据可以不需要打乱数据</span><br><span class="line">    val_images, val_labels &#x3D; read_records(val_record_file, resize_height, resize_width, type&#x3D;&#39;normalization&#39;)</span><br><span class="line">    val_images_batch, val_labels_batch &#x3D; get_batch_images(val_images, val_labels,</span><br><span class="line">                                                          batch_size&#x3D;batch_size, labels_nums&#x3D;labels_nums,</span><br><span class="line">                                                          one_hot&#x3D;True, shuffle&#x3D;False)</span><br><span class="line"> </span><br><span class="line">    # Define the model:</span><br><span class="line">    # with slim.arg_scope(inception_v3.inception_v3_arg_scope()):</span><br><span class="line">    #     out, end_points &#x3D; inception_v3.inception_v3(inputs&#x3D;input_images, num_classes&#x3D;labels_nums, dropout_keep_prob&#x3D;keep_prob, is_training&#x3D;is_training)</span><br><span class="line">    vgg &#x3D; Vgg16(vgg16_npy_path&#x3D;&#39;.&#x2F;vgg16.npy&#39;,input&#x3D;input_images)</span><br><span class="line">    out &#x3D; vgg.out</span><br><span class="line">    # Specify the loss function: tf.losses定义的loss函数都会自动添加到loss函数,不需要add_loss()了</span><br><span class="line">    tf.losses.softmax_cross_entropy(onehot_labels&#x3D;input_labels, logits&#x3D;out)#添加交叉熵损失loss&#x3D;1.6</span><br><span class="line">    # slim.losses.add_loss(my_loss)</span><br><span class="line">    loss &#x3D; tf.losses.get_total_loss(add_regularization_losses&#x3D;True)#添加正则化损失loss&#x3D;2.2</span><br><span class="line">    accuracy &#x3D; tf.reduce_mean(tf.cast(tf.equal(tf.argmax(out, 1), tf.argmax(input_labels, 1)), tf.float32))</span><br><span class="line">    # Specify the optimization scheme:</span><br><span class="line">    optimizer &#x3D; tf.train.GradientDescentOptimizer(learning_rate&#x3D;base_lr)</span><br><span class="line">    train_op &#x3D; slim.learning.create_train_op(total_loss&#x3D;loss,optimizer&#x3D;optimizer)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    saver &#x3D; tf.train.Saver()</span><br><span class="line">    max_acc&#x3D;0.0</span><br><span class="line">    with tf.Session() as sess:</span><br><span class="line">        sess.run(tf.global_variables_initializer())</span><br><span class="line">        sess.run(tf.local_variables_initializer())</span><br><span class="line">        coord &#x3D; tf.train.Coordinator()</span><br><span class="line">        threads &#x3D; tf.train.start_queue_runners(sess&#x3D;sess, coord&#x3D;coord)</span><br><span class="line">        for i in range(max_steps+1):</span><br><span class="line">            batch_input_images, batch_input_labels &#x3D; sess.run([train_images_batch, train_labels_batch])</span><br><span class="line">            _, train_loss &#x3D; sess.run([train_op, loss], feed_dict&#x3D;&#123;input_images:batch_input_images,</span><br><span class="line">                                                                      input_labels:batch_input_labels,</span><br><span class="line">                                                                      keep_prob:0.5, is_training:True&#125;)</span><br><span class="line">            # train测试(这里仅测试训练集的一个batch)</span><br><span class="line">            if i%train_log_step &#x3D;&#x3D; 0:</span><br><span class="line">                train_acc &#x3D; sess.run(accuracy, feed_dict&#x3D;&#123;input_images:batch_input_images,</span><br><span class="line">                                                          input_labels: batch_input_labels,</span><br><span class="line">                                                          keep_prob:1.0, is_training: False&#125;)</span><br><span class="line">                print(&quot;%s: Step [%d]  train Loss : %f, training accuracy :  %g&quot; % (datetime.now(), i, train_loss, train_acc))</span><br><span class="line"> </span><br><span class="line">            # val测试(测试全部val数据)</span><br><span class="line">            if i%val_log_step &#x3D;&#x3D; 0:</span><br><span class="line">                mean_loss, mean_acc&#x3D;net_evaluation(sess, loss, accuracy, val_images_batch, val_labels_batch,val_nums)</span><br><span class="line">                print(&quot;%s: Step [%d]  val Loss : %f, val accuracy :  %g&quot; % (datetime.now(), i, mean_loss, mean_acc))</span><br><span class="line"> </span><br><span class="line">            # 模型保存:每迭代snapshot次或者最后一次保存模型</span><br><span class="line">            if (i %snapshot &#x3D;&#x3D; 0 and i &gt;0)or i &#x3D;&#x3D; max_steps:</span><br><span class="line">                print(&#39;-----save:&#123;&#125;-&#123;&#125;&#39;.format(snapshot_prefix,i))</span><br><span class="line">                saver.save(sess, snapshot_prefix, global_step&#x3D;i)</span><br><span class="line">            # 保存val准确率最高的模型</span><br><span class="line">            if mean_acc&gt;max_acc and mean_acc&gt;0.5:</span><br><span class="line">                max_acc&#x3D;mean_acc</span><br><span class="line">                path &#x3D; os.path.dirname(snapshot_prefix)</span><br><span class="line">                best_models&#x3D;os.path.join(path,&#39;best_models_&#123;&#125;_&#123;:.4f&#125;.ckpt&#39;.format(i,max_acc))</span><br><span class="line">                print(&#39;------save:&#123;&#125;&#39;.format(best_models))</span><br><span class="line">                saver.save(sess, best_models)</span><br><span class="line"> </span><br><span class="line">        coord.request_stop()</span><br><span class="line">        coord.join(threads)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    train_record_file&#x3D;&#39;dataset&#x2F;record&#x2F;train224.tfrecords&#39;</span><br><span class="line">    val_record_file&#x3D;&#39;dataset&#x2F;record&#x2F;val224.tfrecords&#39;</span><br><span class="line"> </span><br><span class="line">    train_log_step&#x3D;100</span><br><span class="line">    base_lr &#x3D; 0.01  # 学习率</span><br><span class="line">    max_steps &#x3D; 200000  # 迭代次数</span><br><span class="line">    train_param&#x3D;[base_lr,max_steps]</span><br><span class="line"> </span><br><span class="line">    val_log_step&#x3D;200</span><br><span class="line">    snapshot&#x3D;2000#保存文件间隔</span><br><span class="line">    snapshot_prefix&#x3D;&#39;.&#x2F;models&#x2F;model.ckpt&#39;</span><br><span class="line">    train(train_record_file&#x3D;train_record_file,</span><br><span class="line">          train_log_step&#x3D;train_log_step,</span><br><span class="line">          train_param&#x3D;train_param,</span><br><span class="line">          val_record_file&#x3D;val_record_file,</span><br><span class="line">          val_log_step&#x3D;val_log_step,</span><br><span class="line">          labels_nums&#x3D;labels_nums,</span><br><span class="line">          data_shape&#x3D;data_shape,</span><br><span class="line">          snapshot&#x3D;snapshot,</span><br><span class="line">          snapshot_prefix&#x3D;snapshot_prefix)</span><br></pre></td></tr></table></figure></p>
<h2 id="3-结果展示"><a href="#3-结果展示" class="headerlink" title="3.结果展示"></a>3.结果展示</h2><p>用实验室服务器训练了20万代，在验证集上的准确率达到了90.75%。以下是预测结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test_images\flower1.jpg</span><br><span class="line">test_images\flower1.jpg is: pre labels:[0],name:[&#39;flower&#39;] score: [ 1.]</span><br><span class="line">test_images\flower2.jpg</span><br><span class="line">test_images\flower2.jpg is: pre labels:[0],name:[&#39;flower&#39;] score: [ 1.]</span><br><span class="line">test_images\kittycat.jpg</span><br><span class="line">test_images\kittycat.jpg is: pre labels:[6],name:[&#39;kittycat&#39;] score: [ 0.4819051]</span><br><span class="line">test_images\kittycat2.jpg</span><br><span class="line">test_images\kittycat2.jpg is: pre labels:[6],name:[&#39;kittycat&#39;] score: [ 0.4819051]</span><br><span class="line">test_images\lion.jpg</span><br><span class="line">test_images\lion.jpg is: pre labels:[6],name:[&#39;kittycat&#39;] score: [ 0.4819051]</span><br><span class="line">test_images\plane.jpg</span><br><span class="line">test_images\plane.jpg is: pre labels:[4],name:[&#39;plane&#39;] score: [ 1.]</span><br><span class="line">test_images\plane2.jpg</span><br><span class="line">test_images\plane2.jpg is: pre labels:[1],name:[&#39;guitar&#39;] score: [ 1.]</span><br><span class="line">test_images\tiger0.jpg</span><br><span class="line">test_images\tiger0.jpg is: pre labels:[5],name:[&#39;tiger&#39;] score: [ 1.]</span><br><span class="line">test_images\tiger1.jpg</span><br><span class="line">test_images\tiger1.jpg is: pre labels:[5],name:[&#39;tiger&#39;] score: [ 1.]</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Deeplearning</category>
        <category>Classification</category>
      </categories>
      <tags>
        <tag>Deeplearning</tag>
        <tag>Classification</tag>
      </tags>
  </entry>
  <entry>
    <title>基于双定向胶囊网络的超低分辨率的图像识别</title>
    <url>/articles/34f2d837.html/</url>
    <content><![CDATA[<blockquote>
<p>解读<a href="https://arxiv.org/abs/1908.10027" target="_blank" rel="noopener">Dual Directed Capsule Network for Very Low Resolution Image Recognition</a></p>
</blockquote>
<h4 id="1-问题导向"><a href="#1-问题导向" class="headerlink" title="1.问题导向"></a>1.问题导向</h4><p>　　在典型的监视场景中，通常会在较大的距离内捕获图像，这回使目标区域的分辨率（VLR）非常低，通常小于16x16,例如图1(a)中显示了VLR识别的实际应用，其中感兴趣的区域是可以是人脸，可疑物体或移动的车牌号。这些样本证明了问题解决的艰巨性，其中VLR识别的的关键挑战是信息内容的有限性和模糊不清，另外VLR识别在象(人脸)，并且这些实体中每个实体的分辨率都很低。</p>
<a id="more"></a>
<p>　　对于街景房门号(SVHN)数据集，人类对于101~125像素的准确度为百分之几，而当对非常低分辨率的样本(即像素高度为25)进行分类时，性能下降到$82.0 \% \pm 2 \%$,直接采用内插的上采样是解决VLR的一个可能解决方案，但是这需要较大的倍率性能差以及可能会引入噪声。</p>
<p><img src="http://cdn.wangng.com/Deeplearning/基于双定向胶囊网络的超低分辨率的图像识别/image-20200322161635396.png" alt></p>
<h4 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2.解决方案"></a>2.解决方案</h4><p>　　提出了一种新颖的基于胶囊网络的VLR识别模型。 由于VLR图像中的信息内容有限，因此VLR识别模型也可以从信息丰富的HR样本中受益，因此作者提出了双定向胶囊网络(<em>DirectCapsNet</em>),由学习HR样本来指导VIL识别，这项工作的创新点有</p>
<ul>
<li><p>提出了一种新颖的双定向胶囊网络（<em>DirectCapsNet</em>）VLR识别模型，能使得从有限信息的VLR样本学习到的特征更加接近从HR样本学习到的更有区别度特征</p>
</li>
<li><p>提出了两种损失：(i)HR锚损失(HR-anchor loss)；(ii)目标重建损失。其中HR锚损失作用于特征学习模块，目的是将每个特定类的VLR特征指向对应类的HR特征；目标重建损失作用于分类模块，从VLR的特征胶囊中重建HR图像，从而使得相同类别的VLR和HR图像的胶囊相似。</p>
</li>
</ul>
<p><img src="http://cdn.wangng.com/Deeplearning/基于双定向胶囊网络的超低分辨率的图像识别/image-20200325095540230.png" alt></p>
<h4 id="3-具体方案"><a href="#3-具体方案" class="headerlink" title="3.具体方案"></a>3.具体方案</h4><p>​        <em>DirectCapsNet</em>通过两种方式指导并增强VLR表示，通过提议的HR锚损失和有针对性的重建损失，两者均使用HR图像提供额外的监督信息，HR信息用于指导以及从有限信息的VLR图像中提取判别表示，这是通过HR锚损失来实现的，HR锚损失同时也使得VLR图像表示更接近其相应的HR样本表示，在分类阶段还通过有针对性的重建损失来强制执行此操作，这将促进同一类别的HR和VLR样本具有相似性。</p>
<h5 id="3-1-CapsNet"><a href="#3-1-CapsNet" class="headerlink" title="3.1 CapsNet"></a>3.1 CapsNet</h5><p><img src="http://cdn.wangng.com/Deeplearning/基于双定向胶囊网络的超低分辨率的图像识别/image-20200324231226901.png" alt></p>
<p>​<br>　　胶囊是“一组神经元，其活动矢量代表特定类型的实体（例如，对象或对象部分）的实例化参数。换句话说，每个胶囊输出一个矢量，而不是单个标量输出，该矢量的值被称为活动向量。每个胶囊向量的长度($|\cdot|<em>2$)被限定到[0-1]之间，最后一层包含$k\times m$的分类胶囊，$k$是类别数，$m$是胶囊尺寸，对于给定的输入，预测类别与具有最大长度的胶囊对应。对于给定$K$个类别的问题，对于输入$x^c$(属于类c),将$v</em>{k}^{x^{c}}$表示为第$k$类胶囊的输出，$T_k$对应第k类的标签，胶囊网络的margin loss定义为</p>
<center>​$$\begin{aligned} \mathcal{L}_{\text {Margin}}=& \sum_{k=1}^{K}\left(T_{k} \max \left(0, m^{+}-\left\|v_{k}^{x^{c}}\right\|\right)^{2}\right.\\ &\left.+\lambda\left(1-T_{k}\right) \max \left(0,\left\|v_{k}^{x^{c}}\right\|-m^{-}\right)^{2}\right) \end{aligned} \tag{1}$$​</center>

<p>$m^+=0.9$ 为上margin,，惩罚假阴性（没有预测到存在的分类的情况), $m^-=0.1$为下margin，惩罚假阳性（预测到不存在的分类的情况），分别对应于用于增加类内相似度和减小类间相似度的正和负边距，注意$T_k$是一个one-hot的向量，$\lambda$是一个常数，为0.5,第一个式子Tc意味着gt中有的类，你要预测出来，没有预测出来要惩罚，第一个式子$1-T_k$意味着gt中没有的类，你不能预测出来，预测出来了要惩罚</p>
<h5 id="3-2双定向胶囊网络"><a href="#3-2双定向胶囊网络" class="headerlink" title="3.2双定向胶囊网络"></a>3.2双定向胶囊网络</h5><p><img src="http://cdn.wangng.com/Deeplearning/基于双定向胶囊网络的超低分辨率的图像识别/image-20200324142003790.png" alt></p>
<p>在训练时，输入包括HR和VLR样本。特征提取模块由卷积层和建议的HR锚损失组成，分类模块由胶囊网络和建议的目标重建损失组成。$DircetCapsNet$的损失有式(2)所示：</p>
<p>​                             <center>$$\begin{aligned} \mathcal{L}_{\text {DirectCaps} N e t} &=\mathcal{L}_{\text {Margin}}+\lambda_{1} \mathcal{L}_{H R-\text {anchor}} \\ &+\lambda_{2} \mathcal{L}_{T-\text {Recon}} \end{aligned} \tag{2}$$</center>                </p>
<p>$\lambda_1 $和$\lambda_2 $ 用于平衡HR锚和目标重建损失。边距损失在类别之间引入了可区分性，而HR锚损失和定向重建损失则在功能和分类级别上强制执行信息特征的表示。在测试时，对于给定的VLR输入，将选择具有最大长度的胶囊作为给定输入的类。</p>
<p><strong>提议的HR锚损失</strong></p>
<p>​    输入的样本包含了HR($32\times 32\times 3$)和VLR($8\times 8\times 3$上采样到HR的分辨率)，HR锚损失使得VLR的特征更加靠近HR的特征，从而使得学习到有限的VLR特征更有区分度。对于属于类别$c$的输入$x^ c$,其经过卷积层的特征$f^ {x^c}$,HR锚损失定义为：</p>
<p>​<center>$$\mathcal{L}_{H R-a n c h o r}=\frac{1}{2}\left(\left(1-r^{x^{c}}\right)\left\|f^{x^{c}}-A^{c}_*\right\|_{2}^{2}+r^{x^{c}}\left\|f^{x^{c}}-A^{c}\right\|_{2}^{2}\right) \tag{3}$$</center></p>
<p>其中$r^{x^c}$的代表样本的属性，例如$r^ {x^c}=1$表示HR样本，$r^{x^c}=0$表示VLR样本，$A^c<em>* $和$A^c$均表示的是类$c$的anchor,用于增强VLR的特征表征，$A^c</em>*$是HR-anchor的固定状态，$A^c$是HR-anchor的参数形态，需要被对其优化。所提出的HR锚损失是学习HR-anchor和靠近HR特征空间的VLR特征的组合，目的是为了学习到更具判别性的VLR特征。等式第一项试图将VLR特征指向HR锚点，第二项是从HR特征中学习到具有代表性的锚点,</p>
<p><strong>提议的目标重建损失</strong></p>
<p>​      第二种形式是通过分类模块（胶囊网络）的目标重建损失来确定的。有针对性的重建损失促进了对HR和VLR样本的相似分类胶囊的学习。如前所述，胶囊是对输入样本的实例化参数进行编码的向量。对于给定的输入，胶囊的激活被称为活动向量。为了重建，仅选择目标类别的激活向量并将其用于重建输入样本。对于输入图像$x^ c$(属于类别$c$),则重建损失定义为</p>
<script type="math/tex; mode=display">\mathcal{L}_{\text {Recon}}=\frac{1}{2}\left\|x^{c}-g\left(v_{c}^{x^{c}}\right)\right\|_{2}^{2} \tag{4}</script><p>其中，$v^{x^c}_c$是第$c$类的对应于输入$x^c$的输出胶囊，$g(\cdot)$表示重建网络，重建损失尝试对能够解释输入图像的实例化参数进行编码，从而能够重建输入。作者认为HR样本及其对应的VLR样本的实例化参数应该相似的。为此，为进行进一步的指导，作者引入了目标重建损失。目标重建损失会使得在重建网络中输出与VLR图像对应HR部分，对于输入$x^c$，目标重建损失可以写成：</p>
<p><center>​$$\mathcal{L}_{T-\text {Recon}}=\left\|h r^{x^{c}}-g\left(v_{c}^{x^{c}}\right)\right\|_{2}^{2} \tag{5}$$
</center><br>$hr^{x^c}$是输入HR/VLR样本的重建的HR图像，公式(5)确保了重建网络的输出是对HR的输入。对于VLR图像，将其HR对应部分作为重建网络的目标，由于重建网络在最终分类胶囊上运行，因此目标重建损失将HR和VLR样本推向具有由HR样本驱动的相似的激活胶囊矢量。因此，通过指示模型从提取的VLR特征中重建HR样本，重建损失促进了在分类阶段直接为HR和VLR样本学习相似的胶囊特征。</p>
<p>结合公式（3）和公式（5），对于输入$x^c$(属于c),$DircetCapsNet$</p>
<p>​            $\mathcal{L}<em>{\text {DirectCapsNet}}=\sum</em>{k=1}^{K}\left(T<em>{k} \max \left(0, m^{+}-\left|v</em>{k}^{x^{c}}\right|\right)^{2}+\right.$</p>
<p>​                                 $\left.\lambda\left(1-T<em>{k}\right) \max \left(0,\left|v</em>{k}^{x^{c}}\right|-m^{-}\right)^{2}\right)+\frac{1}{2}\left(\lambda<em>{1}\left(1-r^{x^{c}}\right)\right.+$<br>$\left.\left|f^{x^{c}}-\mathrm{A}^{c}\right|</em>{2}^{2}+\lambda<em>{1} r^{x^{c}}\left|f^{x^{c}}-A^{c}\right|</em>{2}^{2}+\lambda<em>{2}\left|h r^{x^{c}}-g\left(v</em>{c}^{x^{c}}\right)\right|_{2}^{2}\right)$</p>
<p>如图3所示 ，对于所有实验，$DirectCapsNet$模型包含<em>n个</em>卷积层，然后是两个胶囊层。HR锚损失应用于$DirectCapsNet$的最后卷积层。最终的胶囊层连接三个全连接层组成重建网络。对于HR样本,像素大于96，包含三个卷积层，每个卷积的通道数为16，32，128。如果HR样本较小，则只含一个卷积层，通道数为128，</p>
<h4 id="4-实验"><a href="#4-实验" class="headerlink" title="4.实验"></a>4.实验</h4><p>对$DirectCapsNet$提出的三个VLR识别问题进行了评估：（i）VLR数字识别，（ii）VLR人脸识别和（iii）无约束VLR人脸识别。</p>
<p><strong>案例1-VLR数字识别：</strong>街景门牌号码（SVHN）数据集,基于VLR数字识别。数据集包含[0 – 9]范围内的数字的真实图像。</p>
<p><strong>案例研究2-VLR人脸识别：</strong> VLR人脸识别在图像标记场景或单个图像中捕获多个人的情况下具有直接的适用性。对于这个特殊的案例研究，已经在CMU Multi-PIE数据集上进行了实验，该数据集模拟了一个受约束场景，使用了 237个主题。每个主题中的一个图像添加到由HR图像组成的训练集中。</p>
<p><strong>案例研究3-无约束的VLR人脸识别</strong>：无约束的VLR人脸识别在监视场景中具有广泛的适用性，其中VLR的人脸图像通常包含姿势，照明和遮挡等其他变化。已经在两个数据集上进行了实验：（a）无约束的（UCCS）数据集 ，（b）半约束的具有姿势和光照变化的CMU Multi-PIE数据集</p>
<blockquote>
<p>1.UCCS数据集包含大学生活动的图像，这些图像是使用相距100至150米的远程高分辨率监控摄像头拍摄。图像显示了学生在上课时在校园里走来走去。较大的隔离距离和不受约束的数据性质可模拟现实世界的监视设置。</p>
<p>2.CMU Multi-PIE数据集是包含具有姿势，表情和照明变化的图像</p>
</blockquote>
<ul>
<li><p><strong>1-VLR数字识别</strong></p>
<p>HR图像是$32\times 32$,VLR图像是$16\times 16$</p>
</li>
</ul>
<p><img src="http://cdn.wangng.com/Deeplearning/基于双定向胶囊网络的超低分辨率的图像识别/image-20200324231612884.png" alt></p>
<p><img src="http://cdn.wangng.com/Deeplearning/基于双定向胶囊网络的超低分辨率的图像识别/image-20200324231733843.png" alt></p>
<ul>
<li><p><strong>2-VLR 人脸识别</strong></p>
<p>HR图像是$96\times 96$,VLR图像是$8\times 8$,$16\times 16$.</p>
</li>
</ul>
<p><img src="http://cdn.wangng.com/Deeplearning/基于双定向胶囊网络的超低分辨率的图像识别/image-20200324232105845.png" alt></p>
<p><img src="http://cdn.wangng.com/Deeplearning/基于双定向胶囊网络的超低分辨率的图像识别/image-20200324232128647.png" alt></p>
<ul>
<li><strong>3 - Unconstrained VLR人脸识别</strong></li>
</ul>
<p><img src="http://cdn.wangng.com/Deeplearning/基于双定向胶囊网络的超低分辨率的图像识别/image-20200324232531850.png" alt></p>
<p><strong>4 - constrained VLR人脸识别</strong></p>
<p><img src="http://cdn.wangng.com/Deeplearning/基于双定向胶囊网络的超低分辨率的图像识别/image-20200324232758266.png" alt></p>
<h4 id="5-总结与疑点"><a href="#5-总结与疑点" class="headerlink" title="5.总结与疑点"></a>5.总结与疑点</h4><p>VLR识别是一个比较棘手的问题，在现实世界中具有广泛的应用性，但它遭受的主要挑战是信息含量低。这项研究提出了一种用于VLR识别的新型双向定向胶囊网络（DirectCapsNet）。DirectCapsNet将分类的边际损失与建议的HR锚损失和目标重建损失相结合，以增强VLR特征表征功能，HR图像在训练过程中用作“辅助”数据，以补充VLR特征学习。</p>
]]></content>
      <categories>
        <category>Deeplearning</category>
        <category>Capsnet</category>
      </categories>
      <tags>
        <tag>Deeplearning</tag>
        <tag>Capsnet</tag>
      </tags>
  </entry>
  <entry>
    <title>目标检测之Cascade-RCNN解读</title>
    <url>/articles/334625bf.html/</url>
    <content><![CDATA[<p>论文:<a href="https://arxiv.org/pdf/1712.00726.pdf" target="_blank" rel="noopener">Cascade R-CNN: Delving into High Quality Object Detection</a><br>期刊:CVPR2018<br>代码:<a href="https://github.com/zhaoweicai/Detectron-Cascade-RCNN" target="_blank" rel="noopener">Detectron-Cascade-RCNN</a></p>
<h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><p>　　在我们前面介绍的二阶段网络中,如RCNN系列，我们在定义正负类的时候会根据proposal与Ground truth的<a href="https://www.wangng.com/articles/13a21032.html/" target="_blank" rel="noopener">IOU</a>来判断这个proposal是属于正类还是负类,这个IOU阈值通常设定在0.5,也就是proposal与GT的IOU大于0.5的我们把他当成正例,小于的当成负例,然后对这些propsal进行正负样本采样,最后进行类别分类和box回归。</p>
<a id="more"></a>
<p>　　Cascade-RCNN文章指出以0.5作为阈值,会产生很多噪声检测,然而如果提高阈值,一方面可以提高proposal质量(iou值越高,proposal与GT越吻合),但另一方面,正负样本差距会进一步拉大(如RCNN中每个batch是128个proposal,其中包含32个正样本,如果iou值提高过大,正样本会很少,对目标检测来说,正样本少会意味着过拟合风险),检测性能会下降。以下图为例:<br><img src="http://cdn.wangng.com/deeplearning/objectdetection/目标检测之Cascade-RCNN解读/fig1.png" alt></p>
<p>　　阈值u=0.5的时候,有些框只包含物体很少一部分,有些框包含了多个目标,这些对检测器来说可能都是噪声,会影响检测性能。如果阈值u提高到0.7,可以看到,检测框的质量极大提高,那些噪声框会极大减少,实际对detector来说,它们需要的这些质量高的框来训练。</p>
<p>　　另外论文中作者提到过mismatch问题,我们以图(c)来讲解下这个问题,作者先是分别使用0.5,0.6,0.7的阈值训练了三个目标检测器,为了衡量每个检测器的性能,作者重新输入经过不同iou阈值的proposal,对这些proposal进行检测,最后输出回归后的检测框与GT的iou值。可以发现,iou为0.5-0.6的proposal,以0.5作为阈值训练的检测器效果是最好的。iou为0.6~0.75的proposal,阈值0.6的检测器效果更好,iou为0.7以上的阈值是0.7的检测器效果更好。也就是,以那个阈值训练的检测器,相应的应当输入以该阈值判断的proposal。</p>
<p>　　然而我们知道，检测器再inference阶段,是没有GT值的,没法根据iou来选择proposal,有的proposal甚至远远低于训练时的iou值,这就会造成mismatch问题。iou阈值越高,测试时mismatch问题越严重</p>
<p>　　图(d)时衡量三个检测器的分类效果,我们可以看到0.5的时候反而分类效果时最好的.阈值高了分类效果反而变差了,这其实不难想到,iou阈值低,正样本数据多,分类器看到的数据也就多了,iou低了,正样本少了,自然会有过拟合问题。</p>
<p>　　论文作者的目的是想在训练时获得高质量的proposal,但是单纯提高iou阈值虽然可以获得高质量的proposal,但是也会带来mismatch和正样本数据减少的问题。作者针对这一问题,提出了CasCade-RCNN的结构,使用三个不同的阈值同时训练三个detector,前面的detecotor为后面的detector提供更为精确的proposal,使得后面的分类得以使用高质量的proposal进行训练。</p>
<h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p><img src="http://cdn.wangng.com/deeplearning/objectdetection/目标检测之Cascade-RCNN解读/fig3.png" alt></p>
<p>　　既然单一的iou阈值无法取得质量较好的proposal,那可不可以使用多个iou阈值呢?下面研究者给出了答案,这里有四个网络结构,分别是Faster R-CNN,Iterative BBox,Integral Loss还有最后的Cascade-RCNN,后面三个其实是对Faster RCNN的改进。</p>
<h3 id="Iterative-BBox"><a href="#Iterative-BBox" class="headerlink" title="Iterative BBox"></a>Iterative BBox</h3><p>　　这个模型其实和Cascade-RCNN的结构很相似,只不过Iterative BBox使用了三个相同的network head,阈值设定都是0.5,统一使用0.5并不能有有效改善后面框的质量,而且前面的实验也可以看到,一个训练好的detector,输出框的iou会高于输入的iou,也就是detector会改变输入的分布,后面再使用0.5的阈值,可能还会造成mismatch问题。</p>
<h3 id="Integral-Loss"><a href="#Integral-Loss" class="headerlink" title="Integral Loss"></a>Integral Loss</h3><p>　　这个模型是共享network head前面的所有层，包括特征提取层和ROI pooling层,将RPN网络提取的ROI分别送到三个不同阈值的network head层去训练,在inference的时候会将三个head层的结果进行ensemble。这个网络虽然使用了三个不同阈值的head结构,但是没解决mismactch和正样本减少问题,在inference的时候会,高阈值的head层还是需要处理更多的低iou的proposal,mismatch问题很严重,而且阈值高的head层,proposal数量少,会有过拟合问题</p>
<h3 id="Cascade-RCNN"><a href="#Cascade-RCNN" class="headerlink" title="Cascade-RCNN"></a>Cascade-RCNN</h3><p>　　结合了Iterative BBox和Integral Loss结构设计,通过三个不同阈值的head层级联的形式,来解决mismatch问题和正样本减少的问题。<br><img src="http://cdn.wangng.com/deeplearning/objectdetection/目标检测之Cascade-RCNN解读/fig4.png" alt><br>这里我们将每个head结构称为一个stage,第一个stage的时候,正负样本都很多,样本分布较均衡,而后面的stage,随着iou的提高,样本分布开始变化,样本更加靠近GT分布,离群点也会也来越多。因此可以看到每个阶段cascade都有不同的IoU阈值，这样可以更好地消除离群点，适应新的proposal分布。</p>
<p><img src="http://cdn.wangng.com/deeplearning/objectdetection/目标检测之Cascade-RCNN解读/fig5.png" alt><br>这里我们可以看到Cascade-RCNN每个stage的样本数量是足够的,不会容易造成过拟合的风险.</p>
<h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p><strong>1.与Iterative BBox和Integral Loss比较</strong><br><img src="http://cdn.wangng.com/deeplearning/objectdetection/目标检测之Cascade-RCNN解读/fig6.png" alt></p>
<p><strong>使用Cascade结构效果</strong><br><img src="http://cdn.wangng.com/deeplearning/objectdetection/目标检测之Cascade-RCNN解读/fig7.png" alt><br>我们可以看到加和不加Cascade结构的效果还是很明显的,加上Cascade结构基本能提升2~4个点,说明这个结构还是挺有用的</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　以往的网络模型会使用单一的iou阈值来选择正负样本,单一的iou阈值选择是一个棘手的问题,阈值低了,会由大量噪声框的存在,阈值高了会有正负样本差距拉大和mismatch等问题。作者提出的Cascade R-CNN使用cascade回归作为一种重采样的机制，逐stage提高proposal的IoU值，从而使得前一个stage重新采样过的proposals能够适应下一个有更高阈值的stage。这个方法既能保证训练proposal的质量问题,还能解决高阈值下正样本数量减少的问题,对于二阶段网络来说,提升效果较明显。</p>
]]></content>
      <categories>
        <category>Deeplearning</category>
        <category>Object Detection</category>
      </categories>
      <tags>
        <tag>Object Detection</tag>
        <tag>Cascade RCNN</tag>
      </tags>
  </entry>
  <entry>
    <title>常规卷积vs.空洞卷积</title>
    <url>/articles/3c0fd490.html/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>　　空洞卷积实际是常规卷积的一种变形,空洞卷积是在常规卷积的基础上引入空洞,从而能进一步增加感受野。按我自己的理解它的操作就是在卷积核中插入(dilation rate-1)个权值为0的空洞,但是卷积核大小还是相当于不变的(很多博主说是在feature map中padding,我不是很理解,如有懂得话,可以相互交流下),这样在不增加参数的情况下,还能增加卷积后特征图的感受野。</p>
<a id="more"></a>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>　　关于为什么要引入空洞卷积，实际上还是CNN中采样的问题。在图像分割领域，图像输入到CNN(典型的网络比如FCN(Fully Convolution Network))中,FCN先像传统的CNN那样对图像做卷积再pooling，降低图像尺寸的同时增大感受野，但是由于图像分割预测是pixel-wise的输出，所以要将pooling后较小的图像尺寸upsampling到原始的图像尺寸进行预测(upsampling一般采用deconv反卷积操作),之前的pooling操作使得每个pixel预测都能看到较大感受野信息。因此图像分割FCN中有两个关键，一个是pooling减小图像尺寸增大感受野，另一个是upsampling扩大图像尺寸。在先减小再增大尺寸的过程中，肯定有一些信息损失掉了，那么能不能设计一种新的操作，不通过pooling也能有较大的感受野看到更多的信息呢？所以空洞卷积由此而生。<br>　　Pooling Layer层是我们经常用到,那这一层主要作用有哪些呢,我总结了主要有以下三点:(1)增加感受野,如一个2x2得maxpooling层,它将原特征图2x2的区域输出为大小为1的区域,感受野增大为2x2;(2)减小feature map的尺度,减小后层计算量与内存消耗;(3)增加平移不变性,我们知道图片平移几个像素对于我们人眼来说可能看不出什么变化,但对计算机来说可是千差万别,使用maxpooling后,我们获取了局部信息的有效信息,即使这些信息平移变化了,但通过Maxpool操作使得有效信息被保留。<br>　　但实际上Pooling包括它的反变换Upsampling还是有其缺点:</p>
<ul>
<li>Up-sampling / pooling layer (e.g. bilinear interpolation) is deterministic. (参数不可学习)</li>
<li>内部数据结构丢失;空间层级化信息丢失。</li>
<li>小物体信息无法重建(假设有四个pooling layer 则任何小于 2^4 =16 pixel的物体信息将理论上无法重建。)</li>
</ul>
<h3 id="常规卷积vs-空洞卷积"><a href="#常规卷积vs-空洞卷积" class="headerlink" title="常规卷积vs.空洞卷积"></a>常规卷积vs.空洞卷积</h3><table><tr>
<td><img src="http://cdn.wangng.com/deeplearning/Convolution/常规卷积vs.空洞卷积/cnn.gif" border="0"></td>
<td><img src="http://cdn.wangng.com/deeplearning/Convolution/常规卷积vs.空洞卷积/dilate.gif" border="0"></td>
</tr></table>

<p>　　左边是一个常规的3x3的卷积,右边一个dilation rate为2的卷积,这里dilation rate是这样定义的:卷积核中相邻两个点的距离,如常规的3x3,5x5的它们的dilation rate都是1。我们可以看到原来输入中每个像素的感受野是1x1,使用大小是3x3,dilation rate为1的卷积核卷积后,感受野增到为3x3,而使用大小任是3x3,dilation rate变为2的卷积核卷积后,感受野增大为5x5,实际上我们也发现,dilation rate大于1后,feature map中的部分信息会忽略掉。实际上我们也可以从采样的角度理解常规卷积和空洞卷积,卷积本质还是滑窗,常规卷积会对输入进行密集的滑窗采样,而空洞卷积会对输入稀疏滑窗采样,空洞卷积会关注更大范围语义和空间位置信息.</p>
<p>以参考1论文中的空洞卷积为例<br><img src="http://cdn.wangng.com/deeplearning/Convolution/常规卷积vs.空洞卷积/fig1.png" alt><br>(a)图是一个dilation rate为1的3x3卷积核结果,它的感受也大小是3x3;(b)是dilation rate为2的3x3卷积核对(a)的结果进行卷积,它的感受野也变成了7x7;(c)是dilation rate为4的3x3卷积核对(b)进行卷积,它的感受野变成了15x15。</p>
<h4 id="感受野"><a href="#感受野" class="headerlink" title="感受野"></a>感受野</h4><p>　　感受野计算可以参考<a href="https://zhuanlan.zhihu.com/p/31004121" target="_blank" rel="noopener">如何计算感受野(Receptive Field)——原理</a>以及<a href="https://zhuanlan.zhihu.com/p/44106492" target="_blank" rel="noopener">卷积神经网络的感受野</a>,这里还有一个以vgg16为例计算感受野的<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">vgg_16 = [</span><br><span class="line">	<span class="comment"># 1</span></span><br><span class="line">	[<span class="number">3</span>, <span class="number">1</span>], [<span class="number">3</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">	<span class="comment"># 2</span></span><br><span class="line">	[<span class="number">3</span>, <span class="number">1</span>],  [<span class="number">3</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">	<span class="comment"># 3</span></span><br><span class="line">	[<span class="number">3</span>, <span class="number">1</span>], [<span class="number">3</span>, <span class="number">1</span>], [<span class="number">3</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">	<span class="comment"># 4</span></span><br><span class="line">	[<span class="number">3</span>, <span class="number">1</span>], [<span class="number">3</span>, <span class="number">1</span>], [<span class="number">3</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">	<span class="comment"># 5</span></span><br><span class="line">	[<span class="number">3</span>, <span class="number">1</span>], [<span class="number">3</span>, <span class="number">1</span>], [<span class="number">3</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">	<span class="comment"># fc6, fake convolutional layer   </span></span><br><span class="line">	[<span class="number">7</span>, <span class="number">1</span>]</span><br><span class="line">]</span><br><span class="line">vgg16_layers = [</span><br><span class="line">	<span class="string">"3x3 conv 64"</span>, <span class="string">"3x3 conv 64"</span>, <span class="string">"pool1"</span>,</span><br><span class="line">	<span class="string">"3x3 conv 128"</span>, <span class="string">"3x3 conv 128"</span>, <span class="string">"pool2"</span>,</span><br><span class="line">	<span class="string">"3x3 conv 256"</span>, <span class="string">"3x3 conv 256"</span>, <span class="string">"3x3 conv 256"</span>, <span class="string">"pool3"</span>,</span><br><span class="line">	<span class="string">"3x3 conv 512"</span>, <span class="string">"3x3 conv 512"</span>, <span class="string">"3x3 conv 512"</span>, <span class="string">"pool4"</span>,</span><br><span class="line">	<span class="string">"3x3 conv 512"</span>, <span class="string">"3x3 conv 512"</span>, <span class="string">"3x3 conv 512"</span>, <span class="string">"pool5"</span>,</span><br><span class="line">	<span class="string">"7x7 fc"</span></span><br><span class="line">]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal_receptive_field</span><span class="params">(kspairs, layers=None)</span>:</span></span><br><span class="line">	<span class="comment"># K: composed kernel, also the receptive field </span></span><br><span class="line">	<span class="comment"># S: composed stride</span></span><br><span class="line">	K, S = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">	<span class="comment"># H = 224</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> layers:</span><br><span class="line">		layers = range(len(kspairs))</span><br><span class="line">	<span class="keyword">for</span> layer, kspair <span class="keyword">in</span> zip(layers, kspairs):</span><br><span class="line">		k, s = kspair</span><br><span class="line">		K = (k<span class="number">-1</span>) * S + K   <span class="comment">#K为感受野,k为卷积核,s为当前步长,S为总步长,padding=same</span></span><br><span class="line">		S = S * s</span><br><span class="line">		<span class="comment"># H = H//s</span></span><br><span class="line">		<span class="comment"># iamge size &#123;0&#125;'.format(H)</span></span><br><span class="line">		</span><br><span class="line">		print(<span class="string">'layer &#123;:&lt;15&#125;: &#123;&#125; [&#123;:3&#125;,&#123;:2&#125;]'</span>.format(layer, kspair, K, S))</span><br><span class="line">		</span><br><span class="line">cal_receptive_field(vgg_16, vgg16_layers)</span><br></pre></td></tr></table></figure><br>所以感受野大小计算公式为</p>
<script type="math/tex; mode=display">
R(i) = (k-1)\times S(i)+R(i-1);S(i)=S(i-1)S(i-2)...S(1)\tag{1}</script><p>R(i)第i层感受野,S(i)第i层步长累计,k卷积核大小</p>
<h4 id="输出特征图计算"><a href="#输出特征图计算" class="headerlink" title="输出特征图计算"></a>输出特征图计算</h4><p>常规卷积</p>
<script type="math/tex; mode=display">
H_{o u t}=\left[\frac{H_{i n}+2 \times \operatorname{padding}-k e r n e l \operatorname{size}}{\operatorname{stride}}\right]+1</script><p>空洞卷积</p>
<script type="math/tex; mode=display">
H_{o u t}=\left[\frac{H_{i n}+2 \times p a d \operatorname{ding}-\operatorname{dilation} \times(\operatorname{kernelsize}-1)-1}{\operatorname{stride}}\right]+1</script><p>空洞卷积的卷积核大小可以近似看成$\operatorname{dilation} \times(\operatorname{kernelsize}-1)+1$,但实际上它只有$kernelsize\times kernelsize$个值是有效的,kernel中其他点为0.</p>
<p>可以看出空洞卷积可以比较有效的保留内部的特征信息,避免了降采样带来的信息丢失问题,同时计算量并未增大,但是我们也需要注意空洞卷积会跳过一些信息,如果连续使用空洞卷积,信息可能进一步丢失.</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>1.<a href="https://arxiv.org/pdf/1511.07122v2.pdf" target="_blank" rel="noopener">Multi-scale context aggregation with dilated convolutions</a><br>2.<a href="https://www.zhihu.com/question/54149221" target="_blank" rel="noopener">如何理解空洞卷积(dilated convolution)?</a><br>3.<a href="http://zike.io/posts/calculate-receptive-field-for-vgg-16/" target="_blank" rel="noopener">Calculate Receptive Field for VGG16</a></p>
]]></content>
      <categories>
        <category>Deeplearning</category>
        <category>Convolution</category>
      </categories>
      <tags>
        <tag>空洞卷积</tag>
        <tag>Dilated Convolution</tag>
      </tags>
  </entry>
  <entry>
    <title>目标检测之Fast-RCNN,Faster-RCNN解读</title>
    <url>/articles/a76a2fca.html/</url>
    <content><![CDATA[<p>论文:<a href="https://www.cv-foundation.org/openaccess/content_iccv_2015/papers/Girshick_Fast_R-CNN_ICCV_2015_paper.pdf" target="_blank" rel="noopener">Fast-RCNN</a></p>
<center><font size="4.5" color="black">Fast-RCNN</font></center>

<a id="more"></a>
<h3 id="RCNN问题回顾"><a href="#RCNN问题回顾" class="headerlink" title="RCNN问题回顾"></a>RCNN问题回顾</h3><ol>
<li>训练要分多步,RCNN中的卷积网络需要先在一个大规模数据集先训练,然后在VOC数据集上finetune,对于SVM分类和目标框回归,都需要CNN计算的特征,而这些特征需要预先保存到磁盘中.这显然即浪费时间又浪费存储空间</li>
<li>预测的时候,每个proposal都需要经过CNN提取一遍特征(大约2000次),时间问题很严重.</li>
<li>每个proposal为了保持fc层大小固定,都需要cut或warp层固定大小,信息丢失或几何失真(CNN的卷积层不需要固定尺寸的图像，全连接层是需要固定大小输入的).</li>
</ol>
<h3 id="SppNet"><a href="#SppNet" class="headerlink" title="SppNet"></a>SppNet</h3><p>　　RCNN中每个proposal需要经过CNN重复计算,SppNet针对这个问题进行改进,每次对一整张图片用CNN提取feature map,然后在feature maps中找到各个候选框的区域。而针对每个proposal为了保持fc层大小固定,都需要cut或warp层固定大小这个问题,使用了空间金字塔池化的方法,将feature map中各个候选的目标框输出固定的大小的特征,从而可以保证可以输入任意大小的图片。但是SppNet的训练和RCNN一样也是一个多步训练的过程,这个过程也比较繁杂.<br><img src="http://cdn.wangng.com/deeplearning/objectdetection/目标检测之Fast-RCNN,Faster-RCNN解读/spp.png" alt><br>　　这里使用Conv5层的feature map,然后分成1x1，2x2，4x4三个pooling结构(这部分结构如上图所示)，对每个输入(这里每个输入大小是不一样的)都作max pooling(论文使用的)，出来的特征再连接到一起，就是(16+4+1)x256的特征向量。<br><img src="http://cdn.wangng.com/deeplearning/objectdetection/目标检测之Fast-RCNN,Faster-RCNN解读/spp2.png" alt><br>　　无论输入图像大小如何，出来的特征固定是(16+4+1)x256维度。这样就实现了不管图像中候选区域尺寸如何，SPP层的输出永远是(16+4+1)x256特征向量。SppNet的结构<br><img src="http://cdn.wangng.com/deeplearning/objectdetection/目标检测之Fast-RCNN,Faster-RCNN解读/spp3.png" alt></p>
<h3 id="模型改进"><a href="#模型改进" class="headerlink" title="模型改进"></a>模型改进</h3><p>　　针对RCNN和SppNet的问题,Fast-RCNN做了以下改进措施:</p>
<ol>
<li><p>针对RCNN中每个region需要被CNN提取特征的问题,借鉴SppNet的方法,先对整张图片提取feature map,再将该图片用Selective Search算法提取到2000个region proposal映射到pool5层的feature map中找到对应的proposal feature map;</p>
</li>
<li><p>针对RCNN需要输入固定大小的region proposal问题,解决方法是将1中每个proposal feature map用ROI Pooling层输出成固定大小的$H\times W$(7x7)的ROI feature map.再送到全连接层</p>
</li>
<li><p>针对需要多阶段训练的问题,将SVM替换成softmax多分类函数,同时提出了多任务损失函数(Multi-task Loss)，将边框回归直接加入到CNN网络中训练，同时包含了候选区域分类损失和位置回归损失。这样整个的训练过程只包含提取候选区域和CNN训练两个阶段。此外，Fast R-CNN在网络微调的过程中，不仅微调全连接层，对部分卷积层也进行了微调，得到了更好的检测结果。</p>
</li>
</ol>
<p>Fast-RCNN的整个流程如下:<br>(1). 输入一张待检测图像；<br>(2). 提取候选区域：利用Selective Search算法在输入图像中提取出候选区域，并把这些候选区域按照空间位置关系映射到最后的卷积特征层；<br>(3). 区域归一化：对于卷积特征层上的每个候选区域进行<a href="https://www.wangng.com/articles/4a644d6f.html/" target="_blank" rel="noopener">RoI Pooling</a>操作，得到固定维度的特征；<br>(4). 分类与回归：将提取到的特征输入全连接层，然后用Softmax进行分类，对候选区域的位置进行回归。<br>Fast R-CNN尽管速度和精度上都有了很大的提升，但仍然未能实现端到端(end-to-end)的目标检测，比如候选区域的获得不能同步进行，速度上还有提升空间。<br><img src="http://cdn.wangng.com/deeplearning/objectdetection/目标检测之Fast-RCNN,Faster-RCNN解读/fig1.png" alt><br>实际的训练和测试过程如下</p>
<table><tr>
<td><img src="http://cdn.wangng.com/deeplearning/objectdetection/目标检测之Fast-RCNN,Faster-RCNN解读/fig3.png" border="0"></td>
<td><img src="http://cdn.wangng.com/deeplearning/objectdetection/目标检测之Fast-RCNN,Faster-RCNN解读/fig2.png" border="0"></td>
</tr></table>


<p>　　在实际训练中，每个mini-batch包含2张图像和128个region proposal(ROI),也就是说每张图像有64个ROI。然后从这些ROI中挑选约25%的ROI，这些ROI和ground truth的IOU值都大于0.5。另外只采用随机水平翻转的方式增加数据集。测试的时候则每张图像大约2000个ROI。</p>
<h3 id="多任务损失"><a href="#多任务损失" class="headerlink" title="多任务损失"></a>多任务损失</h3><p>　　Fast RCNN在输出层有两个分支,第一个分支是分类,输出每个ROI的类别概率,共有K+1类,K个类别和1个背景,第二个分支输出目标框的偏置。训练的时候Fast RCNN将分类loss和回归loss整合在一起，其中分类采用log loss，即对真实分类的概率取负log,回归loss采用smoothl1 loss。总损失为:</p>
<script type="math/tex; mode=display">
L\left(p, u, t^{u}, v\right)=L_{\mathrm{cls}}(p, u)+\lambda[u \geq 1] L_{\mathrm{loc}}\left(t^{u}, v\right)\tag{1}</script><p>　　每个roi有一个真实的标记,类别为$u$,ground truth为$v$,上式中$L<em>{\mathrm{cls}}(p, u)=-logp</em>{u}$是是K+1类中预测真实类别为第$u$类的损失,而$L<em>{\mathrm{loc}}\left(t^{u}, v\right)$类别为u的预测框和真实框的损失,预测值为$t^{u}=\left(t</em>{\mathrm{x}}^{u}, t<em>{\mathrm{y}}^{u}, t</em>{\mathrm{w}}^{u}, t<em>{\mathrm{h}}^{u}\right)$,真实值为$v=\left(v</em>{\mathbf{x}}, \boldsymbol{v}<em>{\mathbf{y}}, \boldsymbol{v}</em>{\mathbf{w}}, \boldsymbol{v}_{\mathbf{h}}\right)$,$[u \geq 1]$表示正例为1,背景时为0。回归损失定义如下</p>
<script type="math/tex; mode=display">
L_{\mathrm{loc}}\left(t^{u}, v\right)=\sum_{i \in\{\mathrm{x}, \mathrm{y}, \mathrm{w}, \mathrm{h}\}} \operatorname{smooth}_{L_{1}}\left(t_{i}^{u}-v_{i}\right)\tag{2}</script><p>其中SmoothL1函数定义为</p>
<script type="math/tex; mode=display">
\operatorname{smooth}_{L_{1}}(x)=\left\{\begin{array}{ll}
0.5 x^{2} & \text { if }|x|<1 \\
|x|-0.5 & \text { otherwise }\tag{3}
\end{array}\right.</script><p>L1损失对于外点(outlier)的敏感度的低于L2损失,当回归目标是没有边界的时候,训练L2损失需要小心的调整学习率才能保证阻止梯度爆炸.</p>
<hr>
<center><font size="4.5" color="black">Faster-RCNN</font></center>

<p>论文:<a href="https://papers.nips.cc/paper/5638-faster-r-cnn-towards-real-time-object-detection-with-region-proposal-networks.pdf" target="_blank" rel="noopener">Faster-RCNN</a></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>　　Faster-RCNN是在Fast-RCNN的基础上改进而来的,本质是解决Fast-RCNN中region proposal需要单独使用区域搜索算法搜索出来的问题,这里作者提出使用RPN网络搜索出region proposal,再用Fast RCNN的head来分类回归,是RPN网络和Fast-RCNN的结合。</p>
<h3 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h3><p><img src="http://cdn.wangng.com/deeplearning/objectdetection/目标检测之Fast-RCNN,Faster-RCNN解读/fig4.png" alt><br>包含了四个部分,这四个部分的功能分别是:<br>1)、Conv layers提取特征图：<br>　　作为一种CNN网络目标检测方法，Faster RCNN首先使用一组基础的conv+relu+pooling层提取input image的feature maps,该feature maps会用于后续的RPN层和全连接层</p>
<p>2)、RPN(Region Proposal Networks):<br>　　RPN网络主要用于生成region proposals，首先生成一堆Anchor box，对其进行裁剪过滤后通过softmax判断anchors属于前景(foreground)或者后景(background)，即是物体or不是物体，所以这是一个二分类；同时，另一分支bounding box regression修正anchor box，形成较精确的proposal（注：这里的较精确是相对于后面全连接层的再一次box regression而言）</p>
<p>3)、Roi Pooling：<br>　　该层利用RPN生成的proposals和VGG16最后一层得到的feature map，得到固定大小的proposal feature map,进入到后面可利用全连接操作来进行目标识别和定位</p>
<p>4)、Classifier：<br>　　会将Roi Pooling层形成固定大小的feature map进行全连接操作，利用Softmax进行具体类别的分类，同时，利用L1 Loss完成bounding box regression回归操作获得物体的精确位置.</p>
<h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p><img src="http://cdn.wangng.com/deeplearning/objectdetection/目标检测之Fast-RCNN,Faster-RCNN解读/fig5.png" alt></p>
<h4 id="1-Conv-Layer"><a href="#1-Conv-Layer" class="headerlink" title="1.Conv Layer"></a>1.Conv Layer</h4><p>　　Conv layers包含了conv，pooling，relu三种层。以python版本中的VGG16模型中的faster_rcnn_test.pt的网络结构为例，如图2，Conv layers部分共有13个conv层，13个relu层，4个pooling层。在Conv layers中:<br>所有的conv层都是：kernel_size=3，pad=1，stride=1<br>所有的pooling层都是：kernel_size=2,pad=1,stride=1,kernel_size=2,pad=0,stride =2.</p>
<p>这可以保证输出图片是输入图片的1/2.经过Conv Layer后,输出特征图分辨率为(W/16,H/16),原文是输入为(1000,600),那么输出为(60,40),最后的特征图大小是60x40x512(VGG16最后卷积层输出通道数为512)。</p>
<h4 id="2-RPN"><a href="#2-RPN" class="headerlink" title="2.RPN"></a>2.RPN</h4><p>　　再Faster-RCNN提出前,region proposal的获取要么使用滑动窗口法,要么使用图像分割的区域建议搜索算法(如selective search),这些方法都比较耗时,Faster-RCNN使用神经网络自己生成,如下图就是其网络结构<br><img src="http://cdn.wangng.com/deeplearning/objectdetection/目标检测之Fast-RCNN,Faster-RCNN解读/fig6.png" alt>　<br>如上图中标识：<br>rpn_cls：60x40x512  1x1x512x18 =&gt; 60x40x9x2<br>逐像素对其9个Anchor box进行二分类(postive/negtive)<br>rpn_bbox：60x40x512 1x1x512x36    =&gt;60x40x9x4<br>逐像素得到其9个Anchor box四个坐标信息(x,y,w,h)</p>
<p><img src="/articles/a76a2fca.html/fig7.png" alt>　　</p>
<h5 id="2-1-anchors"><a href="#2-1-anchors" class="headerlink" title="2.1.anchors"></a>2.1.anchors</h5><p>　　前面提到经过Conv layers后，图片大小变成了原来的1/16，令feat_stride=16，在生成Anchors时，我们先定义一个base_anchor，大小为16x16的box(因为特征图(60x40)上的一个点，可以对应到原图（1000x600）上一个16x16大小的区域)，源码中转化为[0,0,15,15]的数组，参数ratios=[0.5, 1, 2]scales=[8, 16, 32]<br>先看[0,0,15,15],面积保持不变，长、宽比分别为[0.5, 1, 2]是产生的Anchors box<br><img src="http://cdn.wangng.com/deeplearning/objectdetection/目标检测之Fast-RCNN,Faster-RCNN解读/fig8.png" alt>　<br>如果经过scales变化，即长、宽分别均为 (16x8=128)、(16x16=256)、(16x32=512)，对应anchor box如图<br><img src="http://cdn.wangng.com/deeplearning/objectdetection/目标检测之Fast-RCNN,Faster-RCNN解读/fig9.png" alt><br>综合以上两种变换，最后生成9个Anchor box<br><img src="http://cdn.wangng.com/deeplearning/objectdetection/目标检测之Fast-RCNN,Faster-RCNN解读/fig10.png" alt></p>
<h5 id="2-2-RPN工作原理"><a href="#2-2-RPN工作原理" class="headerlink" title="2.2 RPN工作原理"></a>2.2 RPN工作原理</h5><p><strong>流程图</strong><br><img src="http://cdn.wangng.com/deeplearning/objectdetection/目标检测之Fast-RCNN,Faster-RCNN解读/fig11.png" alt></p>
<p><strong>rpn-data</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">layer &#123;  </span><br><span class="line">      name: &#39;rpn-data&#39;  </span><br><span class="line">      type: &#39;Python&#39;  </span><br><span class="line">      bottom: &#39;rpn_cls_score&#39;   #仅提供特征图的height和width的参数大小</span><br><span class="line">      bottom: &#39;gt_boxes&#39;        #ground truth box</span><br><span class="line">      bottom: &#39;im_info&#39;         #包含图片大小和缩放比例，可供过滤anchor box</span><br><span class="line">      bottom: &#39;data&#39;  </span><br><span class="line">      top: &#39;rpn_labels&#39;  </span><br><span class="line">      top: &#39;rpn_bbox_targets&#39;  </span><br><span class="line">     top: &#39;rpn_bbox_inside_weights&#39;  </span><br><span class="line">     top: &#39;rpn_bbox_outside_weights&#39;  </span><br><span class="line">     python_param &#123;  </span><br><span class="line">        module: &#39;rpn.anchor_target_layer&#39;  </span><br><span class="line">        layer: &#39;AnchorTargetLayer&#39;  </span><br><span class="line">        param_str: &quot;&#39;feat_stride&#39;: 16 \n&#39;scales&#39;: !!python&#x2F;tuple [8, 16, 32]&quot;  </span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>　　这一层主要是为特征图60<em>40上的每个像素生成9个Anchor box，并且对生成的Anchor box进行过滤和标记，参照源码，过滤和标记规则如下：<br>①去除掉超过1000</em>600这原图的边界的anchor box<br>②如果anchor box与ground truth的IoU值最大，标记为正样本，label=1<br>③如果anchor box与ground truth的IoU&gt;0.7，标记为正样本，label=1<br>④如果anchor box与ground truth的IoU&lt;0.3，标记为负样本，label=0<br>剩下的既不是正样本也不是负样本，不用于最终训练，label=-1</p>
<p><strong>Proposal</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">layer &#123;  </span><br><span class="line">      name: &#39;proposal&#39;  </span><br><span class="line">      type: &#39;Python&#39;  </span><br><span class="line">      bottom: &#39;rpn_cls_prob_reshape&#39; #[1,18,40,60]&#x3D;&#x3D;&gt; [batch_size, channel，height，width]Caffe的数据格式anchor box分类的概率</span><br><span class="line">      bottom: &#39;rpn_bbox_pred&#39;  # 记录训练好的四个回归值△x, △y, △w, △h</span><br><span class="line">      bottom: &#39;im_info&#39;  </span><br><span class="line">      top: &#39;rpn_rois&#39;  </span><br><span class="line">      python_param &#123;  </span><br><span class="line">        module: &#39;rpn.proposal_layer&#39;  </span><br><span class="line">        layer: &#39;ProposalLayer&#39;  </span><br><span class="line">        param_str: &quot;&#39;feat_stride&#39;: 16 \n&#39;scales&#39;: !!python&#x2F;tuple [4, 8, 16, 32]&quot;</span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>　　rpn_bbox_pred会记录$\Delta$x,$\Delta$y,$\Delta$w,$\Delta$h,而Conv5会生成60x40x9个anchor box，然后累加上训练好的$\Delta$x,$\Delta$y,$\Delta$w,$\Delta$h,从而得到了相较于之前更加准确的预测框region proposal，进一步对预测框进行越界剔除和使用nms非最大值抑制，剔除掉重叠的框；比如，设定IoU为0.7的阈值，即仅保留覆盖率不超过0.7的局部最大分数的box(粗筛)。最后留下大约2000个anchor(训练),然后再取前N个box(比如300个)(预测),这样，进入到下一层ROI Pooling时region proposal大约只有300个。<br>RPN网络结构总结<br>生成anchors -&gt;标记数据生成rpn-data-&gt; softmax分类器提取前景anchors-&gt; bbox reg回归前景anchors-&gt;使用nms剔除部分重叠anchor-&gt; Proposal Layer生成proposals</p>
<blockquote>
<p>用下图一个案例来对NMS算法进行简单介绍<br><img src="http://cdn.wangng.com/deeplearning/objectdetection/目标检测之Fast-RCNN,Faster-RCNN解读/fig12.png" alt><br>如上图所示，一共有6个识别为人的框，每一个框有一个置信率。<br>现在需要消除多余的:<br>·按置信率排序: 0.95, 0.9, 0.9, 0.8, 0.7, 0.7<br>·取最大0.95的框为一个物体框<br>·剩余5个框中，去掉与0.95框重叠率IoU大于0.7(可以另行设置)，则保留0.9, 0.8, 0.7三个框<br>·重复上面的步骤，直到没有框了，0.9为一个框<br>·选出来的为: 0.95, 0.9</p>
</blockquote>
<h3 id="Classification"><a href="#Classification" class="headerlink" title="Classification"></a>Classification</h3><p>　　Classification部分利用已经获得的proposal feature maps，通过full connect层与softmax计算每个proposal具体属于那个类别（如人，车，电视等），输出cls_prob概率向量；同时再次利用bounding box regression获得每个proposal的位置偏移量bbox_pred，用于回归更加精确的目标检测框<br><img src="http://cdn.wangng.com/deeplearning/objectdetection/目标检测之Fast-RCNN,Faster-RCNN解读/fig13.png" alt><br>从RoI Pooling获取到7x7=49大小的proposal feature maps后，送入后续网络，可以看到做了如下2件事：<br>1.通过全连接和softmax对proposals进行分类，这实际上已经是识别的范畴了<br>2.再次对proposals进行bounding box regression，获取更高精度的rect box</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.robots.ox.ac.uk/~tvg/publications/talks/fast-rcnn-slides.pdf" target="_blank" rel="noopener">http://www.robots.ox.ac.uk/~tvg/publications/talks/fast-rcnn-slides.pdf</a><br><a href="https://blog.csdn.net/fengbingchun/article/details/87091740" target="_blank" rel="noopener">目标检测算法Fast R-CNN简介</a><br><a href="https://www.cnblogs.com/wangyong/p/8513563.html" target="_blank" rel="noopener">Faster RCNN 学习笔记</a><br><a href="https://zhuanlan.zhihu.com/p/31426458" target="_blank" rel="noopener">一文读懂Faster RCNN</a></p>
]]></content>
      <categories>
        <category>Deeplearning</category>
        <category>Object Detection</category>
      </categories>
      <tags>
        <tag>Object Detection</tag>
        <tag>Fast RCNN</tag>
        <tag>Faster RCNN</tag>
      </tags>
  </entry>
  <entry>
    <title>目标检测之IOU理解与实现</title>
    <url>/articles/b66d099a.html/</url>
    <content><![CDATA[<h3 id="IOU"><a href="#IOU" class="headerlink" title="IOU"></a>IOU</h3><p>　　IOU(Intersection over Union)即交并比，是目标检测中衡量目标检测算法准确度的一个重要指标，顾名思义，即交集与并集的比值，那所谓的交集和并集分别指代什么呢？</p>
<a id="more"></a>
<p><img src="/articles/b66d099a.html/iou.png" alt></p>
<p>　　目标检测是一个有监督学习的过程，它常常需要大量的有标签数据进行训练学习。目标检测实际要解决的问题有两个，一个是目标分类，还有一个就是目标定位，这里我把目标的位置信息也当作是一种标签，只不过这种标签是目标框的信息x,y,w,h，一般由人工标记。如上图所示，ground truth 所在的框就是一个目标真实label,而bounding box 就是目标检测算法预测的目标的label。如果两个框能完全重合，那么就说明目标检测算法预测结果完全正确，但通常这是不可能，目标框的预测实际是回归问题，回归问题的损失函数再怎么迭代更新，都不可能等于0。</p>
<p>　　上图所示就是所谓的IOU，它是目标所在的真实框(ground truth) 与算法预测的目标所在的框(bounding box)的交集与并集的比值。这个IOU由什么用呢？有时我们听别人作报告时，会听到IOU阈值这类的说法，我们会用IOU阈值来判定预测的bounding box是否有效。一般阈值会设定在0.5，当IOU的值大于等于0.5时，我们会把这个预测的bounding box 归为正类，而小于0.5的归为负类。再将正类的bounding box拿去回归训练。</p>
<h3 id="IOU的类型有以下几种"><a href="#IOU的类型有以下几种" class="headerlink" title="IOU的类型有以下几种"></a>IOU的类型有以下几种</h3><p><img src="/articles/b66d099a.html/iou2.png" alt></p>
<h3 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h3><p>　　如上图示，ground truth的坐标为（x0,y0,w0,h0)，bounding box的坐标分别为（x1,y1,w1,h1)，则交集和并集的大小为<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">W = w0+w1-(max((x0+w0),(x1+w1))-min(x0,x1))</span><br><span class="line">H = h0+h1-(max((y0+h0),(h1+h1))-min(y0,y1))</span><br><span class="line">Intersection = W*H</span><br><span class="line">Union = w0*h0 + w1*h1 -Intersection</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_iou</span><span class="params">(gt_box,b_box)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    计算iou</span></span><br><span class="line"><span class="string">    :param gt_box: ground truth gt_box = [x0,y0,x1,y1]（x0,y0)为左上角的坐标（x1,y1）为右下角的坐标</span></span><br><span class="line"><span class="string">    :param b_box: bounding box b_box 表示形式同上</span></span><br><span class="line"><span class="string">    :return: </span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    width0=gt_box[<span class="number">2</span>]-gt_box[<span class="number">0</span>]</span><br><span class="line">    height0 = gt_box[<span class="number">3</span>] - gt_box[<span class="number">1</span>]</span><br><span class="line">    width1 = b_box[<span class="number">2</span>] - b_box[<span class="number">0</span>]</span><br><span class="line">    height1 = b_box[<span class="number">3</span>] - b_box[<span class="number">1</span>]</span><br><span class="line">    max_x =max(gt_box[<span class="number">2</span>],b_box[<span class="number">2</span>])</span><br><span class="line">    min_x = min(gt_box[<span class="number">0</span>],b_box[<span class="number">0</span>])</span><br><span class="line">    width = width0 + width1 -(max_x-min_x)</span><br><span class="line">    max_y = max(gt_box[<span class="number">3</span>],b_box[<span class="number">3</span>])</span><br><span class="line">    min_y = min(gt_box[<span class="number">1</span>],b_box[<span class="number">1</span>])</span><br><span class="line">    height = height0 + height1 - (max_y - min_y)</span><br><span class="line"></span><br><span class="line">    interArea = width * height</span><br><span class="line">    boxAArea = width0 * height0</span><br><span class="line">    boxBArea = width1 * height1</span><br><span class="line">    iou = interArea / (boxAArea + boxBArea - interArea)</span><br><span class="line">    <span class="keyword">return</span> iou</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Deeplearning</category>
        <category>Object Detection</category>
      </categories>
      <tags>
        <tag>Object Detection</tag>
        <tag>IOU</tag>
      </tags>
  </entry>
  <entry>
    <title>目标检测之RCNN解读</title>
    <url>/articles/1db815e3.html/</url>
    <content><![CDATA[<p>论文:<a href="arxiv.org/pdf/1311.2524.pdf">Rich feature hierarchies for accurate object detection and semantic segmentation</a><br>代码:<a href="https://github.com/rbgirshick/rcnn" target="_blank" rel="noopener">matlab</a></p>
<a id="more"></a>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>　　RCNN是将深度学习引入目标检测领域的开篇之作,与AlexNet在图像分类领域的地位一样,RCNN对深度学习运用在目标检测领域的推动作用也是巨大的,使得深度学习用在目标检测领域成为常态。RCNN在目标检测数据集VOC2007上平均识别精度(map)相比传统方法从30.5%提升到了58.8%,这个提升是相当巨大的。RCNN的创新之处在于使用CNN提取的特征来进行分类和目标框的回归。</p>
<h3 id="网络模型分析"><a href="#网络模型分析" class="headerlink" title="网络模型分析"></a>网络模型分析</h3><h4 id="1-RCNN目标检测总览"><a href="#1-RCNN目标检测总览" class="headerlink" title="1.RCNN目标检测总览"></a>1.RCNN目标检测总览</h4><p><img src="/articles/1db815e3.html/fig1.png" alt><br>步骤如下:</p>
<ol>
<li>输入一张图片,使用区域建议(Selective Search)算法从这张图片中提取出约2000个候选目标框(region proposal)</li>
<li>将这2000个目标框进行统一缩放(Cut/Warp)送入到已经训练好的的CNN(AlexNet)网络提取固定长度(4096)的特征.</li>
<li>将提取的特征用SVM进行分类</li>
<li>用提取的特征进行线性回归来矫正bounding box</li>
</ol>
<h4 id="2-具体实现"><a href="#2-具体实现" class="headerlink" title="2.具体实现"></a>2.具体实现</h4><h5 id="2-1-Selective-Search算法"><a href="#2-1-Selective-Search算法" class="headerlink" title="2.1 Selective Search算法"></a>2.1 Selective Search算法</h5><p><img src="/articles/1db815e3.html/selective.png" alt><br>输入一张图片,物体的可能位置</p>
<ol>
<li>使用 Felzenszwalb and Huttenlocher提出的方法得到初始分割区域R={r1,r2,…,rn}；</li>
<li>初始化相似度集合S=∅；</li>
<li>计算两两相邻区域之间的相似度，将其添加到相似度集合S中；</li>
<li>从集合S中找出，相似度最大的两个区域 ri 和rj，将其合并成为一个区域 rt，从集合中删去原先与ri和rj相邻区域之间计算的相似度，计算rt与其相邻区域（与ri或rj相邻的区域）的相似度，将其结果加入到相似度集合S中。同时将新区域 rt 添加到区域集合R中；</li>
<li>获取每个区域的Bounding Boxes L，输出物体位置的可能结果L。</li>
</ol>
<table><tr>
<td><img src="/articles/1db815e3.html/s1.png" border="0"></td>
<td><img src="/articles/1db815e3.html/s2.png" border="0"></td>
</tr></table>

<p>相似性度量准则包括<strong>颜色相似度、纹理相似度、大小相似度和形状吻合相似度。</strong></p>
<h5 id="2-2-模型训练"><a href="#2-2-模型训练" class="headerlink" title="2.2 模型训练"></a>2.2 模型训练</h5><p>　　这里的CNN网络作者选择的是AlexNet,由于CNN训练需要大量的数据做支撑,此前的做法是用无监督方法先预训练模型参数,再用有监督方法在目标数据集微调.作者这里选择在大规模数据集ILSVRC(1000万张)先进行有监督预训练(1000类),然后在特定的小规模数据集VOC(1万张)上微调(20类)。</p>
<p>　　具体的,<strong>在微调训练，将region proposal与GT的IOU大于0.5的归为正样本,将IOU小于0.5的归为负样本,每个batch包含128个样本,其中有32个正样本,96个负样本(背景)</strong>。由于fc的存在,输入需要固定,所以将网络的输入(region proposal)需要缩放到固定大小227x227。RCNN的训练也是分步的,对于一张图片，使用训练好的CNN计算得到的feature map现存到到硬盘里面(这里一存，后面训练一取，非常耗费时间),然后送到SVM去分类.</p>
<h5 id="2-3-目标种类分类"><a href="#2-3-目标种类分类" class="headerlink" title="2.3 目标种类分类"></a>2.3 目标种类分类</h5><p><strong>训练</strong>:对于每个region proposal,经CNN网络计算后得到一个4096维长度的特征,然后送到线性分类器SVM中,SVM是一个二分类器,判断是否属于对应类别,它只能预测positve和negtive,。训练的时候SVM将IOU大于0.3作为正例,将IOU小于0.3的作为负例。</p>
<p><strong>预测:</strong> 在经过SVM分类后，会输出一堆的候选框得分,20个类,所以会得到(20000,20)个得分,这时候我们需要用的非极大值抑制得到想要的候选框了,以最高分的区域为基础，剔除掉那些重叠位置的区域。</p>
<h5 id="2-4-Bounding-box回归"><a href="#2-4-Bounding-box回归" class="headerlink" title="2.4 Bounding box回归"></a>2.4 Bounding box回归</h5><p>　　我们使用一个简单的bounding-box回归用于提高定位的表现。这个bbox回归应用在SVM分类器给每个候选区域打分后，bbox回归认为候选区域和ground-truth之间是线性关系(因为在最后从SVM内确定出来的区域比较接近ground-truth,这里近似认为可以线性关系)</p>
<h5 id="RCNN实际流程"><a href="#RCNN实际流程" class="headerlink" title="RCNN实际流程"></a>RCNN实际流程</h5><p><img src="/articles/1db815e3.html/fig2.png" alt></p>
<h3 id="RCNN存在的问题"><a href="#RCNN存在的问题" class="headerlink" title="RCNN存在的问题"></a>RCNN存在的问题</h3><ol>
<li>预测的时候每次都要提取2000个region proposal,然后分别由CNN提取特征(2000次CNN提取特征),再用SVM分类,这会造成大量时间的消耗</li>
<li>每次需要将region proposal 缩放到227x227,实际会造成信息的丢失问题</li>
<li>由于训练不是端到端的,对于分类和回归的参数梯度无法传递到前面参数中,无法充分利用更顶层的语义信息.<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3>1.<a href="https://arxiv.org/pdf/1311.2524.pdf" target="_blank" rel="noopener">RCNN</a><br>2.<a href="http://www.robots.ox.ac.uk/~tvg/publications/talks/fast-rcnn-slides.pdf" target="_blank" rel="noopener">http://www.robots.ox.ac.uk/~tvg/publications/talks/fast-rcnn-slides.pdf</a><br>3.<a href="https://blog.csdn.net/shenxiaolu1984/article/details/51066975" target="_blank" rel="noopener">RCNN算法详解</a></li>
</ol>
<p>　　</p>
]]></content>
      <categories>
        <category>Deeplearning</category>
        <category>Object Detection</category>
      </categories>
      <tags>
        <tag>Deeplearning</tag>
        <tag>Object Detection</tag>
        <tag>RCNN</tag>
      </tags>
  </entry>
  <entry>
    <title>目标检测之Map计算详解</title>
    <url>/articles/71e282d7.html/</url>
    <content><![CDATA[<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>　　Map—Mean Average Precision是目标检测算法的常用衡量标准,它是一个较为综合的评价指标,它能评估一个模型在某个数据集上的整体识别性能。<strong>Map它首先是AP(Average Precision)的一个平均值,这个AP其实数据集中每一类的识别准确率,将所有类别的AP相加除类别数就得到了Map</strong>。而每一类的AP又是由P-R(Precision-Recall)曲线所围面积计算得到,所以我们还得先计算机每类的准确率和召回率,准确率和召回率又与机器学习中True Postive,True Negtive,False Postive, False Negtive等有关,我们来一一解释目标检测中这个指标的含义:</p>
<a id="more"></a>
<h3 id="目标检测中正例和负例"><a href="#目标检测中正例和负例" class="headerlink" title="目标检测中正例和负例"></a>目标检测中正例和负例</h3><p>　　目标检测中的正负例是相对于目标框来说的,对于一张待检测图片,经模型预测输出后会得到许多带有置信度的目标框,而经nms操作后每个目标就对应一个框，如何判断这张图片的这些框是正例还是负例呢?在计算Map时会设定两个阈值,置信度(confidence)阈值和iou阈值。</p>
<font size="3" color="red">置信度(confidence)阈值被用来区分正例和负例,iou阈值被用来区分真假</font>

<p>　　置信度阈值的设定是用来判断目标是否存在,如对于一个目标框的置信度是0.9,我们有90%的判断这个目标存在,现在设定一个置信度阈值为0.6,我们把大于0.6的框判为正例,小于这个阈值的判为负例,也就是我们人为的认为大于0.6这个可能性的目标是存在,是可以被检测出来的,小于0.6我们认为这个目标不存在</p>
<p>　　iou阈值的设定是判断这个预测的目标框框的准不准的问题,iou的含义与计算可以参考<a href="https://wangng.com/articles/b66d099a.html/">目标检测之IOU理解与实现</a>,iou越大,代表框得越准。现在设定一个iou阈值0.5(voc数据集判断阈值),将大于iou阈值得定义为true,小于的定义为false.如将既大kuqa于置信度阈值又大于iou阈值的框称为true Postive,而正例中小于iou的称为False Postive(对于一个GTbox,对应多个检测框的时候,选择iou最大的那个框作为TP,其余的为FP),同时如果类别预测错的也当成是False Postive</p>
<h3 id="准确率和召回率"><a href="#准确率和召回率" class="headerlink" title="准确率和召回率"></a>准确率和召回率</h3><p><img src="/articles/71e282d7.html/fig2.png" alt><br>和图片分类不一样,这里TP,FP,FN等都是相对目标框来说的,而不是相对图片来说的</p>
<p><strong>准确率</strong>:在所有存在的目标框(正例)中,真正框对的目标框(真正例)的占比:</p>
<script type="math/tex; mode=display">
Precision = \frac{TP}{TP+FP}</script><p><strong>召回率</strong>:所有该类中的目标框(GT),被真确预测对的目标框的占比;</p>
<script type="math/tex; mode=display">
Recall = \frac{TP}{Tp+FN}</script><p>FN假负例,即该类中未被预测的目标,FN等于该类中所有的ground truth个数减去TP的个数</p>
<h3 id="AP的计算"><a href="#AP的计算" class="headerlink" title="AP的计算"></a>AP的计算</h3><p>　　前面已经计算了准确率和召回率，准确率、召回率和我们预先设定的置信度阈值和iou阈值有关,因此可以在给定不同阈值的情况下得到多个准确率、召回率,然后使用召回率为自变量,准确率为因变量,得到Precsion-Recall曲线,而该曲线所围面积即为某类的AP.<br>　　<br>　　正如前面所述，至少有两个变量会影响Precision和Recall，即IoU和置信度阈值。IoU是一个简单的几何度量，可以很容易标准化，比如在PASCAL VOC竞赛中采用的IoU阈值为0.5，而COCO竞赛中在计算mAP较复杂，其计算了一系列IoU阈值（0.05至0.95）下的mAP。但是置信度却在不同模型会差异较大，可能在我的模型中置信度采用0.5却等价于在其它模型中采用0.8置信度，这会导致precision-recall曲线变化。为此，PASCAL VOC组织者想到了一种方法来解决这个问题，即要采用一种可以用于任何模型的评估指标。在paper中，他们推荐使用如下方式计算Average Precision（AP）</p>
<p>　　可以看到，为了得到precision-recall曲线，首先要对模型预测结果进行排序(ranked output，按照各个预测值置信度降序排列)。那么给定一个rank，Recall和Precision仅在高于该rank值的预测结果中计算，改变rank值会改变recall值。这里共选择11个不同的recall([0, 0.1, …, 0.9, 1.0])，可以认为是选择了11个rank，由于按照置信度排序，所以实际上等于选择了11个不同的置信度阈值。那么，AP就定义为在这11个recall下precision的平均值，其可以表征整个precision-recall曲线（曲线下面积）。</p>
<script type="math/tex; mode=display">
A P=\frac{1}{11} \sum_{r \in\{0,0.1, \ldots, 1\}} p_{\text {interp}}(r)</script><p>而$p_{\text {interp}}(r)$的取值如下</p>
<script type="math/tex; mode=display">
p_{\text {interp}}(r)=\max _{\tilde{r} \cdot r \geq r} p(\tilde{r})</script><p>在VOC2010以前，只需要选取当Recall &gt;= 0, 0.1, 0.2, …, 1共11个点时的Precision最大值，然后AP就是这11个Precision的平均值。</p>
<p>在VOC2010及以后，需要针对每一个不同的Recall值（包括0和1），选取其大于等于这些Recall值时的Precision最大值，然后计算PR曲线下面积作为AP值。</p>
<h3 id="Map的计算示例"><a href="#Map的计算示例" class="headerlink" title="Map的计算示例"></a>Map的计算示例</h3><p>mAP计算示例,对于Aeroplane类别,我们网络有以下输出(BB表示BoundingBox序号,IoU&gt;0.5时GT=1)：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BB  | confidence | GT</span><br><span class="line">----------------------</span><br><span class="line">BB1 |  0.9       | 1</span><br><span class="line">----------------------</span><br><span class="line">BB2 |  0.9       | 1</span><br><span class="line">----------------------</span><br><span class="line">BB1 |  0.8       | 1</span><br><span class="line">----------------------</span><br><span class="line">BB3 |  0.7       | 0</span><br><span class="line">----------------------</span><br><span class="line">BB4 |  0.7       | 0</span><br><span class="line">----------------------</span><br><span class="line">BB5 |  0.7       | 1</span><br><span class="line">----------------------</span><br><span class="line">BB6 |  0.7       | 0</span><br><span class="line">----------------------</span><br><span class="line">BB7 |  0.7       | 0</span><br><span class="line">----------------------</span><br><span class="line">BB8 |  0.7       | 1</span><br><span class="line">----------------------</span><br><span class="line">BB9 |  0.7       | 1</span><br><span class="line">----------------------</span><br></pre></td></tr></table></figure></p>
<p>因此，我们有 TP=5 (BB1, BB2, BB5, BB8, BB9), FP=5 (重复检测到的BB1也算FP)。除了表里检测到的5个GT以外，我们还有2个GT没被检测到，因此: FN = 2. 这时我们就可以按照Confidence的顺序给出各处的PR值，如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rank&#x3D;1  precision&#x3D;1.00 and recall&#x3D;0.14</span><br><span class="line">----------</span><br><span class="line">rank&#x3D;2  precision&#x3D;1.00 and recall&#x3D;0.29</span><br><span class="line">----------</span><br><span class="line">rank&#x3D;3  precision&#x3D;0.66 and recall&#x3D;0.29</span><br><span class="line">----------</span><br><span class="line">rank&#x3D;4  precision&#x3D;0.50 and recall&#x3D;0.29</span><br><span class="line">----------</span><br><span class="line">rank&#x3D;5  precision&#x3D;0.40 and recall&#x3D;0.29</span><br><span class="line">----------</span><br><span class="line">rank&#x3D;6  precision&#x3D;0.50 and recall&#x3D;0.43</span><br><span class="line">----------</span><br><span class="line">rank&#x3D;7  precision&#x3D;0.43 and recall&#x3D;0.43</span><br><span class="line">----------</span><br><span class="line">rank&#x3D;8  precision&#x3D;0.38 and recall&#x3D;0.43</span><br><span class="line">----------</span><br><span class="line">rank&#x3D;9  precision&#x3D;0.44 and recall&#x3D;0.57</span><br><span class="line">----------</span><br><span class="line">rank&#x3D;10 precision&#x3D;0.50 and recall&#x3D;0.71</span><br><span class="line">----------</span><br></pre></td></tr></table></figure></p>
<p>　　对于上述PR值，如果我们采用：VOC2010之前的方法，我们选取Recall &gt;= 0, 0.1, …, 1的11处Percision的最大值：1, 1, 1, 0.5, 0.5, 0.5, 0.5, 0.5, 0, 0, 0。此时Aeroplane类别的 AP = 5.5 / 11 = 0.5</p>
<p>　　VOC2010及以后的方法，对于Recall &gt;= 0, 0.14, 0.29, 0.43, 0.57, 0.71, 1，我们选取此时Percision的最大值：1, 1, 1, 0.5, 0.5, 0.5, 0。此时Aeroplane类别的 AP = (0.14-0)<em>1 + (0.29-0.14)</em>1 + (0.43-0.29)<em>0.5 + (0.57-0.43)</em>0.5 + (0.71-0.57)<em>0.5 + (1-0.71)</em>0 = 0.5mAP就是对每一个类别都计算出AP然后再计算AP平均值就好了</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.zhihu.com/question/53405779" target="_blank" rel="noopener">https://www.zhihu.com/question/53405779</a></p>
]]></content>
      <categories>
        <category>Deeplearning</category>
        <category>Object Detection</category>
      </categories>
      <tags>
        <tag>Object Detection</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title>目标检测之ROI Pooling</title>
    <url>/articles/4a644d6f.html/</url>
    <content><![CDATA[<h3 id="ROI-Pooling"><a href="#ROI-Pooling" class="headerlink" title="ROI Pooling"></a>ROI Pooling</h3><p>　　ROI Pooling的作用是对不同大小的region proposal转换为固定的输出特征，即从最后卷积层输出的feature map提取大小固定的feature map。简单讲可以看做是SPPNet的简化版本，因为全连接层的输入需要大小一样，所以不能直接将不同大小的region proposal映射到feature map作为输出，需要做尺寸变换.</p>
<a id="more"></a>
<p><img src="/articles/4a644d6f.html/roipooling.png" alt></p>
<p>针对上图</p>
<p>1)Conv layers使用的是VGG16,feat_stride=32(即表示，经过网络层后图片缩小为原图的1/32),原图$800\times 800$,则最后一层特征图feature map大小为$25\times 25$</p>
<p>2)假定原图中有一region proposal，大小为$665\times665$，映射到特征图中的大小为$665/32=20.78$,即$20.78\times20.78$，而Caffe版本的Roi Pooling的C++源码，在计算的时候会进行取整操作，于是，进行所谓的第一次量化，即映射的特征图大小为$20\times20$</p>
<p>3)假定pooled_w=7,pooled_h=7,即pooling后固定成$7\times7$大小的特征图，所以，将上面在 feature map上映射的$20\times20$的 region  proposal划分成49个同等大小的小区域，每个小区域的大小$20/7=2.86$,即$2.86\times2.86$，此时，进行第二次量化，故小区域大小变成$2\times2$</p>
<p>4)每个$2\times2$的小区域里，取出其中最大的像素值，作为这一个区域的代表，这样，49个小区域就输出49个像素值，组成$7\times7$大小的feature map</p>
<p>总结，所以，通过上面可以看出，经过两次量化，即将浮点数取整，原本在特征图上映射的$20\times20$大小的region proposal，转换成大小为$7\times7$的.</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/wangyong/p/8523814.html" target="_blank" rel="noopener">RoIPooling、RoIAlign笔记</a></p>
]]></content>
      <categories>
        <category>Deeplearning</category>
        <category>Object Detection</category>
      </categories>
      <tags>
        <tag>Object Detection</tag>
        <tag>ROI Pooling</tag>
      </tags>
  </entry>
  <entry>
    <title>目标检测之SSD解读</title>
    <url>/articles/8c764809.html/</url>
    <content><![CDATA[<p>论文:<a href="https://arxiv.org/pdf/1512.02325.pdf" target="_blank" rel="noopener">SSD: Single Shot MultiBox Detector</a><br>代码:<a href="https://github.com/amdegroot/ssd.pytorch" target="_blank" rel="noopener">SSD_pytorch</a></p>
<a id="more"></a>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>　　SSD是经典的单阶段目标检测算法之一,发表于ECCV2016,它摒弃了二阶段检测算法中需要预先获得候选框的的步骤,直接在特征图中生成候选框,然后对候选框进行分类和回归定位.相比二阶段检测模型来说,检测速度得到大大的提升,识别精度甚至可以达到二阶段检测模型精度,而相比同是单阶段检测算法的yolo(v1)来说,识别精度和速度都有大幅提高.</p>
<h3 id="模型特点"><a href="#模型特点" class="headerlink" title="模型特点"></a>模型特点</h3><p>1.沿用了单阶段目标检测算法的yolo的思路,直接对输入图像中的目标进行分类和定位<br>2.使用了特征金字塔的多层级特征检测方法,在不同感受野对不同大小目标进行检测<br>3.借鉴了faster-RCNN的anchor机制,在feature map中每个位置中预设prior box</p>
<h3 id="网络模型分析"><a href="#网络模型分析" class="headerlink" title="网络模型分析"></a>网络模型分析</h3><p><img src="/articles/8c764809.html/fig1.png" alt></p>
<p>论文中提到了两种SSD结构，根据不同输入尺寸的图像,分为SSD300和SSD512,本文中以SSD300为例,特征提取层使用了VGG16的卷积层，并将VGG16的两个全连接层转换成了普通的卷积层(图中conv6和conv7)，之后又接了多个卷积(conv8_1，conv8_2，conv9_1，conv9_2，conv10_1，conv10_2)，最后用一个Global Average Pooling来变成1x1的输出(conv11_2)。</p>
<p>SSD为每个检测层都预定义了不同大小的先验框(Prior boxes), Conv4_3、Conv10_2和Conv11_2分别有4种先验框，而Conv7、Conv8_2和Conv9_2分别有6种先验框，即对应于特征图上的每个像素，都会生成K(prior box种类)个prior box.</p>
<p>网络6个检测层总共预测的边界框数目为8732$(38 \times 38 \times 4 + 19 \times 19 \times 6 + 10 \times 10 \times 6 + 5 \times 5 \times 6 + 3 \times 3 \times 4 + 1 \times 1 \times 4)$。</p>
<h4 id="SSD同时使用多个卷积层的输出来做分类和位置回归"><a href="#SSD同时使用多个卷积层的输出来做分类和位置回归" class="headerlink" title="SSD同时使用多个卷积层的输出来做分类和位置回归"></a>SSD同时使用多个卷积层的输出来做分类和位置回归</h4><p>从上图中可以看到YOLO只使用了最后一层的7x7数据来做回归，而SSD将conv4_3、conv7、conv8_2、conv9_2、conv10_2、conv11_2都连接到了最后的检测、分类层做回归。SSD这么做有什么好处呢？<br>要回答这个问题得先回顾下YOLO的结构，YOLO在训练时ground truth和bbox是一一对应的关系(ground truth对应到其中心位置所在区域中IOU最大的那个bbox来计算loss)，如果有两个ground truth的尺寸和位置都比较相近，就很有可能对应到同一个区域的同一个bbox，这种场景下必然会有一个目标无法识别。为了解决这个问题SSD的作者把YOLO的结构做了如下优化：</p>
<p>a、重新启用了Faster R-CNN中anchor的结构<br>在SSD中如果有多个ground truth，每个anchor(原文中称作default box，取名不同而已)会选择对应到IOU最大的那个ground truth。一个anchor只会对应一个ground truth，但一个ground truth都可以对应到大量anchor，这样无论两个ground truth靠的有多近，都不会出现YOLO中bbox冲突的情况。</p>
<p>b、同时使用多个层级上的anchor来进行回归<br>作者认为仅仅靠同一层上的多个anchor来回归，还远远不够。因为有很大可能这层上所有anchor的IOU都比较小，就是说所有anchor离ground truth都比较远，用这种anchor来训练误差会很大。例如图2中，左边较低的层级因为feature map尺寸比较大，anchor覆盖的范围就比较小，远小于ground truth的尺寸，所以这层上所有anchor对应的IOU都比较小；右边较高的层级因为feature map尺寸比较小，anchor覆盖的范围就比较大，远超过ground truth的尺寸，所以IOU也同样比较小；只有图2中间的anchor才有较大的IOU。通过同时对多个层级上的anchor计算IOU，就能找到与ground truth的尺寸、位置最接近(即IOU最大)的一批anchor，在训练时也就能达到最好的准确度。<br><img src="/articles/8c764809.html/fig2.png" alt></p>
<h4 id="先验框的匹配过程"><a href="#先验框的匹配过程" class="headerlink" title="先验框的匹配过程"></a>先验框的匹配过程</h4><p>在目标检测任务中，通常会生成大量的先验框，网络对于所有的先验框会生成对应的坐标偏移，那么网络在计算定位误差的时候，必须要知道每个先验框所对应的真实框。</p>
<p>匹配条件1，对于每个真实框，找到与之IOU最大的先验框，保证每个真实框都有一个先验框来负责检测它。正常来说，网络生成的先验框的数量是远远大于真实框的数量的，如果只根据策略1来进行匹配，大量的未与真实框相匹配的先验框，它们的标签都为背景，那么这将导致类别严重失衡。<br>这个时候，还需要第2个条件，对于剩余的未被匹配的先验框，如果有某个真实框与它的IOU大于某个阈值(一般取0.5)，也将该真实框与之匹配。正常情况下，每个真实框都会同时与多个先验框进行匹配，而每个先验框只能匹配一个真实框。匹配过程需先满足第一个条件，然后满足第二个条件。</p>
<p>即便每个真实框可与多个先验框同时匹配，但背景先验框的数量还是要明显大于物体先验框的数量。因此，论文中还使用了Hard negative mining的策略，按照先验框的类别置信度误差从高到低排序，只选择前top_k个先验框作为训练的背景先验框（背景先验框的采样），最终正负样本的比例约为1:3。</p>
<h4 id="anchor的选择"><a href="#anchor的选择" class="headerlink" title="anchor的选择"></a>anchor的选择</h4><p>下面来看下SSD选择anchor的方法。首先每个点都会有一大一小两个正方形的anchor，小方形的边长用min_size来表示，大方形的边长用sqrt(min_size*max_size)来表示(min_size与max_size的值每一层都不同)。同时还有多个长方形的anchor，长方形anchor的数目在不同层级会有差异，他们的长宽可以用下面的公式来表达，ratio的数目就决定了某层上每一个点对应的长方形anchor的数目：</p>
<script type="math/tex; mode=display">
\begin{array}{l}
\text {width}=\sqrt{\text {ratio}} * \min \text { size} \\
\text {height}=1 / \sqrt{\text {ratio}} * \min _{-} \text {size}
\end{array}\tag{1}</script><p>上面的min_size和max_size由公式2计算得到.前面已经提到6个特征图层需要参与回归的,这6个特征图的尺寸分别为(38, 19, 10, 5, 3, 1)</p>
<script type="math/tex; mode=display">
s_{k}=s_{\min }+\frac{s_{\max }-s_{\min }}{m-1}(k-1), \quad k \in[1, m]\tag{2}</script><p>m表示特征图的个数，m=6(不包括Conv4_3),Sk表示先验框大小和图片大小的比例，Smin表示最小比例，设为0.2，Smax表示最大比例，设为0.9 。对于第一个特征图Conv4_3，比例单独设置为Smin=Smin/2 = 0.1，其对应大小为300 * 0.1 = 30。对于之后的特征图，先验框的大小按照上面的公式线性增加</p>
<p>对于conv-7：k=2,min_size = S1x300,max_size = S2x300<br>….<br><img src="/articles/8c764809.html/fig4.png" alt></p>
<p>注：以上是作者论文中给的计算各层anchor尺寸的方法，但在作者源码中给的计算anchor方法有点差异，没有和论文的方法完全对应上。<br>SSD的基本配置文件<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">voc = &#123;</span><br><span class="line">    <span class="string">'num_classes'</span>: <span class="number">21</span>,</span><br><span class="line">    <span class="string">'lr_steps'</span>: (<span class="number">80000</span>, <span class="number">100000</span>, <span class="number">120000</span>),</span><br><span class="line">    <span class="string">'max_iter'</span>: <span class="number">120000</span>,</span><br><span class="line">    <span class="string">'feature_maps'</span>: [<span class="number">38</span>, <span class="number">19</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>],</span><br><span class="line">    <span class="string">'min_dim'</span>: <span class="number">300</span>,</span><br><span class="line">    <span class="string">'steps'</span>: [<span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">100</span>, <span class="number">300</span>],</span><br><span class="line">    <span class="string">'min_sizes'</span>: [<span class="number">30</span>, <span class="number">60</span>, <span class="number">111</span>, <span class="number">162</span>, <span class="number">213</span>, <span class="number">264</span>],</span><br><span class="line">    <span class="string">'max_sizes'</span>: [<span class="number">60</span>, <span class="number">111</span>, <span class="number">162</span>, <span class="number">213</span>, <span class="number">264</span>, <span class="number">315</span>],</span><br><span class="line">    <span class="string">'aspect_ratios'</span>: [[<span class="number">2</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">2</span>], [<span class="number">2</span>]],</span><br><span class="line">    <span class="string">'variance'</span>: [<span class="number">0.1</span>, <span class="number">0.2</span>],</span><br><span class="line">    <span class="string">'clip'</span>: <span class="literal">True</span>,</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'VOC'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h4><script type="math/tex; mode=display">
L(x, c, l, g)=\frac{1}{N}\left(L_{c o n f}(x, c)+\alpha L_{l o c}(x, l, g)\right)\tag{3}</script><p>对于SSD，虽然paper中指出采用了所谓的“multibox loss”，但是依然可以清晰看到SSD loss分为了confidence loss和location loss(bouding box regression loss)两部分，其中N是match到GT（Ground Truth）的prior box数量；而α参数用于调整confidence loss和location loss之间的比例，默认α=1。SSD中的confidence loss是典型的softmax loss：</p>
<script type="math/tex; mode=display">
L_{c o n f}(x, c)=-\sum_{i \in P o s}^{N} x_{i j}^{p} \log \left(\hat{c}_{i}^{p}\right)-\sum_{i \in N e g} \log \left(\hat{c}_{i}^{0}\right) \quad \text { where } \quad \hat{c}_{i}^{p}=\frac{\exp \left(c_{i}^{p}\right)}{\sum_{p} \exp \left(c_{i}^{p}\right)}\tag{4}</script><p>这里$x_{i j}^{p}$得取值为(0,1),表示第i个prior box与第j个类别是p的GT是否匹配,location loss:</p>
<script type="math/tex; mode=display">
\begin{aligned}
L_{l o c}(x, l, g)=\sum_{i \in P o s}^{N} \sum_{m \in\{c x, c y, w, h\}} x_{i j}^{k} \operatorname{smooth}_{L 1}\left(l_{i}^{m}-\hat{g}_{j}^{m}\right) \\
\\\hat{g}_{j}^{c x}=\left(g_{j}^{c x}-d_{i}^{c x}\right) / d_{i}^{w} ,\hat{g}_{j}^{c y}=\left(g_{j}^{c y}-d_{i}^{c y}\right) / d_{i}^{h} \\
\hat{g}_{j}^{w}=\log \left(\frac{g_{j}^{w}}{d_{i}^{w}}\right) ,\hat{g}_{j}^{h}=\log \left(\frac{g_{j}^{h}}{d_{i}^{h}}\right)
\end{aligned}</script><p>l为预测坐标，d为先验框，g为GT框</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>SSD网络的关键在于MultiBox detection, 多个特征图多尺度检测。之后的Yolov3中同样借鉴了这个思路。同时它还使用了更多的精心挑选的先验框(共8732个），让网络的的检测效果更好。SSD对小目标的检测效果之所以不太好，主要原因可能在于，大的特征图负责检测小物体，小的特征图负责检测大的物体，大的特征图具有更多的位置信息，但缺少足够的语义信息，而小的特征图具有更多的语义信息，却因为不断的下采样丢失了大量的位置信息。之后的Yolov3在借鉴SSD多尺度多框思路的同时，也利用了跳过连接，融合高分辨率的特征图和包含更多语义信息的特征图，从而更好的定位。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://arxiv.org/pdf/1512.02325.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1512.02325.pdf</a><br><a href="https://www.jianshu.com/p/0903b160d554" target="_blank" rel="noopener">https://www.jianshu.com/p/0903b160d554</a><br><a href="zhuanlan.zhihu.com/p/31427288">zhuanlan.zhihu.com/p/31427288</a><br><a href="https://segmentfault.com/a/1190000021845972" target="_blank" rel="noopener">https://segmentfault.com/a/1190000021845972</a></p>
]]></content>
      <categories>
        <category>Deeplearning</category>
        <category>Object Detection</category>
      </categories>
      <tags>
        <tag>Object Detection</tag>
        <tag>SSD</tag>
      </tags>
  </entry>
  <entry>
    <title>胶囊神经网络</title>
    <url>/articles/5d654916.html/</url>
    <content><![CDATA[<h3 id="CNN的缺陷"><a href="#CNN的缺陷" class="headerlink" title="CNN的缺陷"></a>CNN的缺陷</h3><p>&ensp;&ensp;CNN中，每个卷积核就是一个filter，卷积的操作是在图片中与对应位置相乘后求和，其实就是求相关性，filter就是需要匹配的模板，各种filter具有不同的作用，有的对边缘敏感，有的对颜色敏感。每个神经元包含很多个filter，以用来检测特定的feature。如图1所示，如果神经元检测到图片中包含很多黄色块，神经元就会很敏感。</p>
<a id="more"></a>
<p><img src="http://cdn.wangng.com/Deeplearning/胶囊神经网络/校车示例.png" alt="图1校车示例"><br><img src="http://cdn.wangng.com/Deeplearning/胶囊神经网络/曲线示例.png" alt="图2曲线示例"><br>&ensp;&ensp;假设这里有一个卷积核（左图），除了曲线轨迹上的值很大，其他的值都是零，所以这个卷积核对旁边这种曲线（右图）就有很高的输出，也就是说对这种曲线有很高的识别，而对其他的曲线类型输出就低。<br>&ensp;&ensp;所以如图像分类中，一旦卷积核检测到了类似于眼睛啊、鼻子啊、嘴巴这种特征；从数学角度上说就，相关卷积核对鼻子、眼睛等卷积出来的值很大，那么与人脸相关的神经元就相当兴奋，最后将图像分类到人脸这一类。所以这就导致了一个问题。如下图3，，右边那张眼睛、鼻子、嘴巴都有了，当然我们的CNN也相当兴奋的将它归于人脸。<br><img src="http://cdn.wangng.com/Deeplearning/胶囊神经网络/人脸示例.png" alt="图3人脸示例"><br><img src="http://cdn.wangng.com/Deeplearning/胶囊神经网络/人像示例.png" alt="图4人像示例"><br>&ensp;&ensp;上面的图4例所示，当仅仅改变Kim Kardashian的图片方向，预测的准确度就会大幅下降。右边的图片，我们能很容易地看出来一只眼睛和她的嘴巴都放在错误的位置，这不是一个人该有的模样。然而，我们却看到这张图是被预测为是人的可能性是0.9。一个被训练地很好的CNN模型在这个方法上会有一些问题。除了很容易地被特征被放置在错误位置的图片欺骗，对于不同方向的图片，CNN模型也很容易辨认不明。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>&ensp;&ensp;重新审视CNN的工作方式，高层特征是底层特征的加权和，前一层的激活与下一层神经元的权重相乘并相加，接着通过非线性激活函数进行激活，在这一个框架中，高层特征与底层特征的位置关系变得模糊，而CNN解决这一问题的方式是最大池化或卷积层扩大后续卷积核的感受野。<br>&ensp;&ensp;Hinton提出，保留对象部件之间的分层位姿关系对于正确分类和辨识对象来说很重要，胶囊网络结合了对象之间的相对关系，在数值中表示为4维位姿矩阵，当模型有了位姿信息后，它可以很容易的理解它看到的是以前看到的东西，只是改变了视角而已，如下图5所示，人眼可以很容易分辨出是自由女神像，只是角度的不同，但CNN却很难做到，而把位姿信息集合进去的胶囊神经网络，是可以判别出是自由女神像的不同角度。<br><img src="http://cdn.wangng.com/Deeplearning/胶囊神经网络/自由女神像.png" alt="图5自由女神像"></p>
<p><strong>CNN存在的问题</strong><br>1.CNN要么需要大量图片来训练，要么需要复用训练好的CNN网络来填充当前网络的某些层<br>2.对于元素丰富的图片，CNN不能很好的处理某些模棱两可的边界。<br>3.CNN在池化层，会丢失大量信息。池化层降低了空间分辨率，所以它们的输出对于输入的小变化是不敏感的。</p>
<h3 id="胶囊神经网络"><a href="#胶囊神经网络" class="headerlink" title="胶囊神经网络"></a>胶囊神经网络</h3><p><img src="http://cdn.wangng.com/Deeplearning/胶囊神经网络/胶囊神经网络.png" alt="图6胶囊神经网络"><br>&ensp;&ensp;所谓胶囊，就是一个向量，它可包含任意个值，每个值代表了当前需要识别的物体（比如图片）的一个特征。结合之前对传统CNN的学习，我们知道，卷积层的每个值，都是上一层某一块区域和卷积核完成卷积操作，即线性加权求和的结果，它只有一个值，所以是标量。而我们的胶囊网络，它的每一个值都是向量，也就是说，这个向量不仅可表示物体的特征、还可以包括物体的方向、状态等等。从上图，我们可以看到，输入是一张手写字的图片。首先对这张图片做了常规的卷积操作，得到ReLU Conv1；然后再对ReLU Conv1做卷积操作，并将其调整成适用于CapsNet的向量神经元层PrimaryCaps。<br>&ensp;&ensp;而第二层(PrimaryCaps)才是真正开始使用Capsul的层，但这层跟它的低一层，也就是上面说的conv layer之间，却并未使用routing算法。这层才是真正为了做routing而准备的。我们先来看下，如果在第一层的输出上做常规的32 channel, 9x9 kernel size和strides 2的CNN，结果是怎么样的呢？事实上我们将得到一个6x6x32的输出，或者说是6x6x1x32的输出（这个1不是随便加的，下面有作用）,如图7<br><img src="http://cdn.wangng.com/Deeplearning/胶囊神经网络/图7.png" alt="图7"><br>&ensp;&ensp;将这个图与原文的图6对比可以看出，原本convolution每次的计算输出是一个scalar value，现在到了PrimaryCaps这里成了一个长度为8的vector，也就是从6x6x1x32到了6x6x8x32（这里1就起作用了，从1到8的转变，也就是从标量向矢量的变化）。这是怎么做到的呢？按照我的理解，其实可以看作第二层在第一层的输出上用8个不同的conv2d层做了共8次32channel,9x9 kernel size和strides 2的卷积（每个conv2d分别一次），如下图(2)所示，每次都得到一个6x6x1x32的输出，共8个，再把这些输出在6x6x1x32的第三个纬度上concatenate,就得到了第二层最终的输出：6x6x8x32大小的高维矩阵，如图8所示。<br><img src="http://cdn.wangng.com/Deeplearning/胶囊神经网络/图8.png" alt="图8"><br>PrimaryCaps到DigitCaps层的传播也就是CapsNet和以往CNN操作的最大区别，本文的提出的算法：动态路由算法，也就运用在这一过程之中，这两层的连接类似于全连接，将32x6x6个维度为8(维度为1的神经元变成维度为8)的胶囊神经元与10个维度为16(维度为1的神经元变成维度为16)的胶囊神经元进行全连接。</p>
<h4 id="动态路由算法"><a href="#动态路由算法" class="headerlink" title="动态路由算法"></a>动态路由算法</h4><p><img src="http://cdn.wangng.com/Deeplearning/胶囊神经网络/动态路由.png" alt="图9"></p>
<p><strong>网络连接方式</strong><br>胶囊网络(PrimaryCaps到DigitCaps)和全连接网络的连接方式一模一样。前一层每一个胶囊神经单元都会和后一层每一个胶囊神经单元相连。<br><strong>网络输入</strong><br>全连接神经网络的输入即线性加权求和，胶囊网络很类似，但是它在线性求和阶段上多加了一个耦合系数C。胶囊网络的输入S由下面公式得到：  </p>
<p>$S<em>{j}=\sum</em>{i} c<em>{i j} \hat{u}</em>{j / i}$     （1）</p>
<p>$\hat{u}<em>{j | i}=W</em>{i j} u_{i}$              （2）</p>
<p>其中$u$是上一层胶囊网络的输出，$W$是每个输出要乘的权值，可以看作上一层每一个胶囊神经元以不同强弱的连接输出到后一层的某一个神经元。C根据下面公式计算：  </p>
<p>$c<em>{i j}=\frac{\exp \left(b</em>{i j}\right)}{\sum<em>{k} \exp \left(b</em>{i k}\right)}$ (3)</p>
<p>C叫做耦合系数。为了求C我们必须先求b，b根据下面公式计算： </p>
<p>$b<em>{i j} \leftarrow b</em>{i j}+\hat{u}<em>{j | i} \cdot v</em>{j}$         (4)</p>
<p>b初始值为0。故在前向传播求S的过程中，我们把W设计成随机值，b初始化为0可以得到C，u就是上一层胶囊网络的输出，有了三这个值，我们就可以得到下一层的S。<br><strong>激活函数</strong><br>在全连接神经网络中，我们选择的激活函数通常为：sigmoid, tanh等。但在胶囊网络中，Hinton构造了新的激活函数Squashing，故输出V的计算如下图所示:  </p>
<p>$\mathrm{v}<em>{j}=\frac{\left|s</em>{j}\right|^{2}}{1+\left|s<em>{j}\right|^{2}} \frac{s</em>{j}}{\left|s_{j}\right|}$  (5)  </p>
<p>该激活函数前一部分是输入输入向量S的缩放尺度，后一部分是S的单位向量。该激活函数既保留了输入输入向量的方向，又将输入向量的模压缩到[0, 1]之间。<br>除了耦合系数C是通过动态路由更新的，整个网络其他的卷积参数和Capusle内的W都需要根据损失函数进行更新。在原论文中，作者采用SVM中常用的Margin Loss，表达式如下:</p>
<p>$L<em>{c}=T</em>{c} \max \left(0, m^{+}-\left|\mathbf{v}<em>{c}\right|\right)^{2}+\lambda\left(1-T</em>{c}\right) \max \left(0,\left|<em>{\mathbf{V}</em>{c}}\right|-m^{-}\right)^{2}$                     (6) </p>
<p>$T_{c}$的值为0或1,$m^{+}=0.9$为上margin,惩罚假阴性（没有预测到存在的分类的情况), $m^{-}=0.1$为下margin，惩罚假阳性（预测到不存在的分类的情况），分别对应于用于增加类内相似度和减小类间相似度的正和负边距，$\lambda$是一个常数，为0.5,第一个式子Tc意味着gt中有的类，你要预测出来，没有预测出来要惩罚，第一个式子意味着gt中没有的类，你不能预测出来，预测出来了要惩罚.</p>
<h3 id="胶囊网络总结"><a href="#胶囊网络总结" class="headerlink" title="胶囊网络总结"></a>胶囊网络总结</h3><p>&ensp;&ensp;胶囊网络也是一种神经网络，与普通神经网络的区别是胶囊网络的神经元是一个向量（一组值）而不是一个标量（单个值），其神经元叫做向量神经元（vector neuron）。向量神经元中的每个值表示某一个属性，如姿态（位置、大小、方向），形变，速度，颜色，纹理结构等。<br>&ensp;&ensp;向量神经元还有一个特殊的属性，其值由向量长度来表示，即神经元所表示的实例存在的概率。说明向量长度在[0,1]区间内。这样，各个属性构成了向量神经元的方向，而实例存在的概率构成向量神经元的长度。<br>&ensp;&ensp;下图是标量神经元（普通神经元）与向量神经元的前向传播过程<br><img src="http://cdn.wangng.com/Deeplearning/胶囊神经网络/神经元传播.png" alt="图10神经元传播"></p>
<ul>
<li>标量神经元前向传播过程：<br>1.将输入标量 x 乘上权重 w<br>2.对加权的输入标量求和成标量 a<br>3.用非线性函数将标量 a 转化成标量 h</li>
<li>向量神经元前向传播过程：<br>1.将输入向量 u 与矩阵 W 相乘得到新的输入向量 U<br>2.将输入向量 U 乘上权重 c<br>3.对加权的输入向量求和成向量 s<br>4.用非线性函数将向量 s 转化成向量 v</li>
<li><strong>优点</strong></li>
</ul>
<ol>
<li>处理较小的数据集时，效果非常好（例如MNIST）</li>
<li>更易于解释鲁棒图像</li>
<li>保留所有信息（pose、texture、location等）</li>
</ol>
<ul>
<li><strong>缺点</strong></li>
</ul>
<ol>
<li>处理较大的数据集时，效果较差（例如CIFAR10)</li>
<li>路由协议算法需要更多计算时间（在全连接中针对向量计算）</li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/godwriter/article/details/79216404" target="_blank" rel="noopener">CapsNet——胶囊网络原理</a><br><a href="https://www.zhihu.com/question/67287444/answer/251460831" target="_blank" rel="noopener">云梦居客</a><br>[搜狐]<a href="https://www.sohu.com/a/226611009_633698" target="_blank" rel="noopener">https://www.sohu.com/a/226611009_633698</a><br><a href="https://blog.csdn.net/luoxuexiong/article/details/88601440" target="_blank" rel="noopener">胶囊网络（CapsulesNet）理解</a></p>
]]></content>
      <categories>
        <category>Deeplearning</category>
        <category>Capsnet</category>
      </categories>
      <tags>
        <tag>Deeplearning</tag>
        <tag>Capsnet</tag>
      </tags>
  </entry>
  <entry>
    <title>目标跟踪之SiamFC:基于全卷积孪生网络的目标跟踪</title>
    <url>/articles/fae94215.html/</url>
    <content><![CDATA[<p>论文：<a href="https://arxiv.org/pdf/1606.09549.pdf" target="_blank" rel="noopener">Fully-Convolutional Siamese Networks for Object Tracking</a><br>代码：<a href="https://github.com/bertinetto/siamese-fc" target="_blank" rel="noopener">github</a></p>
<h3 id="背景简介"><a href="#背景简介" class="headerlink" title="背景简介"></a>背景简介</h3><p><img src="/articles/fae94215.html/track.gif" alt><br>　　目标跟踪是计算机视觉中一个非常重要的研究方向，它的应用领域包括自动驾驶,人机交互,视频监控等。目标(单目标)跟踪任务就是在给定某视频序列初始帧的目标大小与位置的情况下，预测后续帧中该目标的大小与位置。这一基本任务流程可以按如下的框架划分：</p>
<a id="more"></a>
<p><img src="/articles/fae94215.html/tracking.png" alt><br>输入初始化目标框，在下一帧中产生众多候选框（Motion Model），提取这些候选框的特征（Feature Extractor），然后对这些候选框评分（Observation Model），最后在这些评分中找一个得分最高的候选框作为预测的目标（Prediction A），或者对多个预测值进行融合（Ensemble）得到更优的预测目标。<br><img src="/articles/fae94215.html/Tracker_development.png" alt><br>　　当前目标跟踪算法的发展方向主要有两个方向,一个是基于相关滤波(Correlation Filter),一个是基于深度学习,其中基于相关滤波的以KCF为代表,在线更新模型,在线跟踪,优点是速度快,缺点是跟踪效果不稳定,另一个是基于数据驱动的深度学习方法,优点是跟踪效果好,缺点是速度没有相关滤波快.而最近以孪生网络为代表的目标跟踪算法,不仅跟踪效果好,而且速度也很快,这里先介绍第一篇基于孪生网络的目标跟踪算法SiamFC</p>
<h3 id="模型分析"><a href="#模型分析" class="headerlink" title="模型分析"></a>模型分析</h3><h4 id="算法流程介绍"><a href="#算法流程介绍" class="headerlink" title="算法流程介绍"></a>算法流程介绍</h4><p><img src="/articles/fae94215.html/fig1.png" alt><br>　　如上图就是SiamFC的基本框架图,该模型需要两个输入,一个是模板图z,大小是(127x127x3),相当于需要跟踪的目标,另一个就是搜索图x,大小是(255x255x3),一般模板图就是待预测视频的第一帧,而搜索图则为从第二帧开始后的视频帧。两个输入经过相同的操作$\varphi$(孪生结构),这里的$\varphi$操作是使用AlexNet进行特征提取,分别得到一个大小是(6x6x128)和一个(22x22x128)的特征图,然后对求得的两个feature map进行相似性度量(求卷积),相当于以(6x6x128)作为卷积核,(22x22x128)作为输入图像,最终得到一个相似度响应图.把响应值高的作为是预测目标的中心.如上图红点对应红色的区域,蓝色的点表示蓝色的区域</p>
<h4 id="算法理论分析"><a href="#算法理论分析" class="headerlink" title="算法理论分析"></a>算法理论分析</h4><p>　　算法本身是比较搜索区域与目标模板的相似度，最后得到搜索区域的score map。其实从原理上来说，这种方法和相关滤波的方法很相似。其在搜索区域中逐个的与目标模板进行匹配，将这种逐点平移匹配计算相似度的方法看成是一种卷积，然后在卷积结果中找到相似度值最大的点，作为新的目标的中心。这里作者使用互相关层来计算他们的相似性</p>
<script type="math/tex; mode=display">
f(z, x)=\varphi(z) * \varphi(x)+b \mathbb{1}\tag{1}</script><p>这里的b1表示每个位置的取值,$*$表示卷积操作.跟踪时以上一帧目标位置为中心的搜索图像来计算响应得分图，将得分最大的位置乘以步长即可得到当前目标的位置。</p>
<blockquote>
<p>这里其实就是卷积的基本形式,卷积从数学角度来看其实就是互相关运算,这里的$\varphi(z)$就是所谓的卷积核(滤波器,滑窗),$\varphi(x)$就是待求互相关的输入,b就是偏置,上式可以抽象成$f=wx+b$,只不过输入输出都是多维的</p>
</blockquote>
<h4 id="输入数据实操"><a href="#输入数据实操" class="headerlink" title="输入数据实操"></a>输入数据实操</h4><p><img src="/articles/fae94215.html/fig2.png" alt><br>如图,图片都来自同一视频,第一行是模板图片,红色框为目标的GT box,第二行是搜索图片,红色框为预测的匹配结果,对于GT box,它所在的位置为(x,y,w,h),那么我们需要把这个目标框设定为固定大小(127x127),该怎么设置呢</p>
<script type="math/tex; mode=display">
s(w+2p) \times s(h+2p)=A\tag{2}</script><p>这里w,h为目标框的宽高,A为预设的模板大小127,p为上下文间隔,s为放缩的尺度因子,其中上下文间隔p等于:</p>
<script type="math/tex; mode=display">
p=(w+h) / 4\tag{3}</script><p>代码中实际是GT框的宽和高加上下文间隔p后直接resize成127x127,而对于搜索图片,在实际跟踪过程中,搜索图并不是直接resize成255x255的大小,而在前一帧预测的bounding box的中心进行裁剪,裁剪为255x255的图片作为搜索图.为了解决目标大小可能发生变化,作者设定了多个尺度进行搜索,对目标进行5种尺度来搜索(1.025^{(−2,−1,0,1,2)}),另外,作者并没有将输出为17x17的score map映射会255x255,而是使用双三次插值映射到272x272的大小,相对于映射到255x255,映射到272x272的定位更精准.</p>
<h4 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h4><p>本文作者采用的是logistic损失函数:</p>
<script type="math/tex; mode=display">
\ell(y, v)=\log (1+\exp (-y v))\tag{4}</script><p>y∈(+1,−1)表示实际标签,v表示score map中每个点的值</p>
<script type="math/tex; mode=display">
L(y, v)=\frac{1}{|D|} \sum_{u \in D} \ell(y[u], v[u])\tag{5}</script><p>u为输出D(score map)中的值,|D|为D的大小,$y[u]$为真值,其定义如下</p>
<script type="math/tex; mode=display">
y[u]=\left\{\begin{array}{ll}
+1 & \text { if } k|| u-c|| \leq R \\
-1 & \text { otherwise }
\end{array}\right.\tag{6}</script><p>这里的c是实际GTbox中的中心点,k为卷积降采样的步长,这里以欧式距离来度量搜索的目标中心与实际目标中心的匹配程度,如果该距离小于R,说明匹配成功,是正样本,否则匹配不成功,为负样本.<br>优化目标为:</p>
<script type="math/tex; mode=display">
\arg \min _{\theta} E_{(z, x, y)} L(y, f(z, x ; \theta))\tag{7}</script><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p><img src="/articles/fae94215.html/result.png" alt></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/jjwu/p/8512730.html" target="_blank" rel="noopener">目标跟踪简介</a></p>
]]></content>
      <categories>
        <category>Deeplearning</category>
        <category>Object tracking</category>
      </categories>
      <tags>
        <tag>Object tracking</tag>
        <tag>SiamFC</tag>
      </tags>
  </entry>
  <entry>
    <title>轻量模型之MobileNetV1</title>
    <url>/articles/b9a7760c.html/</url>
    <content><![CDATA[<p><strong>MobileNets(V1): Efficient Convolutional Neural Networks for Mobile Vision Applications</strong></p>
<p>期刊：CVPR2017<br>论文：<a href="https://arxiv.org/abs/1704.04861" target="_blank" rel="noopener">https://arxiv.org/abs/1704.04861</a><br>代码地址：<a href="https://github.com/shicai/MobileNet-Caffe" target="_blank" rel="noopener">github</a></p>
<a id="more"></a>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>​        从文章标题就可以看出，MobileNet(V1)的提出就是针对手机这种可移动的嵌入式设别的。作者提出使用深度可分离卷积( Depthwise Separable Convolutions)来构造模型，深度可分离卷积又有(Depthwise Convolution)和(Pointwise Convolutions)组成，并且还引入了两个可调参数来进一步控制模型大小，这使得MobileNet(V1)既能兼顾模型小也不兼顾速度快,MobileNet在轻量模型中达到了sota水平。</p>
<h3 id="网络模型分析"><a href="#网络模型分析" class="headerlink" title="网络模型分析"></a>网络模型分析</h3><h4 id="分组卷积"><a href="#分组卷积" class="headerlink" title="分组卷积"></a>分组卷积</h4><p>　　提到分组卷积，我们最开始应该想到是大名鼎鼎的AlexNet，AlexNet最先用到了分组卷积，由于计算资源的有限，它将网络分成两部分，从而能够在两个GPU上并行运行。如图所示：</p>
<p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之MobileNetV1/分组卷积.png" alt></p>
<p>分组卷积的具体操作</p>
<p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之MobileNetV1/分组卷积2.png" alt></p>
<p>　　左边的是常规的卷积，右边就是分组卷积。它把输入的特征图分成了几个组,然后各个组分别进行常规的卷积，将分组卷积后得到的特征图进行concat拼接,最后得到新的特征图。</p>
<ul>
<li><p>常规卷积vs分组卷积</p>
<p>　　就以上面的图为例，假设输入特征图的大小是$H\times W\times N$,卷积核的数量大小是$M\times k\times k\times N$,输出的特征图$H\times W\times M$,另外假设分组大小是s组。</p>
<p>1.常规卷积</p>
<p>params = $M\times k\times k\times N$,  FLOPs = $M\times k\times k\times N\times H\times W$</p>
<p>2.分组卷积s</p>
<p>params = $(M/s)\times k\times k\times (N/s)\times s$,  FLOPs = $(M/s)\times k\times k\times (N/s)\times H\times W\times s$</p>
<p>比较两组卷积方式，分组卷积的计算量和参数量都是常规卷积的1/s倍</p>
</li>
</ul>
<h4 id="Depthwise-卷积"><a href="#Depthwise-卷积" class="headerlink" title="Depthwise 卷积"></a>Depthwise 卷积</h4><p>　　Depthwise 卷积是分组卷积的极端情况，也就是将分组数设成是$C<em>{in}$，此时$C</em>{in}$和$C_{out}$也是相等的。</p>
<p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之MobileNetV1/depthwise.png" alt></p>
<h6 id="Pointwise-卷积"><a href="#Pointwise-卷积" class="headerlink" title="Pointwise 卷积"></a>Pointwise 卷积</h6><p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之MobileNetV1/pointwise.png" alt></p>
<p>pointwse卷积参数量和计算量：</p>
<p>params = $M\times 1\times 1\times N$   FLOPs = $M\times 1\times 1\times N\times H\times W$，pointwise卷积是常规卷积的$\frac{1}{K^2}$</p>
<h4 id="深度可分离卷积"><a href="#深度可分离卷积" class="headerlink" title="深度可分离卷积"></a>深度可分离卷积</h4><p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之MobileNetV1/深度可分离卷积.png" alt></p>
<p>深度可分离卷积</p>
<p>params = $M\times k\times k+M\times 1\times 1\times N$</p>
<p>FLOPs = $(M\times k\times k+M\times 1\times 1\times N)\times H\times W$</p>
<p>和常规卷积相比，参数量和计算量都减少到了$\frac{1}{N}+\frac{1}{k^2}$倍。</p>
<h6 id="Depthwise-Separable-Convolutions-Layer"><a href="#Depthwise-Separable-Convolutions-Layer" class="headerlink" title="Depthwise Separable Convolutions Layer"></a>Depthwise Separable Convolutions Layer</h6><p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之MobileNetV1/mobilenet1module.png" alt></p>
<p>　　作图是一个标准卷积层，右图就是深度可分离卷积层。首先使用3x3卷积提取每个通道的信息，然后再经由1x1卷积混叠提取的信息。</p>
<p>代码(tf版本)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_depthwise_separable_conv2d</span><span class="params">(self, inputs, num_filters, width_multiplier,</span></span></span><br><span class="line"><span class="function"><span class="params">       scope, downsample=False)</span>:</span></span><br><span class="line">       <span class="string">"""depthwise separable convolution 2D function"""</span></span><br><span class="line">       num_filters = round(num_filters * width_multiplier)</span><br><span class="line">       strides = <span class="number">2</span> <span class="keyword">if</span> downsample <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">with</span> tf.variable_scope(scope):</span><br><span class="line">           <span class="comment"># depthwise conv2d</span></span><br><span class="line">           dw_conv = depthwise_conv2d(inputs, <span class="string">"depthwise_conv"</span>, strides=strides)</span><br><span class="line">           <span class="comment"># batchnorm</span></span><br><span class="line">           bn = bacthnorm(dw_conv, <span class="string">"dw_bn"</span>, is_training=self.is_training)</span><br><span class="line">           <span class="comment"># relu</span></span><br><span class="line">           relu = tf.nn.relu(bn)</span><br><span class="line">           <span class="comment"># pointwise conv2d (1x1)</span></span><br><span class="line">           pw_conv = conv2d(relu, <span class="string">"pointwise_conv"</span>, num_filters)</span><br><span class="line">           <span class="comment"># bn</span></span><br><span class="line">           bn = bacthnorm(pw_conv, <span class="string">"pw_bn"</span>, is_training=self.is_training)</span><br><span class="line">           <span class="keyword">return</span> tf.nn.relu(bn)</span><br></pre></td></tr></table></figure>
<h4 id="可调参数-alpha-和-rho"><a href="#可调参数-alpha-和-rho" class="headerlink" title="可调参数$\alpha$和$\rho$"></a>可调参数$\alpha$和$\rho$</h4><p>　　$\alpha$是宽度乘子，用来调节通道数，$\rho$是分辨率乘子，用来调整输入图像的分辨率。$\alpha$使模型更”廋”,$\rho$使表征减小。</p>
<p>　　使用可调参数$\alpha$和$\rho$后模型的计算量为:</p>
<script type="math/tex; mode=display">
\alpha*M*k*k*\alpha)*\rho*H*\rho*W+\alpha*M*1*1*N*\alpha*\rho*H*\rho*W</script><p>在上一步的基础上进一步将计算量减少了约$\alpha^2+\rho^2$倍</p>
<h4 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h4><p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之MobileNetV1/mobile1结构.png" alt></p>
<h3 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h3><p>1.在ImageNet数据集上的对比</p>
<p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之MobileNetV1/mobile1_result1.png" alt></p>
<p>2.与AlexNet和SqueezeNet对比</p>
<p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之MobileNetV1/mobile1_result2.png" alt></p>
<p>3.在MS-COCO数据集表现</p>
<p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之MobileNetV1/mobile1_result3.png" alt></p>
]]></content>
      <categories>
        <category>Deeplearning</category>
        <category>Classification</category>
      </categories>
      <tags>
        <tag>light model</tag>
        <tag>Deeplearning</tag>
        <tag>MobileNet</tag>
      </tags>
  </entry>
  <entry>
    <title>轻量模型之GhostNet</title>
    <url>/articles/376fa5a6.html/</url>
    <content><![CDATA[<p>期刊：CVPR2020<br>论文:<a href="https://arxiv.org/abs/1911.11907" target="_blank" rel="noopener">https://arxiv.org/abs/1911.11907</a><br>代码地址：<a href="https://github.com/huawei-noah/ghostnet" target="_blank" rel="noopener">tensorflow</a>,<a href="https://github.com/iamhankai/ghostnet.pytorch" target="_blank" rel="noopener">pytorch</a></p>
<a id="more"></a>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>​　　当前神经网络的设计趋势是对移动设备具有可移植性，而这几年也提出了一些有效方法，针对模型压缩的有网络剪枝，参数量化和知识蒸馏等。还有一些则是针对轻量网络结构设计的，如MobileNet、shuffleNet等。本文是针对的是后一种的，提出了一种新的神经网络结构GhostNet。</p>
<p>​　　该论文提供了一个全新的Ghost模块，旨在通过廉价操作生成更多的特征图。基于一组原始的特征图，作者应用一系列线性变换，以很小的代价生成许多能从原始特征发掘所需信息的“幻影”特征图（Ghost feature maps）。该Ghost模块即插即用，通过堆叠Ghost模块得出Ghost bottleneck，进而搭建轻量级神经网络——GhostNet。在ImageNet分类任务，GhostNet在相似计算量情况下<strong>Top-1正确率达75.7%</strong>，高于MobileNetV3的75.2%。</p>
<h3 id="模型优化策略"><a href="#模型优化策略" class="headerlink" title="模型优化策略"></a>模型优化策略</h3><p>​　　提出了全新的Ghost模块来提取更多信息，首先从卷积层中输出较少的一些特征，然后使用这个Ghost模块对这些特征进行线性变化，从而生成更多的丰富冗余的特征，这样不经没有破坏特征，反而还减少了模型的参数量，提高了识别精度。</p>
<h3 id="网络结构分析"><a href="#网络结构分析" class="headerlink" title="网络结构分析"></a>网络结构分析</h3><h4 id="1-输出特征分析"><a href="#1-输出特征分析" class="headerlink" title="1.输出特征分析"></a>1.输出特征分析</h4><p>​　　作者经过实验分析指出一个已经训练好的模型中，往往会有一些丰富而又冗余的特征信息，这些信息能保证网络对输入数据能有全面的理解，作者以已经训练好的ResNet50为例，打印了一些特征图信息，相似的特征图类似于对方的ghost。冗余的特征是网络的关键特性，作者认为与其避免冗余特征，不如以一种cost-efficient的方式接受，可以获得很不错的性能提升</p>
<p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之GhostNet/res50.png" alt></p>
<h4 id="2-Ghost-Module"><a href="#2-Ghost-Module" class="headerlink" title="2.Ghost Module"></a>2.Ghost Module</h4><p>​　　对于输入数据$X∈R^{c\times h \times w}$,经过卷积操作输出的结果可以表示为：</p>
<script type="math/tex; mode=display">
Y=X*f+b\tag{1}</script><p>​　　其中$*$表示卷积操作，$Y∈R^{n\times h^{‘} \times w^{‘}}$为n维输出特征，卷积核$f∈R^{c\times k\times k \times n}$,该卷积层的FLOPs为$c\times k\times k\times n\times h^{‘}\times w^{‘}$,这个数值通常会很大，造成数值大的主要原因还是$c，n$例如(256,512).而实际上这些输出特征图中存在相似的ghost特征图，所以没必要以这么大参数代价来生成这些冗余特征。</p>
<p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之GhostNet/ghostmodule.png" alt></p>
<p>​　　假设输出的特征为某些原始特征进行简单的变换得到Ghost，通常这些原始特征数量都很少，并且能通过原始卷积操作公式2获得。</p>
<script type="math/tex; mode=display">
Y^{’}=X*f^{'}\tag{2}</script><p>​　　其中$Y^{‘}∈R^{h^{‘} \times w^{‘}\times m}$为原始卷积生成的特征，$m\le n$,卷积核为$f^{‘}∈R^{c\times k\times k \times m}$,为了获得最初的n维特征，需要对这些原始输出特征进行线性变换来产生s维的ghost特征。转换过程如下：</p>
<script type="math/tex; mode=display">
y_{ij}=\Phi_{i,j}(y^{’}) \quad \forall i=1,2,...,m, j=1,2,..s, \tag{3}</script><p>​　　其中 $y^{‘}<em>{i}$是$Y^{‘}$中第$i$个原始特征图，函数$\Phi</em>{i,j}$指的是的是第$i$个特征图的第 $j$个线性运算，用于生成第$j$个ghost特征图 $y<em>{ij}$，也就是说， $y^{‘}</em>{i}$可以具有一个或多个ghost特征图 。</p>
<ul>
<li>代码实现</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GhostModule</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, inp, oup, kernel_size=<span class="number">1</span>, ratio=<span class="number">2</span>, dw_size=<span class="number">3</span>, stride=<span class="number">1</span>, relu=True)</span>:</span></span><br><span class="line">        super(GhostModule, self).__init__()</span><br><span class="line">        self.oup = oup</span><br><span class="line">        init_channels = math.ceil(oup / ratio)</span><br><span class="line">        new_channels = init_channels*(ratio<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">        self.primary_conv = nn.Sequential(</span><br><span class="line">            nn.Conv2d(inp, init_channels, kernel_size, stride, kernel_size//<span class="number">2</span>, bias=<span class="literal">False</span>),</span><br><span class="line">            nn.BatchNorm2d(init_channels),</span><br><span class="line">            nn.ReLU(inplace=<span class="literal">True</span>) <span class="keyword">if</span> relu <span class="keyword">else</span> nn.Sequential(),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        self.cheap_operation = nn.Sequential(</span><br><span class="line">            nn.Conv2d(init_channels, new_channels, dw_size, <span class="number">1</span>, dw_size//<span class="number">2</span>, groups=init_channels, bias=<span class="literal">False</span>),</span><br><span class="line">            nn.BatchNorm2d(new_channels),</span><br><span class="line">            nn.ReLU(inplace=<span class="literal">True</span>) <span class="keyword">if</span> relu <span class="keyword">else</span> nn.Sequential(),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x1 = self.primary_conv(x)</span><br><span class="line">        x2 = self.cheap_operation(x1)</span><br><span class="line">        out = torch.cat([x1,x2], dim=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> out[:,:self.oup,:,:]</span><br></pre></td></tr></table></figure>
<h4 id="3-复杂度分析"><a href="#3-复杂度分析" class="headerlink" title="3.复杂度分析"></a>3.复杂度分析</h4><p>​　　ghost模块包含一个恒等映射和$m(s-1)= \frac{n}{s}(s-1)$个线性运算。使用Ghost模块的理论加速比为：</p>
<script type="math/tex; mode=display">
\begin{aligned} r_{s} &=\frac{n \cdot h^{\prime} \cdot w^{\prime} \cdot c \cdot k \cdot k}{\frac{n}{s} \cdot h^{\prime} \cdot w^{\prime} \cdot c \cdot k \cdot k+(s-1) \cdot \frac{n}{s} \cdot h^{\prime} \cdot w^{\prime} \cdot d \cdot d} \\ &=\frac{c \cdot k \cdot k}{\frac{1}{g} \cdot c \cdot k \cdot k+\frac{s-1}{s} \cdot d \cdot d} \approx \frac{s \cdot c}{s+c-1} \approx s \end{aligned} \tag{4}</script><p>　　$d\times d$和$k\times k$大小相似,在论文中，$d\times d$的大小定位$3\times 3$, 另外$s\ll c,s$在论文中定位2。使用Ghost模块的理论参数压缩比为：</p>
<script type="math/tex; mode=display">
r_{c}=\frac{n \cdot c \cdot k \cdot k}{\frac{n}{s} \cdot c \cdot k \cdot k+(s-1) \cdot \frac{n}{s} \cdot d \cdot d} \approx \frac{s \cdot c}{s+c-1} \approx s\tag{5}</script><h4 id="4-ghost-bottleneck"><a href="#4-ghost-bottleneck" class="headerlink" title="4.ghost bottleneck"></a>4.ghost bottleneck</h4><p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之GhostNet/ghostbottleneck.png" alt></p>
<p>​　　Ghost Bottleneck(G-bneck)与residual block类似，主要由两个Ghost模块堆叠，第一个模块用于增加特征维度，增大的比例称为<em>expansion ration</em>，而第二个模块则用于减少特征维度，使其与shortcut一致。G-bneck包含stride=1和stride=2版本，对于stride=2，shortcut路径由下采样层和stride=2的depthwise卷积组成。为了加速，Ghost模块的原始卷积均采用pointwise卷积。</p>
<h4 id="5-GhostNet网络结构"><a href="#5-GhostNet网络结构" class="headerlink" title="5.GhostNet网络结构"></a>5.GhostNet网络结构</h4><p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之GhostNet/architecture.png" alt></p>
<h3 id="实验及分析"><a href="#实验及分析" class="headerlink" title="实验及分析"></a>实验及分析</h3><h4 id="1-Toy-Experiment"><a href="#1-Toy-Experiment" class="headerlink" title="1.Toy Experiment"></a>1.Toy Experiment</h4><p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之GhostNet/exp1.png" alt></p>
<p>​　　论文对图1的ghost pair进行了不同核大小的线性变化测试，将左图作为输入右图作为输出训练小的depthwise卷积来验证线性变换$\Phi$,计算其变换后与右图的MSE。可以看到，不同的核大小下差值都很小，说明线性变换是有效的，而且核大小的影响不大，所以用核大小固定为d的depthwise卷积来实现公式(3)的转换。</p>
<h4 id="2-超参数消融实验"><a href="#2-超参数消融实验" class="headerlink" title="2.超参数消融实验"></a>2.超参数消融实验</h4><p>​        Ghost模块由两个超参数，用于生成m个原始特征的参数s($m=\frac{n}{s}$)以及进行线性变化的深度卷积核大小$d\times d$作者对这两个超参数进行了消融实验。</p>
<p>实验一：作者先固定了参数s=2,让d在[1,3,5,7]中变化，使用的backbone是VGG16，将VGG16的卷积层替换成     　　　　ghost模块，测试数据集为cifar10。</p>
<p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之GhostNet/fixs.png" alt></p>
<p>实验二：作者先固定了参数d=3,让ｓ在[２,3,4,5]中变化，使用的backbone和数据集同上。<br><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之GhostNet//fixd.png" alt></p>
<h4 id="3-在ImageNet数据集上对ResNet50的压缩对比"><a href="#3-在ImageNet数据集上对ResNet50的压缩对比" class="headerlink" title="3.在ImageNet数据集上对ResNet50的压缩对比"></a>3.在ImageNet数据集上对ResNet50的压缩对比</h4><p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之GhostNet/compress.png" alt></p>
<h4 id="4-在ImageNet数据上精度对比"><a href="#4-在ImageNet数据上精度对比" class="headerlink" title="4.在ImageNet数据上精度对比"></a>4.在ImageNet数据上精度对比</h4><table><tr>
<td><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之GhostNet/imagnet1.png" border="0"></td>
<td><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之GhostNet/imagenet2.png" border="0"></td>
</tr></table>

<table><tr>
    <td><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之GhostNet/img3.png"></td>
</tr></table>

<p>5.在MS-COCO数据集上的对比</p>
<p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之GhostNet/coco.png" alt></p>
]]></content>
      <categories>
        <category>Deeplearning</category>
        <category>Classification</category>
      </categories>
      <tags>
        <tag>light model</tag>
        <tag>Deeplearning</tag>
        <tag>GhostNet</tag>
      </tags>
  </entry>
  <entry>
    <title>轻量模型之MobileNetV2</title>
    <url>/articles/20ae27b6.html/</url>
    <content><![CDATA[<p>期刊：CVPR2018<br>论文：<a href="https://arxiv.org/abs/1801.04381" target="_blank" rel="noopener">https://arxiv.org/abs/1801.04381</a><br>代码地址：<a href="https://github.com/tensorflow/models/tree/master/research/slim/nets/mobilenet" target="_blank" rel="noopener">tensorflow</a></p>
<a id="more"></a>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>​　　MobileNetV2是MobileNetV1的升级版，论文标题其实就是该版本的改进和创新点，使用Inverted Residuals和Linear Bottlenecks来构建block。V2相比V1识别精度不仅提高了，参数数量也更少了。</p>
<h3 id="模型优化策略"><a href="#模型优化策略" class="headerlink" title="模型优化策略"></a>模型优化策略</h3><p>1.引入Linear Bottleneck</p>
<p>2.引入Inverted Residual block</p>
<h3 id="网络模型分析"><a href="#网络模型分析" class="headerlink" title="网络模型分析"></a>网络模型分析</h3><h4 id="Linear-Bottlenecks"><a href="#Linear-Bottlenecks" class="headerlink" title="Linear Bottlenecks"></a>Linear Bottlenecks</h4><p>　　Linear Bottlenecks的引入其实是为了解决MobileNetV1在实际的训练中有部分Depthwise卷积核为空的问题。作者针对这个问题做了具体分析,把矛头指向了激活函数ReLU。</p>
<p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之MobileNetV2/relu_effect.png" alt></p>
<blockquote>
<p>Examples of ReLU transformations of low-dimensional manifolds embedded in higher-dimensional spaces. In these examples the initial spiral is embedded into an n-dimensional space using random matrix $T$ followed by ReLU, and then projected back to the 2D space using $T^{-1}$ samples above n= 2， 3 result in information loss where certain points of the manifold collapse into each other, while for n= 15 to 30 the transformation is highly non-convex</p>
</blockquote>
<p>​　　大致意思是将输入经矩阵$T$转换为高维空间后，经过RELU作用，再经逆矩阵$T^{-1}$恢复，如果转化维度较低，则输出信息丢失较多。而转化维度较高时Lin，信息丢失较少。作者解决这个问题的方法就是将激活函数ReLU换成线性的。也就是这里的Linear Bottleneck。</p>
<p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之MobileNetV2/bottleneck.png" alt></p>
<p>ReLU vs. ReLU6</p>
<p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之MobileNetV2/ReLU.png" alt></p>
<p>　　这是为了在移动端设备 float16/int8 的低精度的时候，也能有很好的数值分辨率，如果对 ReLU 的激活范围不加限制，输出范围为0到正无穷，如果激活值非常大，分布在一个很大的范围内，则低精度的float16/int8无法很好地精确描述如此大范围的数值，带来精度损失。</p>
<h4 id="Inverted-Residual"><a href="#Inverted-Residual" class="headerlink" title="Inverted Residual"></a>Inverted Residual</h4><p>　　Residual Block：输入首先经过$1\times 1$的卷积进行压缩，然后使用$3\times 3$的卷积进行特征提取，最后在用$1\times 1$的卷积把通道数变换回去。整个过程是“压缩-卷积-扩张”。这样做的目的是减少$3 * 3$模块的计算量，提高残差模块的计算效率。</p>
<p>　　Inverted Residual Block:输入首先经过$1\times 1$的卷积进行通道扩张，然后使用$3\times 3$的depthwise卷积，最后使用$1\times 1$的pointwise卷积将通道数压缩回去。整个过程是“扩张-卷积-压缩”。这样做的原因时Depthwise卷积无法特征图拓展维度。</p>
<p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之MobileNetV2/Inres_block.png" alt></p>
<h4 id="BottleNeck结构"><a href="#BottleNeck结构" class="headerlink" title="BottleNeck结构"></a>BottleNeck结构</h4><p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之MobileNetV2/v2.png" alt></p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InvertedResidual</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, inp, oup, stride, expand_ratio)</span>:</span></span><br><span class="line">        super(InvertedResidual, self).__init__()</span><br><span class="line">        self.stride = stride</span><br><span class="line">        <span class="keyword">assert</span> stride <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">        hidden_dim = int(inp * expand_ratio)</span><br><span class="line">        self.use_res_connect = self.stride == <span class="number">1</span> <span class="keyword">and</span> inp == oup</span><br><span class="line">        <span class="keyword">if</span> expand_ratio == <span class="number">1</span>:</span><br><span class="line">            self.conv = nn.Sequential(</span><br><span class="line">                <span class="comment"># dw</span></span><br><span class="line">                nn.Conv2d(hidden_dim, hidden_dim, <span class="number">3</span>, stride, <span class="number">1</span>, groups=hidden_dim, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(hidden_dim),</span><br><span class="line">                nn.ReLU6(inplace=<span class="literal">True</span>),</span><br><span class="line">                <span class="comment"># pw-linear</span></span><br><span class="line">                nn.Conv2d(hidden_dim, oup, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(oup),</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.conv = nn.Sequential(</span><br><span class="line">                <span class="comment"># pw</span></span><br><span class="line">                nn.Conv2d(inp, hidden_dim, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(hidden_dim),</span><br><span class="line">                nn.ReLU6(inplace=<span class="literal">True</span>),</span><br><span class="line">                <span class="comment"># dw</span></span><br><span class="line">                nn.Conv2d(hidden_dim, hidden_dim, <span class="number">3</span>, stride, <span class="number">1</span>, groups=hidden_dim, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(hidden_dim),</span><br><span class="line">                nn.ReLU6(inplace=<span class="literal">True</span>),</span><br><span class="line">                <span class="comment"># pw-linear</span></span><br><span class="line">                nn.Conv2d(hidden_dim, oup, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(oup),</span><br><span class="line">            )</span><br></pre></td></tr></table></figure>
<h6 id="网络结构参数"><a href="#网络结构参数" class="headerlink" title="网络结构参数"></a>网络结构参数</h6><p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之MobileNetV2/network.png" alt></p>
<h5 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h5><p>1.ImageNet评估结果</p>
<p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之MobileNetV2/imagenet.png" alt></p>
<p>2.MS-COCO目标检测评估结果</p>
<p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之MobileNetV2/detection.png" alt></p>
<p>3.VOC2012实例分割评估结果</p>
<p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之MobileNetV2/segmentation.png" alt></p>
]]></content>
      <categories>
        <category>Deeplearning</category>
        <category>Classification</category>
      </categories>
      <tags>
        <tag>light model</tag>
        <tag>Deeplearning</tag>
        <tag>MobileNet</tag>
      </tags>
  </entry>
  <entry>
    <title>轻量模型之MobileNetV3</title>
    <url>/articles/57a91720.html/</url>
    <content><![CDATA[<p>期刊：ICCV2019<br>论文：<a href="https://arxiv.org/abs/1905.02244" target="_blank" rel="noopener">https://arxiv.org/abs/1905.02244</a><br>代码地址：<a href="https://github.com/xiaolai-sqlai/mobilenetv3" target="_blank" rel="noopener">pytorch</a>,<a href="https://github.com/Bisonai/mobilenetv3-tensorflow" target="_blank" rel="noopener">tensorflow</a>,<a href="https://github.com/jixing0415/caffe-mobilenet-v3" target="_blank" rel="noopener">caffe</a></p>
<a id="more"></a>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>　　从标题可以看出，MobileNetV3是由网络结构搜索(NAS)技术搜索而来的。该网络结合了V1的深度可分离卷积，V2的Linear Bottleneck，Inverted Residuals，SE模块等。MobileNetV3有两个版本，Large版本和Small版本。与MobileNetVV2相比，MobileNetV3-Large在ImageNet分类上的准确度高3.2％，同时将延迟降低了20％。与延迟相当的MobileNetV2模型相比，MobileNetV3-Small的准确度高6.6％。 MobilSeNetV3-Large的检测速度快25％以上，精度与COCO检测上的MobileNetV2大致相同。</p>
<h3 id="模型优化策略"><a href="#模型优化策略" class="headerlink" title="模型优化策略"></a>模型优化策略</h3><ul>
<li>基于网络架构搜索技术(NAS)</li>
<li>引入基于squeeze and excitation结构的轻量级注意力模型SE(在V2的基础上)</li>
<li>使用了一种新的激活函数h-swish(x)</li>
<li>重新设计耗时层</li>
</ul>
<h3 id="网络结构分析"><a href="#网络结构分析" class="headerlink" title="网络结构分析"></a>网络结构分析</h3><h5 id="1-网络搜索"><a href="#1-网络搜索" class="headerlink" title="1.网络搜索"></a>1.网络搜索</h5><p>​　　借鉴了MnasNet的资源受限的网络结构搜索(Platform-aware NAS)技术。使用该技术通过优化每个网络block来搜索一个全局的网络结构。然后使用网络自适应搜索(NetAdapt NAS)来进一步优化block中每层卷积核的数量。</p>
<h4 id="2-激活函数h-swish-x"><a href="#2-激活函数h-swish-x" class="headerlink" title="2.激活函数h-swish(x)"></a>2.激活函数h-swish(x)</h4><p>​　　h-swish是基于swish的改进，swish最早是在谷歌2017的论文<a href="https://link.zhihu.com/?target=https%3A//arxiv.org/abs/1710.05941">Searching for Activation functions</a>所提出。swish论文的作者认为，swish具备无上界有下界、平滑、非单调的特性。并且swish在深层模型上的效果优于ReLU。仅仅使用Swish单元替换ReLU就能把MobileNet,NASNetA在 ImageNet上的top-1分类准确率提高0.9%，Inception-ResNet-v2的分类准确率提高0.6%。其表达式为$f(x)= x<em>sigmoid(\beta</em>x)$。</p>
<p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之MobileNetV3/swish.png" alt></p>
<p>　　V3用swish替代ReLU时，也可以显著提高神经网络的精度。但是作者认为这种非线性激活函数虽然提高了精度，但在嵌入式环境中，是有不少的成本的。原因就是在移动设备上计算sigmoid函数是非常不明智的选择。所以提出了h-swish。</p>
<p>​　　可以用一个近似函数来逼急这个swish，作者选择的是基于ReLU6，作者认为几乎所有的软件和硬件框架上都可以使用ReLU6的优化实现。其次，它能在特定模式下消除了由于近似sigmoid而带来的潜在的数值精度损失。</p>
<script type="math/tex; mode=display">
f(x) = x*\frac{ReLU6(x+3)}{6}</script><p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之MobileNetV3/hswish.png" alt></p>
<h6 id="3-squeeze-and-excitation结构"><a href="#3-squeeze-and-excitation结构" class="headerlink" title="3.squeeze and excitation结构"></a>3.squeeze and excitation结构</h6><p>​        SENet的提出动机非常简单，传统的方法是将网络的Feature Map等权重的传到下一层，SENet的核心思想在于<strong>建模通道之间的相互依赖关系，通过网络的全局损失函数自适应的重新矫正通道之间的特征相应强度</strong>。</p>
<p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之MobileNetV3/semodule.png" alt></p>
<h6 id="4-重新设计耗时层"><a href="#4-重新设计耗时层" class="headerlink" title="4.重新设计耗时层"></a>4.重新设计耗时层</h6><p>​　　当前模型是基于V2模型中的<strong>倒残差结构</strong>相应的变体。使用<strong>1×1卷积</strong>来构建最后层，这样可以便于拓展到更高维的特征空间。这样做在预测时，有更多更丰富的特征来满足预测，但是同时也<strong>引入了额外的计算成本与延时</strong>。</p>
<p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之MobileNetV3/lastlayer.png" alt></p>
<p>在不造成精度损失的同时，减少7ms延时，减小了30m的MAdd操作。对于v2的输入层，通过3×3卷积将输入扩张成32维。作者发现使用ReLU或者switch激活函数，将通道数缩减到16维，且准确率还能保持不变。这又能节省3ms的延时。</p>
<h3 id="网络结构和参数"><a href="#网络结构和参数" class="headerlink" title="网络结构和参数"></a>网络结构和参数</h3><h4 id="1-mobilenetv3的block"><a href="#1-mobilenetv3的block" class="headerlink" title="1.mobilenetv3的block"></a>1.mobilenetv3的block</h4><p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之MobileNetV3/block.png" alt></p>
<h6 id="2-网络结构参数"><a href="#2-网络结构参数" class="headerlink" title="2.网络结构参数"></a>2.网络结构参数</h6><p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之MobileNetV3/m3.png" alt></p>
<h3 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h3><p>Imagenet数据集</p>
<p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之MobileNetV3/result2.png" alt></p>
<p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之MobileNetV3/imgresult.png" alt></p>
]]></content>
      <categories>
        <category>Deeplearning</category>
        <category>Classification</category>
      </categories>
      <tags>
        <tag>light model</tag>
        <tag>Deeplearning</tag>
        <tag>MobileNet</tag>
      </tags>
  </entry>
  <entry>
    <title>轻量模型之SqueezeNet</title>
    <url>/articles/225ebdce.html/</url>
    <content><![CDATA[<p><strong>SqueezeNet:AlexNet-level accuracy with 50x fewer parameters and &lt;0.5MB</strong></p>
<p>期刊：ICLR2017<br>文章地址：<a href="https://arxiv.org/abs/1602.07360" target="_blank" rel="noopener">https://arxiv.org/abs/1602.07360</a><br>代码链接:<a href="https://github.com/forresti/SqueezeNet" target="_blank" rel="noopener">caffe版</a>,<a href="https://github.com/pytorch/vision/blob/f9ef235c402f48a335293c626e17bd8504d3af87/torchvision/models/squeezenet.py#L14" target="_blank" rel="noopener">pytorch版</a></p>
<a id="more"></a>
<h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>　　这篇文章的比较对象直指ALexNet,文章指出现有的大部分深度神经网络为了为了追求在某些数据集上的识别精度,就不断的增加网络层数来提高检测精度。但是随着网络层数的增加,模型大小和训练难度也在急剧的增加,这不利于这些检测模型在某些应用的推广使用，如特斯拉的自动驾驶,FPGA以及一些资源受限的硬件等。作者指出在保持检测精度的情况的小的的模型能够解决这些问题。</p>
<h5 id="模型优化策略"><a href="#模型优化策略" class="headerlink" title="模型优化策略"></a>模型优化策略</h5><ul>
<li><p>使用1x1卷积代替3x3卷积</p>
</li>
<li><p>减少3x3卷积核的通道数</p>
</li>
<li><p>将降采样后移</p>
<p>其中前两个策略的作用是试图在保持精度的情况下减少网络参数,最后一个策略是在有限模型参数的情况下最大化检测精度。（这样的操作虽然会提升网络的精度，但是它有一个非常严重的缺点：即会增加网络的计算量。）</p>
</li>
</ul>
<h5 id="网络模型分析"><a href="#网络模型分析" class="headerlink" title="网络模型分析"></a>网络模型分析</h5><ul>
<li><strong>Fire Module</strong></li>
</ul>
<p>　　SqueezeNet主要由Fire Module模块组成,Fire Modele包含squeeze层和expand层,squeeze层由1x1卷积核组成,expand层由1x1和3x3卷积核组成。输出的特征图分别经由expand层的1x1卷积核和3x3卷积核的输出concat得到。</p>
<p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之SqueezeNet/firemodule.png" alt></p>
<p>Fire Module中包含三个可调的参数s1,e1,e3分别代表squeeze层中1x1卷积核、expand层中1x1卷积核和3x3卷积核的通道数。squeezenet中Fire Moduel结构，作者对这三个参数的设置是e1=e3=4s1</p>
<p>Fire Module代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fire</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, inplanes, squeeze_planes,</span></span></span><br><span class="line"><span class="function"><span class="params">                 expand1x1_planes, expand3x3_planes)</span>:</span></span><br><span class="line">        super(Fire, self).__init__()</span><br><span class="line">        self.inplanes = inplanes</span><br><span class="line">        self.squeeze = nn.Conv2d(inplanes, squeeze_planes, kernel_size=<span class="number">1</span>)</span><br><span class="line">        self.squeeze_activation = nn.ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">        self.expand1x1 = nn.Conv2d(squeeze_planes, expand1x1_planes,</span><br><span class="line">                                   kernel_size=<span class="number">1</span>)</span><br><span class="line">        self.expand1x1_activation = nn.ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">        self.expand3x3 = nn.Conv2d(squeeze_planes, expand3x3_planes,</span><br><span class="line">                                   kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line">        self.expand3x3_activation = nn.ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = self.squeeze_activation(self.squeeze(x))</span><br><span class="line">        <span class="keyword">return</span> torch.cat([</span><br><span class="line">            self.expand1x1_activation(self.expand1x1(x)),</span><br><span class="line">            self.expand3x3_activation(self.expand3x3(x))</span><br><span class="line">        ], <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>SqueezeNet Architecture</strong></li>
</ul>
<p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之SqueezeNet/squeezenet.png" alt></p>
<p>具体的网络参数</p>
<p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之SqueezeNet/parameter.png" alt></p>
<p>中间和右边的结构借鉴了resnet网络，加入了skip结构</p>
<h5 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h5><p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之SqueezeNet/squeezenet_result.png" alt></p>
]]></content>
      <categories>
        <category>Deeplearning</category>
        <category>Classification</category>
      </categories>
      <tags>
        <tag>light model</tag>
        <tag>SqueezeNet</tag>
        <tag>Deeplearning</tag>
      </tags>
  </entry>
  <entry>
    <title>轻量模型之ShuffleNetV2</title>
    <url>/articles/e3f1c69e.html/</url>
    <content><![CDATA[<p>期刊：ECCV2018<br>论文:<a href="https://arxiv.org/abs/1807.11164" target="_blank" rel="noopener">https://arxiv.org/abs/1807.11164</a><br>代码地址：<a href="https://github.com/ericsun99/Shufflenet-v2-Pytorch/blob/master/ShuffleNetV2.py" target="_blank" rel="noopener">pytorch</a></p>
<a id="more"></a>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>​　　这篇文章出自旷视研究院，论文指出当前评估轻量网络模型运行复杂度的指标主要依靠FLOPs(float-point operations)，即主要是卷积层的乘加操作。但是FLOPs是个间接指标，并不能表示直接的指标如速度或延时等。因为影响模型速度的因素不仅仅是FLOPs，还有内存访问操作所消耗的计算（memory access cost，MAC），以及平台因素。</p>
<p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之ShuffleNetV2/speed.png" alt></p>
<p>​　　当前sota的模型各个操作的时间占比,其中FLOPs所指的就是Conv操作，可以看到Elemwise(Addtensor,ReLU等等),Data(I/O)，以及一些其他操作也占用一部分时间。而对于平台因素，以GPU的张量分解来说。在一些论文里，提出了FLOPs减少75%的张量分解，理论上应该是加速了很多的。但是在GPU中却慢了很多。论文认为，这是因为CUDNN有针对$3\times3$的卷积进行优化的，我们不能想当然的认为$3\times3$卷积会比$1 \times1$卷积慢9倍</p>
<p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之ShuffleNetV2/runtime.png" alt></p>
<h5 id="四条指导原则"><a href="#四条指导原则" class="headerlink" title="四条指导原则"></a>四条指导原则</h5><p>作者结合实验观察，提出了四条具有建设性的轻量模型设计指导原则：</p>
<p><strong>G1.同等通道大小最小化MAC</strong></p>
<p>​　　由于1x1卷积占据了大量的计算复杂度，针对1x1卷积作者进行了分析，假设1x1卷积层输入通道是$c<em>{1}$,输出通道数是$c</em>{2}$,  $h\times w$是特征图的分辨率。则FLOPs和MAC分别是</p>
<script type="math/tex; mode=display">
B=FLOPs=hwc_{1}c_{2}\tag{1}</script><script type="math/tex; mode=display">
MAC=hw(c_{1}+c_{2})+c_1c_2 \tag{2}</script><p>MAC中的两部分分别代表输入输出特征图和卷积核参数。根据平均值不等式可以得到</p>
<script type="math/tex; mode=display">
MAC\ge2\sqrt{hwB}+\frac{B}{hw}\tag{3}</script><p>在给定FLOPs下，当且仅当$c_{1}=c{2}$时，MAC达到最小边界值。这是理论计算结果，作者为了验证这一结论，也进行了相应的实验。</p>
<p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之ShuffleNetV2/G1.png" alt><br><strong>G2.组卷积分组过多会增加MAC</strong>`</p>
<p>​　　分组卷积后的FLOPs和MAC分别为：</p>
<script type="math/tex; mode=display">
B=FLOPs=hwc_{1}c_{2}/g\tag{4}</script><script type="math/tex; mode=display">{&}
MAC = hw(c_{1}+c_{2})+c_1c_2/g \\
= hwc_{1}+\frac{Bg}{c_{1}}+\frac{B}{hw}\tag{5}</script><p>​　　从公式(5)可以看到，在给定FLOPs下，分组越多，则MAC越大，同样的也有实验来验证这一点。</p>
<p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之ShuffleNetV2/G2.png" alt></p>
<p><strong>3.模型分支数量过多会减少并行性</strong><br><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之ShuffleNetV2/G3.png" alt></p>
<p><strong>4.元素级操作不能忽略</strong></p>
<p>​　　元素级操作在Fig2中也占了很大一部分时间尤其是在GPU中，元素级操作包括激活函数ReLU，张量相加，偏置相加，跳过连接等,它们有相对较小的FLOPs但是却有相当大的MAC。作者也做了相应的实验来证明这点。</p>
<p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之ShuffleNetV2/G4.png" alt></p>
<p>作者根据上述的实验指导以及经验学习，得出设计高效的网络结构应该遵循：</p>
<p>1）卷积层使用相同的输入输出通道数</p>
<p>2）注意到使用大的分组数所带来的坏处</p>
<p>3）减少分支以及所包含的基本单元</p>
<p>4）减少Element-wise操作</p>
<h3 id="ShuffleNet-V2网络结构"><a href="#ShuffleNet-V2网络结构" class="headerlink" title="ShuffleNet V2网络结构"></a>ShuffleNet V2网络结构</h3><p>​　　ShuffleNet V2依据上面四点原则对V1版本网络进行了升级改造，作者指出了V1版本中的大量的Pointwise Group Conv违背G1，另外v1采用了类似ResNet中的瓶颈层（bottleneck layer），输入和输出通道数不同，这违背了<strong>G1</strong>原则。同时使用过多的组，也违背了<strong>G3</strong>原则。短路连接中存在大量的元素级Add运算，这违背了<strong>G4</strong>原则。</p>
<h4 id="Channel-Split-and-ShuﬄeNet-V2-unit"><a href="#Channel-Split-and-ShuﬄeNet-V2-unit" class="headerlink" title="Channel Split and ShuﬄeNet V2 unit"></a>Channel Split and ShuﬄeNet V2 unit</h4><p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之ShuffleNetV2/结构1.png" alt></p>
<p>​　　为了改善v1的缺陷，v2版本引入了一种新的操作：channel split。具体来说，在开始时先将输入特征图在通道维度分成两个分支：通道数分别为 $c^{’}$和 $c-c^{‘}$（实际$c^{’}=\frac{c}{2}$）。左边分支做同等映射，右边的分支包含3个连续的卷积，并且输入和输出通道相同，这符合<strong>G1</strong>。而且两个1x1卷积不再是组卷积，这符合<strong>G2</strong>，另外两个分支相当于已经分成两组。两个分支的输出不再是Add元素，而是concat在一起，紧接着是对两个分支concat结果进行channle shuffle，以保证两个分支信息交流。而concat和channel shuffle可以和下一个模块单元的channel split实际可以合成一个元素级运算，这符合<strong>G4</strong>。</p>
<p>​　　对于下采样模块，不再有channel split，而是每个分支都是直接copy一份输入，每个分支都有stride=2的下采样，最后concat在一起后，特征图空间大小减半，但是通道数翻倍。</p>
<h4 id="网络结构参数"><a href="#网络结构参数" class="headerlink" title="网络结构参数"></a>网络结构参数</h4><p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之ShuffleNetV2/结构2.png" alt></p>
<h3 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h3><p>1.在ImageNet数据集上的结果</p>
<p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之ShuffleNetV2/result.png" alt></p>
<p>可以看到，在同等条件下，ShuffleNetv2相比其他模型速度稍快，而且准确度也稍好一点。</p>
<p>2.在MS-COCO数据集上的结果</p>
<p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之ShuffleNetV2/coco.png" alt></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://zhuanlan.zhihu.com/p/67009992" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/67009992</a></p>
]]></content>
      <categories>
        <category>Deeplearning</category>
        <category>Classification</category>
      </categories>
      <tags>
        <tag>light model</tag>
        <tag>Deeplearning</tag>
        <tag>ShuffleNet</tag>
      </tags>
  </entry>
  <entry>
    <title>轻量模型之ShuffleNetV1</title>
    <url>/articles/7af89724.html/</url>
    <content><![CDATA[<p>期刊：CVPR2017<br>论文:<a href="https://arxiv.org/abs/1707.01083" target="_blank" rel="noopener">https://arxiv.org/abs/1707.01083</a><br>代码地址：<a href="https://github.com/jaxony/ShuffleNet" target="_blank" rel="noopener">pytorch</a>,<a href="https://github.com/farmingyard/ShuffleNet" target="_blank" rel="noopener">caffe</a></p>
<a id="more"></a>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>​　　不同于MobileNet系列使用深度可分离卷积来减少模型的参数量和计算量，shuffleNet使用分组卷积来实现轻量模型这一目标。文章对分组卷积进行了改进，使用分组逐点卷积(pointwise group convolution )和通道混合(channel shuffle),改进了分组卷积中组信息不交融的问题，在保证计算精度的同时，大大降低了计算成本。</p>
<h3 id="模型优化策略"><a href="#模型优化策略" class="headerlink" title="模型优化策略"></a>模型优化策略</h3><ul>
<li>分组逐点卷积(pointwise group convolution )</li>
<li>通道混合(channel shuffle)</li>
</ul>
<h3 id="网络结构分析"><a href="#网络结构分析" class="headerlink" title="网络结构分析"></a>网络结构分析</h3><p>​　　自从AlexNet将组卷积引入进来后，Xception, ResNeXt和MobileNet相继使用组卷积的方式减少模型参数，并取得了不错的进展。作者发现，在ResNeXt(cardinality=32)中，93.4%的加法和乘法是用在pointwise conv上，pointwise conv是为了解决group conv中组与组之间相互独立的问题而引入的，本质上是一个1*1的普通卷积操作，因此pointwise通道稠密 ，参数量较多。解决的方法是使其变成通道稀疏的卷积操作，也就是变成组卷积的形式。</p>
<h4 id="分组卷积和通道混合"><a href="#分组卷积和通道混合" class="headerlink" title="分组卷积和通道混合"></a>分组卷积和通道混合</h4><p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之ShufflenNetV1/channelshuffle.png" alt></p>
<p>​　　左图是两个分组卷积分组数相同，导致组与组之间的信息不流通，中间的GConv2进一步分组，输入到GConv的是不同组的特征，右边的使用了channel shuffle来等同于中间的操作。channel shuffle的操作很简单，假定输入是有$g$组，每组有$n$个channel,输出则有$g\times n$个channel，首先将输出转化成二维的$(g,n)$，然后转置成$(n,g)$,最后又reshape成$g\times n$维度，最后每个组是均匀的混合着。</p>
<h4 id="ShufﬂeNet单元"><a href="#ShufﬂeNet单元" class="headerlink" title="ShufﬂeNet单元"></a>ShufﬂeNet单元</h4><p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之ShufflenNetV1/shufflenet_unit.png" alt></p>
<p>　　图a展示了基本ResNet轻量级结构，这是一个包含3层的残差单元：首先是1x1卷积，然后是3x3的depthwise convolution（DWConv，主要是为了降低计算量），这里的3x3卷积是瓶颈层（bottleneck），紧接着是1x1卷积，最后是一个短路连接，将输入直接加到输出上。</p>
<p>​　　图b展示了改进思路：将密集的1x1卷积替换成1x1的group convolution，不过在第一个1x1卷积之后增加了一个channel shuffle操作。值得注意的是3x3卷积后面没有增加channel shuffle，对于这样一个残差单元，作者认为一个channel shuffle操作是足够了。还有就是3x3的depthwise convolution之后没有使用ReLU激活函数。</p>
<p>​　　图c展示了其他改进，对原输入采用stride=2的3x3 avg pool，在depthwise convolution卷积处取stride=2保证两个通路shape相同，然后将得到特征图与输出进行连接，而不是相加。极致的降低计算量与参数大小。</p>
<h4 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h4><p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之ShufflenNetV1/结构.png" alt></p>
<h3 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h3><p>1.不同组数的评估结果</p>
<p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之ShufflenNetV1/result.png" alt></p>
<p>其中ShuffleNet 1x表示baseline结构，0.5x和0.25x表示在1x的基础上对每层的通道数乘0.5，0.25。</p>
<p>2.和MobileNetV1在ImageNet数据集上的对比</p>
<p><img src="http://cdn.wangng.com/deeplearning/classification/轻量模型之ShufflenNetV1/vsmobilenet.png" alt></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/hellcat/p/10318630.html" target="_blank" rel="noopener">『高性能模型』轻量级网络ShuffleNet_v1及v2</a></p>
]]></content>
      <categories>
        <category>Deeplearning</category>
        <category>Classification</category>
      </categories>
      <tags>
        <tag>light model</tag>
        <tag>Deeplearning</tag>
        <tag>ShuffleNet</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈python中的赋值、浅拷贝、深拷贝问题</title>
    <url>/articles/ea672d08.html/</url>
    <content><![CDATA[<h3 id="可变对象不可变对象"><a href="#可变对象不可变对象" class="headerlink" title="可变对象不可变对象"></a>可变对象不可变对象</h3><p>python一切皆为对象，python中的所有对象又分为可变对象和不可变对象,可变指的是对象的内容是可变的,反之不可变对象的内容是不可变的。以下数据类型同样指的是对象，这些数据类型具体的归类如下：</p>
<blockquote>
<p>不可变对象 ：int，string，float，tuple<br>可变对象：list，dictionary    </p>
</blockquote>
<p><strong>不可变对象</strong><br>由于Python中的变量存放的是对象引用(python中不存在所谓的传值调用，一切传递的都是对象的引用，也可以认为是传址。)，所以对于不可变对象而言，尽管对象本身不可变，但变量的对象引用是可变的。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i=<span class="number">73</span></span><br><span class="line">i+=<span class="number">2</span></span><br></pre></td></tr></table></figure><br><img src="/articles/ea672d08.html/fig1.png" alt><br>从上面得知，不可变的对象的特征没有变，依然是不可变对象，变的只是创建了新对象，改变了变量的对象引用。如下面的示例<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=<span class="number">1</span>   <span class="comment">#将变量a和对象1绑定,a为对象1的引用，也即a指向1所在内存</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=a   <span class="comment">#将变量b指向a的内存</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="number">1</span>   </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=<span class="number">4</span>   <span class="comment">#创建了新对象4，更新变量b的对象引用,将b指向新的对象内存,a任然指向1的内存地址</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="number">4</span>  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><br>另外python有一个机制：Python会缓存使用非常频繁的小整数-5至256、ISO/IEC 8859-1单字符、只包含大小写英文字母的字符串，以对其复用,不会创建新的对象：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=<span class="number">-6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=<span class="number">-6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)==id(b) </span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=<span class="number">-5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=<span class="number">-5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)==id(b) </span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=<span class="number">256</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=<span class="number">256</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)==id(b) </span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=<span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=<span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)==id(b) </span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><br><strong>可变对象</strong><br>可变对象的内容是可以变化的，当可变对象的内容变化时，对象引用并不会发生改变<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a) </span><br><span class="line"><span class="number">1932387411016</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>]=<span class="number">9</span>      <span class="comment">#对象内容发生改变，但对象的引用不变</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a) </span><br><span class="line"><span class="number">1932387411016</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=[<span class="number">456</span>,<span class="number">89</span>]   <span class="comment">#创建了一个新的对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a) </span><br><span class="line"><span class="number">1932387392584</span></span><br></pre></td></tr></table></figure></p>
<h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>使用赋值操作就是给对象创建了一个别名,他们会指向同一个对象的引用,不会创建新的变量。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=<span class="string">"hello"</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a) </span><br><span class="line"><span class="number">1932387430104</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b) </span><br><span class="line"><span class="number">1932387430104</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=[<span class="string">"hello"</span>,<span class="string">"world"</span>,<span class="string">"!"</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">1932387392584</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b) </span><br><span class="line"><span class="number">1932387392584</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(<span class="string">"python"</span>)         </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a,b</span><br><span class="line">([<span class="string">'hello'</span>, <span class="string">'world'</span>, <span class="string">'!'</span>, <span class="string">'python'</span>], [<span class="string">'hello'</span>, <span class="string">'world'</span>, <span class="string">'!'</span>, <span class="string">'python'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a),id(b) </span><br><span class="line">(<span class="number">1932387392584</span>, <span class="number">1932387392584</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h3><p><strong>对于拷贝来说,是对对象的拷贝，会在内存中生成新的对象，产生新的内存地址。</strong><br>对于浅拷贝来说，它只会拷贝最外围的对象本身，不会拷贝对象内部的子对象,换句话就是外部生成了一个新的对象,内部只拷贝了对象的引用，内部对象具有相同的引用地址</p>
<p>对于深拷贝，它会完全拷贝最外面的对象和子对象。对象和子对象都会生成新的对象。</p>
<p>注：这里生成对象意味这会开辟新的新的内存空间，新的引用地址</p>
<p><strong>浅拷贝示例</strong><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a.copy()    <span class="comment">#创建了一个和a值一模一样的新对象b</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a),id(b) </span><br><span class="line">(<span class="number">1932387392776</span>, <span class="number">1932387411080</span>) <span class="comment">#创建了新的对象，引用地址已改变</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a[<span class="number">0</span>]),id(b[<span class="number">0</span>]) </span><br><span class="line">(<span class="number">1965976640</span>, <span class="number">1965976640</span>) <span class="comment">#浅拷贝，内部对象并未拷贝，也就是并未创建新的对象，他们指向同一个对象，所以引用地址是相同的</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a[<span class="number">1</span>]),id(b[<span class="number">1</span>]) </span><br><span class="line">(<span class="number">1965976672</span>, <span class="number">1965976672</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(<span class="number">5</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a,b</span><br><span class="line">([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]) <span class="comment">#对于a来说,a的子对象创建了一个新的变量，也就是a[4]指向了新的对象5,</span></span><br></pre></td></tr></table></figure><br>对于复杂对象，例如，列表中嵌套这列表这样,稍微不同<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">5</span>,<span class="number">6</span>]] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=a.copy()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a,b</span><br><span class="line">([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">5</span>, <span class="number">6</span>]], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a),id(b) </span><br><span class="line">(<span class="number">1932387411016</span>, <span class="number">1932387411144</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a[<span class="number">0</span>]),id(b[<span class="number">0</span>]) </span><br><span class="line">(<span class="number">1965976640</span>, <span class="number">1965976640</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a[<span class="number">3</span>]),id(b[<span class="number">3</span>]) </span><br><span class="line">(<span class="number">1932387392584</span>, <span class="number">1932387392584</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">3</span>].append(<span class="number">9</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a,b</span><br><span class="line">([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>]], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a[<span class="number">3</span>]),id(b[<span class="number">3</span>]) </span><br><span class="line">(<span class="number">1932387392584</span>, <span class="number">1932387392584</span>)</span><br></pre></td></tr></table></figure><br>这里a的子数组新增了一个数字9，同样的b也新增了一个数字9，<strong>这是因为对于子数组a[3]和b[3]来说，他们指向的对象是同一个可变对象内存地址,当这个内存内的内容发生变化时，那么对于a[3]和b[3]来说，他们内容时同步的</strong></p>
<p>总结就是对于浅拷贝，它是对对象外部的拷贝，对象内部并未拷贝，对于子对象中不可变对象，改变这些对象时，不会对其他父对象中的子对象有任何影响，而对于子对象中的可变对象，改变这些对象，则其他父对象中的子对象会发生同步变化。</p>
<p><strong>深拷贝</strong><br>深拷贝会创建一个新的对象，子对象也会创建新的对象。因此他们的外部对象引用和内部子对象引用都不相同。这样的话，他们两个时值相同的完全独立的对象，任何的操作改变都不会对其他对象(拷贝或被拷贝)有任何影响。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>浅拷贝</tag>
        <tag>深拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo为博客创建唯一链接</title>
    <url>/articles/96afc19.html/</url>
    <content><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>由于有些博客的标题是中文的，而且标题很长的话，生成的链接会特别长，而且也不简约。看到别人的博客链接都很短，感觉挺好的，于是google了下，发现有现成的开源的生成唯一连接的hexo插件<a href="https://github.com/rozbo/hexo-abbrlink" target="_blank" rel="noopener">abbrlink</a></p>
<a id="more"></a>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>那个abbrlink的仓库也有提供方法。很简单</p>
<ul>
<li>第一步安装插件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure></li>
<li>第二步在站点配置文件_config.yml中修改<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># permalink: :title&#x2F;</span><br><span class="line">permalink: articles&#x2F;:abbrlink.html&#x2F;  #articles可以设成你想要的目录</span><br><span class="line">abbrlink:</span><br><span class="line">	alg: crc32   #算法： crc16(default) and crc32</span><br><span class="line">	rep: hex     #进制： dec(default) and hex</span><br></pre></td></tr></table></figure></li>
<li>第三步hexo g生成，会显示如下信息<br><img src="/articles/96afc19.html/abbrlink.png" alt></li>
</ul>
<p>而且你会在写好的.md文件中看到出现了关键字abbrlik: xxxxxx</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://github.com/rozbo/hexo-abbrlink" target="_blank" rel="noopener">https://github.com/rozbo/hexo-abbrlink</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>宝塔mysql无法启动</title>
    <url>/articles/46e2d8fc.html/</url>
    <content><![CDATA[<p>在使用宝塔linux面板一键安装LNMP的是，数据库mysql始终无法启动，查查找找用了几个小时，问题终于解决了</p>
<blockquote>
<ul>
<li>版本：mysql5.7(刚开始安装的mysql5.6，安装速度是20多分种，真是慢，后来问题解决后我觉得应该和把版本没关系，心累)</li>
</ul>
</blockquote>
<a id="more"></a>
<p>下面的就是报错的截图，如果使用宝塔linux面板安装的数据库无法启动，所报的错误应该是一样 ，就是找不到这PID file,这个PID file我也不知道是啥。<br><img src="https://img-blog.csdnimg.cn/2020021523041717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzMTY5Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>步骤1：到/www/server/mysql/data/,查看localhost.err,这是启动报错的log文件，查看该文件, cat命令查看，cat localhost.err<br><img src="https://img-blog.csdnimg.cn/20200215231419692.png" alt="在这里插入图片描述"></p>
<p>步骤2：查看该文件, cat命令查看，cat localhost.err，发现出现了一个新的问题，Fatal error: Can’t open and lock privilege tables: Table ‘mysql.user’ doesn’t exist<br><img src="https://img-blog.csdnimg.cn/20200215231739333.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzMTY5Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>步骤3，1.首先找到mysql_install_db(最终解决步骤，前面两步是要让你怎么发现问题，知道这个问题出在哪里)<br><img src="https://img-blog.csdnimg.cn/20200215232420882.png" alt="在这里插入图片描述"></p>
<p>2.执行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;www&#x2F;server&#x2F;mysql&#x2F;bin&#x2F;mysql_install_db --datadir&#x3D;&#x2F;www&#x2F;server&#x2F;mysql&#x2F;data&#x2F; --basedir&#x3D;&#x2F;www&#x2F;server&#x2F;mysql --user&#x3D;mysql</span><br></pre></td></tr></table></figure><br><img src="https://img-blog.csdnimg.cn/20200215232820957.png" alt="在这里插入图片描述"><br>3.显示目录已存在，删除该目录 rm -r /www/server/mysql/data，再执行2命令<br>4.启动mysql,已显示active状态<br><img src="https://img-blog.csdnimg.cn/20200215233342117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzMTY5Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>最后还有感谢这位博主<a href="https://blog.csdn.net/xhool/article/details/52398042" target="_blank" rel="noopener">xhool</a>,根据他的方法来解决步骤3的问题的</p>
<p>参考：<a href="https://blog.csdn.net/a2011480169/article/details/51912771" target="_blank" rel="noopener">https://blog.csdn.net/a2011480169/article/details/51912771</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>宝塔mysql</tag>
        <tag>wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title>win10删除vs2015安装vs2019,并卸载cuda9.0安装cuda10.0</title>
    <url>/articles/87c00dba.html/</url>
    <content><![CDATA[<h2 id="卸载cuda9-0"><a href="#卸载cuda9-0" class="headerlink" title="卸载cuda9.0"></a>卸载cuda9.0</h2><p>打开<strong>控制面板</strong>中的程序选项，</p>
<a id="more"></a>
<p><img src="https://img-blog.csdnimg.cn/20200101194716296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzMTY5Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>保留Nvidia 图型驱动程序432.00和Nvidia PhysX系统软件这两个，删除掉以Nvidia开头的所有程序，<br>这样，我们的cuda9.0就被删除掉了，如果还想删除cuda9.0所在的文件夹的话，删除该文件夹即可。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v9.0</span><br></pre></td></tr></table></figure></p>
<h2 id="删除vs2015"><a href="#删除vs2015" class="headerlink" title="删除vs2015"></a>删除vs2015</h2><p>这个可以参考这篇博文链接:<a href="https://blog.csdn.net/qq_26591517/article/details/79549008" target="_blank" rel="noopener">link</a></p>
<h2 id="安装vs2019"><a href="#安装vs2019" class="headerlink" title="安装vs2019"></a>安装vs2019</h2><p>进入vs2019下载页面链接：<a href="https://docs.microsoft.com/zh-cn/visualstudio/releases/2019/release-notes#16.1.2" target="_blank" rel="noopener">Visual Studio 2019</a><br><img src="https://img-blog.csdnimg.cn/20200101202533779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzMTY5Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我下载的是community版本，选择对应版本进行下载，下载完成后，双击会自动安装Visual Studio Installer,<br>然后在Visual Studio Installer中选择不同的版本进行安装。由于我已安装了community版本，所以可用列表中只显示了其他两个版本的安装选项。选择你要安装的版本，点击安装<br><img src="https://img-blog.csdnimg.cn/20200101203000962.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzMTY5Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这里会显示下载负载，我只选择了使用C++进行桌面开发，全部下载完安装。最后等待其安装，其中你也可以选择你安装的位置。这里默认是在C盘。但其实只选择这一个选项的话，所占用的空间并不大。<br><img src="https://img-blog.csdnimg.cn/20200101203422223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzMTY5Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="安装cuda10-0"><a href="#安装cuda10-0" class="headerlink" title="安装cuda10.0,"></a>安装cuda10.0,</h2><p>win10版本的cuda10和cudnn安装包，我放在我的链接:<a href="https://pan.baidu.com/s/1279mSA2-ww2koC0bcUikMw" target="_blank" rel="noopener">百度云</a>,提取码:mcjb<br>1.下载安装文件后，直接双击安装<br><img src="https://img-blog.csdnimg.cn/20200101201326231.png" alt="在这里插入图片描述"><br>2.选择Ok,然后等待其解压缩<br><img src="https://img-blog.csdnimg.cn/20200101201443877.png" alt="在这里插入图片描述"><br>3同意并继续<br><img src="https://img-blog.csdnimg.cn/20200101201555920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzMTY5Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>4选择精简安装<br><img src="https://img-blog.csdnimg.cn/20200101201715126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzMTY5Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>5.勾选并点击next，然后等待其安装。<br><img src="https://img-blog.csdnimg.cn/20200101201751552.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzMTY5Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>6测试安装是否成功,在windows power终端中<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvcc -V</span><br></pre></td></tr></table></figure><br><img src="https://img-blog.csdnimg.cn/20200101203901895.png" alt="在这里插入图片描述"><br>则表明cuda安装成功。</p>
<h2 id="安装cudnn"><a href="#安装cudnn" class="headerlink" title="安装cudnn"></a>安装cudnn</h2><p>1.将cudnn安装包解压，得到<br><img src="https://img-blog.csdnimg.cn/2020010120413113.png" alt="在这里插入图片描述"><br>2.找到cuda10.0的安装路径<br><img src="https://img-blog.csdnimg.cn/20200101204244607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzMTY5Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>将1中文件夹中的文件复制到2中对应的文件夹下即可。</p>
]]></content>
      <categories>
        <category>Setting disposition</category>
      </categories>
      <tags>
        <tag>win10</tag>
        <tag>cuda9</tag>
        <tag>cuda10</tag>
      </tags>
  </entry>
  <entry>
    <title>解决next主题中mist主题文本不居中</title>
    <url>/articles/e36f14c4.html/</url>
    <content><![CDATA[<h4 id="1-前述"><a href="#1-前述" class="headerlink" title="1 前述"></a>1 <strong>前述</strong></h4><p>在基于hexo和github搭建个人博客的时候，选择了next主题中的mist主题，然而将生成的静态网页上传完毕后，发现文本和文本下的站点信息都是偏左对齐的，看起来不是很美观。还是得google，但一些方法只能使文本中心对齐，地下的站点信息还是没法对齐，还是得修改配置文件。</p>
<a id="more"></a>
<h4 id="2-修改配置"><a href="#2-修改配置" class="headerlink" title="2 修改配置"></a>2 <strong>修改配置</strong></h4><ul>
<li><strong>文本中心对齐</strong><br>选择themes\next\source\css\_schemes\Mist_posts-expand.styl，将.post-meta中得text-align改为center<br><img src="https://img-blog.csdnimg.cn/20200325132335976.png" alt="在这里插入图片描述"></li>
<li><strong>站点信息中心对齐</strong><br>选择themes\next\source\css\_schemes\Mist_layout.styl中的.footer-inner中得text-align该为center<br><img src="https://img-blog.csdnimg.cn/20200325132856969.png" alt="在这里插入图片描述"><br>选择themes\next\source\css_variables\Mist.styl，将$site-meta-text-align 改为center<br><img src="https://img-blog.csdnimg.cn/20200325133159147.png" alt="在这里插入图片描述"><br>然后重新生成上传即可</li>
</ul>
<h4 id="3-参考"><a href="#3-参考" class="headerlink" title="3 参考"></a>3 <strong>参考</strong></h4><p><a href="https://www.jianshu.com/p/19089f2b99c6" target="_blank" rel="noopener">https://www.jianshu.com/p/19089f2b99c6</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客搭建，hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>使用ssh和vscode进行远程调试</title>
    <url>/articles/58d22c92.html/</url>
    <content><![CDATA[<h3 id="SSH简介"><a href="#SSH简介" class="headerlink" title="SSH简介"></a>SSH简介</h3><blockquote>
<p>SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。几乎所有UNIX平台—包括HP-UX、Linux、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行SSH。(摘自<a href="https://baike.baidu.com/item/SSH/10407" target="_blank" rel="noopener">百度百科</a>，具体的可以查看链接内容)</p>
</blockquote>
<a id="more"></a>
<p>总结就是，SSH是一种安全有效网络传输协议，利用ssh进行网络传输能有效避免信息泄露问题。</p>
<h4 id="OpenSSH"><a href="#OpenSSH" class="headerlink" title="OpenSSH"></a>OpenSSH</h4><p>OpenSSH（OpenBSD Secure Shell）是SSH协议的一种实现，在计算机上安装完OpenSSH并开启服务后该计算机就可作为SSH服务器被远程访问和上传下载文件。</p>
<h3 id="VS-Code编辑器"><a href="#VS-Code编辑器" class="headerlink" title="VS Code编辑器"></a>VS Code编辑器</h3><p>是一个由微软大大开发，同时支持Windows 、 Linux和macOS等操作系统且开放源代码的代码编辑器，在之前所使用的python代码编辑器中，我有用过pycharm,spyder,以及jupyter notebook等，后来用到VS Code，感觉VS Code编辑器用得更便捷，更舒适，所以我也一直在使用这款编辑器。界面布局如下<br><img src="https://img-blog.csdnimg.cn/20200211132725132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzMTY5Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="SSH和VS-Code进行远程开发调试"><a href="#SSH和VS-Code进行远程开发调试" class="headerlink" title="SSH和VS Code进行远程开发调试"></a>SSH和VS Code进行远程开发调试</h3><p>首先你需要有两台电脑，一台手头的，一台远程的。远程的电脑我称之为服务器吧，你需要知道这台服务器的公网ip和端口号以及这台服务器的root密码</p>
<h4 id="安装openssh"><a href="#安装openssh" class="headerlink" title="安装openssh"></a>安装openssh</h4><p>从 Win10 1809 和 Windows Server 2019 开始 Windows 开始支持 OpenSSH Server。在Windows PowerShell中输入ssh命令显示下图，表明已安装openssh,不过openssh包含客户端(client)和服务端(server),win10系统默认已安装客户端。<br><img src="https://img-blog.csdnimg.cn/20200211140652119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzMTY5Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>安装服务端可在设置里面 应用和功能&gt;管理可选功能&gt;添加功能中安装<br><img src="https://img-blog.csdnimg.cn/20200211141402398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzMTY5Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>win+r运行services.msc,打开服务管理器，<br><img src="https://img-blog.csdnimg.cn/20200211161632483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzMTY5Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>将OpenSSH Authentication Agent 服务和 OpenSSH SSH Server 服务双击设置为自启动，并启动这两个服务<br><img src="https://img-blog.csdnimg.cn/20200211161934334.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzMTY5Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>而在ubuntu系统中，也是默认已安装了openssh客户端的，使用命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get insatll openssh-server    #安装openssh server</span><br><span class="line">sudo &#x2F;etc&#x2F;init.d&#x2F;ssh start   #启动 openssh server</span><br></pre></td></tr></table></figure></p>
<h4 id="测试连接"><a href="#测试连接" class="headerlink" title="测试连接"></a>测试连接</h4><p>比如我的远程的服务器的IP是47.93.251.207（公网IP，如果你的服务器是处于局域网内，你必须把你的服务器的IP影射到公网中去，这就需要使用内网穿透了），端口号是xxx，使用ssh进行远程连接，使用命令ssh -p 端口好 服务器名称@服务器ip地址，本来应该由yes/no选项的，需要选择yes,然后enter，我的是之前已经连接过，所以没有这个选项。下图表明我们已经连上我们的远程服务器了<br><img src="https://img-blog.csdnimg.cn/2020021116300575.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzMTY5Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="3-3-VSCode结合remote-ssh进行远程调试开发"><a href="#3-3-VSCode结合remote-ssh进行远程调试开发" class="headerlink" title="3.3 VSCode结合remote ssh进行远程调试开发"></a>3.3 VSCode结合remote ssh进行远程调试开发</h3><p><img src="https://img-blog.csdnimg.cn/20200211165401608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzMTY5Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">选择扩展程序，然后搜索Remote SSH并install,最后会出现箭头④所示的插件符。<br>选择remote ssh,然后选择“+”号，添加主机<br><img src="https://img-blog.csdnimg.cn/20200211165801241.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzMTY5Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200211170041203.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzMTY5Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>键入之前测试连接的命令，然后enter<br><img src="https://img-blog.csdnimg.cn/20200211170210916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzMTY5Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>选择ssh config的存放位置，选择第一个<br><img src="https://img-blog.csdnimg.cn/20200211170358557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzMTY5Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>点击左下角的符号连接主机。<br><img src="https://img-blog.csdnimg.cn/20200211172521538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzMTY5Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>选择刚才添加的主机，然后输入主机密码最后enter<br><img src="https://img-blog.csdnimg.cn/20200211172555508.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzMTY5Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>出现红色箭头所示，表明我们已连上远程的服务器<br><img src="https://img-blog.csdnimg.cn/2020021117300176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzMTY5Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Explorer中打开你所在工程的文件目录<br><img src="https://img-blog.csdnimg.cn/20200211173156385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzMTY5Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>打开我项目文件的所在目录<br><img src="https://img-blog.csdnimg.cn/20200211173548292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzMTY5Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在Extensions中搜索python,安装python解释器<br><img src="https://img-blog.csdnimg.cn/20200211174000665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzMTY5Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>打开任意.py文件，按箭头位置选择你需要的python解释器<br><img src="https://img-blog.csdnimg.cn/20200211174809676.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjYzMTY5Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>至此，所有操作已完成，你就可以在本地实现远程的代码调试和开发了。由于VS code远程连接需要两次握手，也即需要输入两次密码，可以使用ssh免密登录，参见<a href="https://blog.csdn.net/weixin_42631693/article/details/102871228" target="_blank" rel="noopener">Windows 实现SSH免密登录</a></p>
<h3 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h3><p>1.<a href="https://www.cnblogs.com/sparkdev/p/10166061.html" target="_blank" rel="noopener">Windows 支持 OpenSSH 了！</a><br>2.<a href="https://www.cnblogs.com/feipeng8848/p/8559803.html" target="_blank" rel="noopener">Windows上安装配置SSH教程（1）——知识点汇总</a><br>3.<a href="https://blog.csdn.net/sixdaycoder/article/details/89947893" target="_blank" rel="noopener">VSCode:Remote-SSH配置实录</a></p>
]]></content>
      <categories>
        <category>Setting disposition</category>
      </categories>
      <tags>
        <tag>远程调试</tag>
      </tags>
  </entry>
  <entry>
    <title>如何优雅的开始深度学习之旅</title>
    <url>/articles/bf0f19e4.html/</url>
    <content><![CDATA[<p>作为一名还在打怪升级的深度学习菜鸟而言，不谈给大家传授什么经验，因为感觉自己也很菜，只是结合自己在学习和科研项目中的一些工具的使用经历，说一说自己在平时常用编程环境和工具</p>
<a id="more"></a>
<ul>
<li>操作系统</li>
<li>IDE</li>
<li>内网穿透</li>
<li>多屏协同</li>
<li>远程调试</li>
<li>文件传输<br>……</li>
</ul>
<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>操作系统的选择方面，其实不用太多介绍，因为实验室服务器清一色的Ubuntu系统，在平时模型训练中，用得多还是Ubuntu系统，关于版本问题，我用过得有16.04的版本和18.04的版本，其实两者没多大区别(对于开发调试而言)，但由于Ubuntu16.04已于2019停止维护更新，所以还是选择比较新的18.04版本吧。听说最新的20.04版本也发布的，感兴趣的人可以去体验体验。Ubantu18.04的安装方法可以参考这篇<a href="https://blog.csdn.net/baidu_36602427/article/details/86548203" target="_blank" rel="noopener">Ubuntu18.04安装教程</a></p>
<h3 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h3><p>怎么说呢，个人有个人的使用习惯，说下我自己吧。写python代码时候pycharm用过一段时间,也用过spyder,sublime text,jupyter notebook,不过这些用的不多。pycharm一开始是师兄介绍使用的,使用一段时间时候,发现占用的缓存越来越多(windows中C盘占了几个G),而且<br>pycharm启动时间很慢，因为他要加载环境里各种安装包。spyder和jupyte notebook是集成在Anconda里的呢，spyder也要个优点，在运行的时候，会显示一些中间变量，方便查看和调试程序，sublim text就是一个纯的文本编辑器，需要安装插件，用的都不多。我现在用的M家的VSCode(Visual studio Code),这个编辑器不大，加载也很快，上手也非常容易，我写的这篇博客用的也是这个编辑器，没错VScode也能用Markdown语法写文章。可以安装很多插件，可以适应不同的开发需求。</p>
<p><img src="/articles/bf0f19e4.html/vscode.png" alt="vscode"></p>
<h3 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h3><p>内网穿透实际上就是将处于局域网内的ip映射到公网IP,这样的话，我们就能在某一个局域网内访问到处于另一局域网内的服务器。什么时候需要用到内网穿透呢，比如我自己实验室在三楼，服务器放在四楼（两个不同的局域网），我想在三楼用自己电脑通过ssh连上四楼的服务器。内网穿透的话我有用过花生壳的内网穿透功能，但是网络不稳定，经常掉线，后来就是改用了开源的<a href="https://github.com/fatedier/frp" target="_blank" rel="noopener">frp</a>,使用这个的前提是你有一台公网IP的服务器，我的公网服务器是阿里云的轻量应用服务器(学生一个月9块钱)，使用frp穿透后网络稳定度就大大提高了。使用方法如下：<br>下载frp到本地和服务器端<br><strong>服务器端(阿里云服务器)</strong><br>1.以linux系统为例，新建目录mkdir -p /usr/local/frp，frp_0.29.0_linux_amd64.tar.gz<br>上传至linux服务器该目录下<br>2.解压tar -zxvf  frp_0.29.0_linux_amd64.tar.gz<br><img src="/articles/bf0f19e4.html/frp.png" alt="frp"><br>3.进入解压目录cd frp_0.29.0_linux_amd64，这里主要关注4个文件，分别是frpc、frpc.ini和frps、frps.ini，前者两个文件是客户端所关注文件，后者两个文件是服务端所关注两个文件。<br><img src="/articles/bf0f19e4.html/frp2.png" alt="frp2"><br>4.配置服务端（公网服务器）,vi frps.ini，<br><img src="/articles/bf0f19e4.html/frp3.png" alt="frp3"><br>5.启动frps服务<br>./frps -c ./frps.ini，这是前台启动，后台启动命令为nohup ./frps -c ./frps.ini &amp;<br><img src="/articles/bf0f19e4.html/frp4.png" alt="frp4"><br><strong>客户端(四楼服务器)</strong><br>1.同服务端的1，2，3.<br>2.配置客户端，vi frpc.ini<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr &#x3D; 47.92.251.201   #公网服务器ip</span><br><span class="line">server_port &#x3D; 7000            #与服务端bind_port一致</span><br><span class="line"> </span><br><span class="line">#公网通过ssh访问内部服务器</span><br><span class="line">[ssh]</span><br><span class="line">type &#x3D; tcp              #连接协议</span><br><span class="line">local_ip &#x3D; 192.168.1.125 #内网服务器ip</span><br><span class="line">local_port &#x3D; 22         #ssh默认端口号</span><br><span class="line">remote_port &#x3D; 6000      #自定义的访问内部ssh端口号</span><br><span class="line"> </span><br><span class="line">#公网访问内部web服务器以http方式</span><br><span class="line">[web]</span><br><span class="line">type &#x3D; http         #访问协议</span><br><span class="line">local_port &#x3D; 8080   #内网web服务的端口号</span><br><span class="line">custom_domains &#x3D; wangng.com  #所绑定的公网服务器域名，一级、二级域名都可以</span><br></pre></td></tr></table></figure><br>3.启动frpc<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;frpc -c .&#x2F;frpc.ini，这是前台启动，后台启动命令为nohup .&#x2F;frpc -c .&#x2F;frpc.ini &amp;</span><br></pre></td></tr></table></figure><br><strong>注意：记得先将阿里云服务器防火墙6000，7000端口开放</strong><br><img src="/articles/bf0f19e4.html/frp5.png" alt="frp5"></p>
<h3 id="多屏协同"><a href="#多屏协同" class="headerlink" title="多屏协同"></a>多屏协同</h3><p>多屏协同也是提高效率的方法。如果有两个显示屏的话，一个屏幕看文献查资料，另一个屏幕码代码调bug，是不是很爽。这里我针对的是有两个电脑的情况，比如有一个笔记本，有一个台式机。或者土豪的话，两个台式机，如果只有一个电脑但有两个屏的话，可以用win10的屏幕拓展功能。<a href="https://pan.baidu.com/s/18R3ei5OBYXRSgGj1ZAaiAw" target="_blank" rel="noopener">synergy</a>(密码2w72)可以实现多屏协同，一个鼠标控制两台电脑。</p>
<h3 id="远程开发调试"><a href="#远程开发调试" class="headerlink" title="远程开发调试"></a>远程开发调试</h3><p>这里要使用Vscode插件Remote SSH。使用情况是，三楼的我用电脑连上四楼的服务器，并在服务器中修改自己的项目文件,这样就可以足不出户实现远程的调试。这个可以参考我的另一篇博文<a href="http://www.wangng.com/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E4%BD%BF%E7%94%A8ssh%E5%92%8Cvscode%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/" target="_blank" rel="noopener">使用ssh和vscode进行远程调试</a></p>
<h3 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h3><p>对于文件传输可以使用scp命令，也可以使用Filezilla传输。Filezilla可以基于ftp,sftp协议。支持断点续传，某些时候我们想上传某个模型的权重文件，但是突然断网了，下次等网络恢复后，使用续传后就不用从头传输了,而且传输速度还比较快，相较于teamview来说。用的时候在文件-&gt;站点管理器-&gt;新建站点，选择sftp,然后填入服务器ip和端口号(阿里云服务器，已进行内网穿透)。<br><img src="/articles/bf0f19e4.html/sftp.png" alt="sftp"></p>
<p><img src="/articles/bf0f19e4.html/sftp2.png" alt="sftp2"></p>
<p>……</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/u013144287/article/details/78589643" target="_blank" rel="noopener">十分钟教你配置frp实现内网穿透</a></p>
]]></content>
      <categories>
        <category>Setting disposition</category>
      </categories>
      <tags>
        <tag>远程调试</tag>
        <tag>环境搭建</tag>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title>国内用户快速下载arxiv论文</title>
    <url>/articles/973c6b43.html/</url>
    <content><![CDATA[<blockquote>
<p>arXiv（X依希腊文的χ发音，读音如英语的archive）是一个收集物理学、数学、计算机科学、生物学与数理经济学的论文预印本的网站，始于1991年8月14日。截至2008年10月，arXiv.org已收集超过50万篇预印本；至2014年底，藏量达到1百万篇。截至2016年10月，提交率已达每月超过10,000篇(摘自维基百科)</p>
</blockquote>
<a id="more"></a>
<p>最近从arxiv网站下载论文的时候特别的卡，很难受啊！于是搜了下，感觉这个方法很管用。<br>使用中科院的arxiv镜像: <a href="http://xxx.itp.ac.cn" target="_blank" rel="noopener">http://xxx.itp.ac.cn</a>, 国内网络能流畅访问, 使用方法如下：<br>把要访问 arxiv 链接中的域名从 <a href="https://arxiv.org" target="_blank" rel="noopener">https://arxiv.org</a> 换成 <a href="http://xxx.itp.ac.cn,比如" target="_blank" rel="noopener">http://xxx.itp.ac.cn,比如</a>: 从 <a href="https://arxiv.org/pdf/1901.07249" target="_blank" rel="noopener">https://arxiv.org/pdf/1901.07249</a> 改为 <a href="http://xxx.itp.ac.cn/pdf/1901.07249" target="_blank" rel="noopener">http://xxx.itp.ac.cn/pdf/1901.07249</a></p>
<p>但是这里可能会有一些论文未收录，还是只能去arxiv镜像中去下载。</p>
<p>这里特此记录下，方便后来自己下载论文。</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.zhihu.com/question/58912862" target="_blank" rel="noopener">https://www.zhihu.com/question/58912862</a></p>
]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>论文下载</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown语法自定义补全</title>
    <url>/articles/6be24c7e.html/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>每次用markdown语法<code>![]()</code>插入的图片预览都是没有中心对齐的，所以想换一种插入方式:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div align&#x3D;center&gt;</span><br><span class="line">&lt;img src&#x3D; imgpath</span><br><span class="line">&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><br>但是这种方式，每次要写这个模板，太麻烦了，所以就想起能不能使用自动补全的方式，只需输入图片路径就行。看到之前有自动创建C++模板的方式,后面就以此来改写markdown版的自动补全代码。</p>
<a id="more"></a>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>step1:这里同<a href="https://blog.csdn.net/weixin_42631693/article/details/100587486" target="_blank" rel="noopener">使用Vscode编辑器创建C++文件模板</a>。在步骤2中输入markdown选择markdown.json,然后参照示例编写自定义补全代码。</p>
<div align="center">
<img src="http://cdn.wangng.com/other/markdown%E8%AF%AD%E6%B3%95%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%A5%E5%85%A8/markdown1.png"></div>

<p>step2:<code>Ctrl+,</code>转到setting界面，点击右上角打开setting.json文件</p>
<div align="center">
<img src="http://cdn.wangng.com/other/markdown%E8%AF%AD%E6%B3%95%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%A5%E5%85%A8/markdown2.png"></div>
step3: 在markdown大括号内写入`"editor.quickSuggestions": true`
<div align="center">
<img src="http://cdn.wangng.com/other/markdown%E8%AF%AD%E6%B3%95%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%A5%E5%85%A8/markdown3.png"></div>

<p>step4:在.md文件中输入c++,img,java等会自动的补全相应的代码。</p>
<blockquote>
<p>ps:vscode里markdown似乎已支持自动补全了，如输入fenced codeblock,image,code,会出现代码块补全代码。</p>
</blockquote>
]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>细说交叉熵损失</title>
    <url>/articles/25624c88.html/</url>
    <content><![CDATA[<p>　　交叉熵损失是我们分类任务中经常用到了一个损失,但是我们很多时候只知道如何使用,对于其内部原理我们可能知之甚少,所有有必要学习其内部原理,更好的理解这个损失的含义。很明显,交叉熵损失是和信息论中的交叉熵有关的,交叉熵是信息论中的一个重要概念，主要用于度量两个概率分布间的差异性，要理解交叉熵我们有必要复习下信息论的知识。</p>
<a id="more"></a>
<h3 id="信息量"><a href="#信息量" class="headerlink" title="信息量"></a>信息量</h3><p>　　信息量是对信息的度量。香农(Shannon)信息论应用概率来描述不确定性,信息量是用不确定性来量度,一个消息的可能性愈小，其信息愈多;而消息的可能性愈大，则其信息愈少。举个例子:<br><strong>太阳从东边出来</strong>,这个是个必然事件,概率为1,不确定性为0,所以它包含的信息量很小;<br>还有某个人做了一件令人改观的事的时候常说的<strong>太阳打西边出来了</strong>,这可能是调侃。但仔细一想,这句话所包含的信息量非常大(黑人问号脸,太阳怎么会从西边出来呢?),从信息论的角度来说,这是个概率极小极小的事件,不确定性很大。所以当越不可能的事件发生了，我们获取到的信息量就越大。越可能发生的事件发生了，我们获取到的信息量就越小</p>
<p>根据上述可总结如下：<strong>信息量的大小与信息发生的概率成反比</strong>。概率越大，信息量越小。概率越小，信息量越大。</p>
<p>设某一事件发生的概率为P(x)，其信息量表示为：</p>
<script type="math/tex; mode=display">
I(x)=−log_{2}(P(x))\tag{1}</script><h3 id="信息熵"><a href="#信息熵" class="headerlink" title="信息熵"></a>信息熵</h3><p>　　信息量度量的是一个具体事件发生了所带来的信息，而熵则是在结果出来之前<strong>对可能产生的所有信息量的期望</strong>,信息熵的定义如下</p>
<script type="math/tex; mode=display">
H(\mathbf{X})=-\sum_{i=1}^{n} P\left(x_{i}\right) \log \left(P\left(x_{i}\right)\right) \quad\left(\mathbf{X}=x_{1}, x_{2}, x_{3} \ldots, x_{n}\right)\tag{2}</script><p>使用明天的天气概率来计算其信息熵：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">事件</th>
<th style="text-align:center">概率p</th>
<th style="text-align:center">信息量I</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">明天是晴天</td>
<td style="text-align:center">0.7</td>
<td style="text-align:center">-log(0.7)</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">明天是多云</td>
<td style="text-align:center">0.2</td>
<td style="text-align:center">-log(0.2)</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">明天是下雨</td>
<td style="text-align:center">0.1</td>
<td style="text-align:center">-log(0.1)</td>
</tr>
</tbody>
</table>
</div>
<script type="math/tex; mode=display">
H(x) = -0.7\times log(0.7)-0.2\times log(0.2)-0.1\times log(0.1)=0.8019\tag{3}</script><h3 id="相对熵-KL散度"><a href="#相对熵-KL散度" class="headerlink" title="相对熵(KL散度)"></a>相对熵(KL散度)</h3><p>　　相对熵又称KL散度,如果我们对于同一个随机变量 x 有两个单独的概率分布 P(x) 和 Q(x)，我们可以使用 KL 散度（Kullback-Leibler (KL) divergence）来衡量这两个分布的差异,KL散度越小,两个分布越相近。公式如下:</p>
<script type="math/tex; mode=display">
D_{K L}(p \| q)=\sum_{i=1}^{n} p\left(x_{i}\right) \log \left(\frac{p\left(x_{i}\right)}{q\left(x_{i}\right)}\right)\tag{4}</script><p>n表示所有事件的可能性。<br>　　在机器学习中,我们常常用P表示样本的真实分布,Q表示样本的预测分布,如在猫狗马三分类预测分布时,某张猫图片的分布P(x)=[1,0,0],其预测分布Q(x)=[0.6,0.3,0.1],其KL散度</p>
<script type="math/tex; mode=display">
\begin{array}{c}
D_{K L}(p \| q)=\sum_{i=1}^{n} p\left(x_{i}\right) \log \left(\frac{p\left(x_{i}\right)}{q\left(x_{i}\right)}\right) \\
=p\left(x_{1}\right) \log \left(\frac{p\left(x_{1}\right)}{q\left(x_{1}\right)}\right)+p\left(x_{2}\right) \log \left(\frac{p\left(x_{2}\right)}{q\left(x_{2}\right)}\right)+p\left(x_{3}\right) \log \left(\frac{p\left(x_{3}\right)}{q\left(x_{3}\right)}\right) \\
=1 * \log \left(\frac{1}{0.6}\right)=0.51\tag{5}
\end{array}</script><p>KL散度越小，表示P(x)与Q(x)的分布更加接近，可以通过反复训练Q(x)来使Q(x)的分布逼近P(x)。</p>
<h3 id="交叉熵"><a href="#交叉熵" class="headerlink" title="交叉熵"></a>交叉熵</h3><p>　　将KL散度公式分解可得</p>
<script type="math/tex; mode=display">
\begin{array}{c}
\quad D_{K L}(p \| q)=\sum_{i=1}^{n} p\left(x_{i}\right) \log \left(\frac{p\left(x_{i}\right)}{q\left(x_{i}\right)}\right) \\
=\sum_{i=1}^{n} p\left(x_{i}\right) \log \left(p\left(x_{i}\right)\right)-\sum_{i=1}^{n} p\left(x_{i}\right) \log \left(q\left(x_{i}\right)\right) \\
=-H(x)+\left[-\sum_{i=1}^{n} p\left(x_{i}\right) \log \left(q\left(x_{i}\right)\right)\right]
\end{array}\tag{6}</script><p>前者H(x)表示信息熵,后者即为交叉熵,因此<font color="red" size="3">KL散度 = 交叉熵 - 信息熵</font><br>交叉熵公式为:</p>
<script type="math/tex; mode=display">
H(p, q)=-\sum_{i=1}^{n} p\left(x_{i}\right) \log \left(q\left(x_{i}\right)\right)\tag{7}</script><p>在机器学习训练网络时，输入数据与标签常常已经确定，那么真实概率分布P(x)也就确定下来了，所以信息熵在这里就是一个常量。由于KL散度的值表示真实概率分布P(x)与预测概率分布Q(x)之间的差异，值越小表示预测的结果越好，所以需要最小化KL散度，而交叉熵等于KL散度加上一个常量（信息熵），且公式相比KL散度更加容易计算，所以在机器学习中常常使用交叉熵损失函数来计算loss就行了</p>
<h3 id="交叉熵在单分类问题中的应用"><a href="#交叉熵在单分类问题中的应用" class="headerlink" title="交叉熵在单分类问题中的应用"></a>交叉熵在单分类问题中的应用</h3><p>在线性回归问题中，常常使用MSE(Mean Squared Error)作为loss函数，而在分类问题中常常使用交叉熵作为loss函数。</p>
<script type="math/tex; mode=display">
loss= -log(q(x_{i}))\tag{8}</script><p>下面通过一个例子来说明如何计算交叉熵损失值,假设我们输入一张狗的图片，标签与预测值如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">-</th>
<th style="text-align:center">猫</th>
<th style="text-align:center">狗</th>
<th style="text-align:center">马</th>
<th style="text-align:center">-</th>
<th style="text-align:center">猫</th>
<th style="text-align:center">狗</th>
<th style="text-align:center">马</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">true</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">pred</td>
<td style="text-align:center">0.6</td>
<td style="text-align:center">0.3</td>
<td style="text-align:center">0.1</td>
<td style="text-align:center"></td>
<td style="text-align:center">0.2</td>
<td style="text-align:center">0.7</td>
<td style="text-align:center">0.1</td>
</tr>
</tbody>
</table>
</div>
<p>交叉熵损失为</p>
<script type="math/tex; mode=display">
\begin{array}{c}
\operatorname{loss1}
=-(0 * \log (0.2)+1 * \log (0.3)+0 * \log (0.1))=-log(0.3)=1.2\\
\operatorname{loss2}
=-(0 * \log (0.2)+1 * \log (0.7)+0 * \log (0.1))=-log(0.7)=0.36
\end{array}\tag{8}</script><p>一个batch的loss为</p>
<script type="math/tex; mode=display">
\operatorname{loss}=-\frac{1}{m} \sum_{i=1}^{m} \sum_{j=1}^{n} p\left(x_{i j}\right) \log \left(q\left(x_{i j}\right)\right)\tag{9}</script><p>m为一个batch中图片数量.</p>
<p>交叉熵能够衡量同一个随机变量中的两个不同概率分布的差异程度，在机器学习中就表示为真实概率分布与预测概率分布之间的差异。交叉熵的值越小，模型预测效果就越好。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/b1055077005/article/details/100152102" target="_blank" rel="noopener">交叉熵损失函数原理详解</a></p>
]]></content>
      <categories>
        <category>MachineLearning</category>
      </categories>
      <tags>
        <tag>MachineLearning</tag>
        <tag>Cross-entropy</tag>
      </tags>
  </entry>
  <entry>
    <title>05数组：为什么很多编程语言中数组都从0开始编号？</title>
    <url>/articles/986e60da.html/</url>
    <content><![CDATA[<blockquote>
<p>声名：本文大部分内容出自于极客时间网站王争的专栏《数据结构与算法之美》，这里本人主要记录自己的学习过程，添加个人见解，并作为自己的学习笔记。如有侵权，立马删除。</p>
</blockquote>
<p>提到数组，我想你肯定不陌生，不管哪种编程语言，都包含这种数据类型。不过，它不仅仅是一种编程语言中的数据类型，还是一种最基础的数据结构。但是你有没有想过，为什么数组的下标都是从0开始而不从1开始呢？</p>
<a id="more"></a>
<h3 id="如何实现数组的随机访问"><a href="#如何实现数组的随机访问" class="headerlink" title="如何实现数组的随机访问"></a>如何实现数组的随机访问</h3><ul>
<li>定义：<strong>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</strong><br>这个定义中有几个关键字；理解这几个关键字，相信我们就能彻底掌握数组的概念了</li>
</ul>
<p>第一就是<strong>线性表(Linear List)</strong>,顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/05数组：为什么很多编程语言中数组都从0开始编号？/线性表.png" alt><br>而与它相对立的概念是非线性表，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/05数组：为什么很多编程语言中数组都从0开始编号？/非线性表.png" alt><br>第二个关键字就是<strong>连续的内存空间和相同类型的数据</strong>。正是因为这两个限制，它才有了一个堪称“杀手锏”的特性：“随机访问”。但有利就有弊，这两个限制也让数组的很多操作变得非常低效比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据掇移工作。</p>
<p>我们拿一个长度为10的int类型的数组int[] a= new int [10]来举例。在下面这个图中，计算机给数组[10]，分配了一块连续内存空间1000-1039，其中，内存块的首地址为base_address= 1000<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/05数组：为什么很多编程语言中数组都从0开始编号？/内存.png" alt><br>我们知道，计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a[i]_address &#x3D; base_address + i * data_type_size</span><br></pre></td></tr></table></figure><br>这个公式就是编译原理中计算内存的偏移地址的公式，其中data_type_size表示数组中每个元素的大小。我们举的这个例子里，数组中存储的是int类型数据，所以 data_type_size就为4个字节。</p>
<h3 id="低效的“插入”和“删除”"><a href="#低效的“插入”和“删除”" class="headerlink" title="低效的“插入”和“删除”"></a>低效的“插入”和“删除”</h3><p>前面概念部分我们提到，数组为了保持内存数据的连续性，会导致插入、删除这两个操作比较低效。现在我们就来详细说一下，究竟为什么会导致低效？又有哪些改进方法呢？</p>
<ul>
<li>插入操作<br>设数组的长度为n，现在，如果我们需要将一个数据插入到数组中的第k个位置。为了把第k个位置腾出来，给新来的数据，我们需要将第k~n这部分的元素都顺序地往后挪一位。那插入操作的时间复杂度是多少呢？<br>如果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为O(1)。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是O(n)<br>因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为(1+2+…+n)/n=O(n)。</li>
</ul>
<p>如果数组中的数据是有序的，我们在某个位置插入一个新的元素时，就必须按照刚才的方法搬移k之后的数据。但是，如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。在这种情况下，如果要将某个数据插入到第k个位置，为了避免大规模的数据搬移，我们还有一个简单的办法就是，直接将第k位的数据搬移到数组元素的最后，把新的元素直接放入第k个位置<br>为了更好地理解，我们举一个例子。假设数组a[10]中存储了如下5个元素：a,b,c,d,e。<br>我们现在需要将元素x插入到第3个位置。我们只需要将c放入到a[5]，将a[2]赋值为x即可。最后，数组中的元素如下：a,b,x,d,e,c<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/05数组：为什么很多编程语言中数组都从0开始编号？/插入.png" alt><br>利用这种处理技巧，在特定场景下，在第k个位置插入一个元素的时间复杂度就会降为O（1）。这个处理思想在快排中也会用到。</p>
<ul>
<li>删除<br>跟插入数据类似，如果我们要删除第k个位置的数据，为了內存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了。和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为O(1)；如果删除开头的数据，则最坏情况时间复杂度为O(n)；平均情况时间复杂度也为O(n)。</li>
</ul>
<p>实际上，在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。如果我们将多次删除操作集中在一起执行，删除的效率是不是会提高很多呢？<br>我们继续来看例子。数组a[10]中存储了8个元素：a,b,c,d,e,f,g,h。现在我们要依次删除a,b,c三个元素。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/05数组：为什么很多编程语言中数组都从0开始编号？/删除.png" alt></p>
<p>为了避兔d,e,f,g,h这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。</p>
<h3 id="警惕数组的访问越界问题"><a href="#警惕数组的访问越界问题" class="headerlink" title="警惕数组的访问越界问题"></a>警惕数组的访问越界问题</h3><p>了解了数组的几个基本操作后，我们来聊聊数组访问越界的问题。<br>首先，我们来这段C语言代码的运行结果：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(; i&lt;=<span class="number">3</span>; i++)&#123;</span><br><span class="line">        arr[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这段代码的运行结果并非是打印三行“hello world”,而是会无限打印“hello world”。这是为什么呢？<br>因为，数组大小为3，a[0]，a[1]，a[2]，而我们的代码因为书写错误，导致for循环的结束条件错写为了i&lt;=3而非i&lt;3，所以当i=3时，数组a[3]访问越界。<br>我们知道，在C语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的。根据我们前面讲的数组寻址公式，a[3]也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量i的内存地址，那么a[3]=0就相当于i=0，所以就会导致代码无限循环</p>
<blockquote>
<p>(解释：<br>1.不同的语言对数组访问越界的处理方式不同，即便是同一种语言，不同的编译器处理的方式也不同。<br>2.C语言中，数组访问越界的处理是未决。并不一定是错。<br>3.该例子，栈是由高到低位增长的，所以，i和数组的数据从高位地址到低位地址依次是：i, a[2], a[1], a[0]。a[3]通过寻址公式，计算得到地址正好是i的存储地址，所以a[3]=0，就相当于i=0.)</p>
</blockquote>
<p>数组越界在C语言中是一种未决行为，并没有规定数组访问越界时编译器应该如何处理。因为，访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误。<br>这种情况下，一般都会出现莫名其妙的逻辑错误，就像我们刚刚举的那个例子， debug的难度非常的大。而且，很多计算机病毒也正是利用到了代码中的数组越界可以访问非法地址的漏洞，来攻击系统，所以写代码的时候一定要警惕数组越界。<br>但并非所有的语言都像C一样，把数组越界检查的工作丢给程序员来做，像Java本身就会做越界检查，比如下面这几行Java代码，就会抛出java.lang.ArraylndexOutofBoundsException<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">a[<span class="number">3</span>] = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="容器能否完全替代数组？"><a href="#容器能否完全替代数组？" class="headerlink" title="容器能否完全替代数组？"></a>容器能否完全替代数组？</h3><p>这里我拿Java语言来举例。如果你是Java工程师，几乎天天都在用 ArrayList，对它应该非常熟悉。那它与数组相比，到底有哪些优势呢？<br>我个人觉得， ArrayList最大的优势就是<strong>可以将很多数组操作的细节封装起来</strong>。比如前面提到的数组插入、删除数据时需要搬移其他数据等。另外，它还有一个优势，就是支持<strong>动态扩容</strong>.<br>数组本身在定义的时候需要预先指定大小，因为需要分配连续的内存空间。如果我们申请了大小为10的数组，当第11个数据需要存储到数组中时，我们就需要重新分配一块更大的空间，将原来的数据复制过去，然后再将新的数据插入。<br>如果使用 ArrayList，我们就完全不需要关心底层的扩容逻辑， ArrayList已经帮我们实现好了。每次存储空间不够的时候，它都会将空间自动扩容为1.5倍大小。<br>不过，这里需要注意一点，因为扩容操作涉及內存申请和数据搬移，是比较耗时的。所以，如果事先能确定需要存储的数据大小，最好在创建 ArrayList的时候事先指定数据大小。<br>比如我们要从数据库中取出10000条数据放入 ArrayList。我们看下面这几行代码，你会发现，相比之下，事先指定数据大小可以省掉很多次內存申请和数据搬移操作。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ArrayList&lt;User&gt; users = <span class="keyword">new</span> ArrayList(<span class="number">10000</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">  users.add(xxx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>作为高级语言编程者，是不是数组就无用武之地了呢？当然不是，有些时候，用数组会更合适些，作者总结了几点自己的经验：</p>
<p>1.Java ArrayList无法存储基本类型，比如int、long，需要封装为 Integer、Long粪，而Autoboxing、 Unboxing则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。<br>2.如果数据大小事先已知，并且对数据的操作非常简单，用不到 Array List提供的大部分方法，也可以直接使用数组。<br>3.还有一个是我个人的喜好，当要表示多维数组时，用数组往往会更加直观。比如 Object array：而用容器的话则需要这样定义：ArrayList&lt; ArrayList <object> &gt; array。<br>总结一下就是，对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。但如果你是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首</object></p>
<h3 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h3><p>现在我们来思考开篇的问题：为什么大多数编程语言中，数组要从0开始编号，而不是从1开始呢？<br>从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（ offset）”。前面也讲到，如果用a来表示数组的首地址，a[0]就是偏移为0的位置，也就是首地址，a[k]就表示偏移k个type_size的位置，所以计算a[k]的内存地址只需要用这个公式<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a[k]_address &#x3D; base_address + k * type_size</span><br></pre></td></tr></table></figure><br>但是，如果数组从1开始计数，那我们计算数组元素a[k]的内存地址就会变为:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a[k]_address &#x3D; base_address + (k-1)*type_size</span><br></pre></td></tr></table></figure><br>对比两个公式，我们不难发现，从1开始编号，每次随机访问数组元素都多了一次减法运算，对于CPU来说，就是多了一次减法指令。<br>数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从0开始编号，而不是从1开始。<br>历史原因：C语言设计者用0开始计数数组下标，之后的Java、 JavaScript等高级语言都效仿了C语言，或者说，为了在一定程度上减少C语言程序员学习Java的学习成本，因此继续沿用了从0开始计数的习惯。实际上，很多语言中数组也并不是从0开始计数的，比如 Matlab。甚至还有一些语言支持负数下标，比如 Python。</p>
<h3 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h3><p>我们今天学习了数组。它可以说是最基础、最简单的数据结构了。<strong>数组用一块连续的内存空间，来存储相同类型的一组数据，最大的特点就是支持随机访问，但插入、删除操作也因此变得比较低效，平均情况时间复杂度为O(n)</strong>。在平时的业务开发中，我们可以直接使用编程语言提供的容器类，但是，如果是特别底层的开发，直接使用数组可能会更合适.</p>
<blockquote>
<p>面试纠错：<br>1、数组中的元素存在一个连续的内存空间中，而链表中的元素可以不存在于连续的内存空间。<br>2、数组支持随机访问，根据下标随机访问的时间复杂度是O(1)；链表适合插入、删除操作，时间复杂度为O(1）。<br>数组的内存寻址公式？<br>一维数组：a[i]_address=base_address+i<em>type_size<br>二维数组：二维数组假设是m</em>n， a[i][j]_address=base_address + (i<em>n+j)</em>type_size<br>三维数组：三维数组假设是m<em>n</em>q， a[i][j][k]_address=base_address + (i<em>n</em>q + j<em>q + k)</em>type_size</p>
</blockquote>
]]></content>
      <categories>
        <category>DataStructureAndAlgorithm</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>07链表（下）：如何轻松写出正确的链表代码？</title>
    <url>/articles/25623a31.html/</url>
    <content><![CDATA[<blockquote>
<p>声名：本文大部分内容出自于极客时间网站王争的专栏《数据结构与算法之美》，这里本人主要记录自己的学习过程，添加个人见解，并作为自己的学习笔记。如有侵权，立马删除。</p>
</blockquote>
<p>虽然知道了链表的相关知识，但是想要写好链表代码并不是容易的事儿，尤其是那些复杂的链表操作，比如链表反转、有序链表合并等，写的时候非常容易出错。</p>
<a id="more"></a>
<p>当然，自己有决心并且付出精力是成功的先决条件，除此之外，我们还需要一些方法和技巧。作者总结了<strong>几个写链表代码技巧</strong>。如果你能熟练掌握这几个技巧，加上自己的主动和坚持，轻松拿下链表代码完全没有问题。</p>
<h3 id="技巧一：理解指针或引用的含义"><a href="#技巧一：理解指针或引用的含义" class="headerlink" title="技巧一：理解指针或引用的含义"></a>技巧一：理解指针或引用的含义</h3><p>事实上，看懂链表的结构并不是很难，但是一旦把它和指针混在一起，就很容易让人摸不着头脑。所以，要想写对链表代码，首先就要理解好指针。<br>我们知道，有些语言有“指针”的概念，比如C语言；有些语言没有指针，取而代之的是引用”，比如Java、 Python。不管是“指针”还是“引用”，实际上，它们的意思都是一样的，都是存储所指对象的内存地址。实际上，对于指针的理解，我们只需要记住下面这句话就可以了：<br><strong>将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量</strong></p>
<p>在编写链表代码的时候，我们经常会有这样的代码：p-&gt;next=q。这行代码是说，p结点中的next指针存储了q结点的内存地址。</p>
<p>还有一个更复杂的，也是我们写链表代码经常会用到的：p-&gt;next=p-&gt;next-&gt;next。这行代码表示，p结点的next指针存储了p结点的下下一个结点的内存地址。</p>
<h3 id="技巧二：警惕指针丟失和内存泄漏"><a href="#技巧二：警惕指针丟失和内存泄漏" class="headerlink" title="技巧二：警惕指针丟失和内存泄漏"></a>技巧二：警惕指针丟失和内存泄漏</h3><p>下知道你有没有这样的感觉，写链表代码的时候，指针指来指去，一会儿就不知道指到哪里了。所以，我们在写的时候，一定注意不要弄丢了指针。<br>指针往往都是怎么弄丢的呢？拿单链表的插入操作为例来分析一下。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/07链表（下）：如何轻松写出正确的链表代码？/插入节点.png" alt><br>如图所示，我们希望在结点a和相邻的结点b之间插入结点x，假设当前指针p指向结点a。如果我们将代码实现变成下面这个样子，就会发生指针丢失和内存泄露。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p-&gt;next &#x3D; x;  &#x2F;&#x2F; 将p的next指针指向x结点；</span><br><span class="line">x-&gt;next &#x3D; p-&gt;next;  &#x2F;&#x2F; 将x的结点的next指针指向b结点；</span><br></pre></td></tr></table></figure><br>这里p-&gt;next指针在完成第一步操作之后，已经不再指向结点b了，而是指向结点x。第2行代码相当于将ⅹ赋值给x-&gt;next，自己指向自己。因此，整个链表也就断成了两半，从结点b往后的所有结点都无法访问到了。</p>
<p>对于有些语言来说，比如C语言，内存管理是由程序员负责的，如果没有手动释放结点对应的内存空间，就会产生内存泄露。所以，我们<strong>插入结点时，一定要注意操作的顺序</strong>，要先将结点x的next指针指向结点b，再把结点a的next指针指向结点x，这样才不会丢失指针，导致内存泄漏。所以，对于刚刚的插λ代码，我们只需要把第1行和第2行代码的页序颠倒一下就可以了。</p>
<p>同理，删除链表结点时，也一定要记得手动释放内存空间，否则，也会出现内存泄漏的问题。当然，对于像Java这种虚拟机自动管理內存的编程语言来说，就不需要考虑这么多了。</p>
<h3 id="技巧三：利用哨兵简化实现难度"><a href="#技巧三：利用哨兵简化实现难度" class="headerlink" title="技巧三：利用哨兵简化实现难度"></a>技巧三：利用哨兵简化实现难度</h3><p>首先，我们先来回顾一下单链表的插入和删除操作。如果我们在结点p后面插入一个新的结点，只需要下面两行代码就可以搞定<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new_node-&gt;next &#x3D; p-&gt;next;</span><br><span class="line">p-&gt;next &#x3D; new_node;</span><br></pre></td></tr></table></figure><br>但是，当我们要向一个空链表中插入第一个结点，刚刚的逻辑就不能用了。我们需要进行下面这样的特殊处理，其中head表示链表的头结点。所以，从这段代码，我们可以发现，对于单链表的插入操作，第一个结点和其他结点的插入逻辑是不一样的<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (head &#x3D;&#x3D; null) &#123;</span><br><span class="line">  head &#x3D; new_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们再来看单链表结点删除操作。如果要删除结点p的后继结点，我们只需要一行代码就可以搞定<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p-&gt;next &#x3D; p-&gt;next-&gt;next;</span><br></pre></td></tr></table></figure><br>但是，如果我们要删除链表中的最后一个结点，前面的删除代码就不work了。跟插入类似，我们也需要对于这种情况特殊处理。写成代码是这样子的<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (head-&gt;next &#x3D;&#x3D; null) &#123;</span><br><span class="line">   head &#x3D; null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>从前面的一步—步分析，我们可以看出，<strong>针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理</strong>。这样代码实现起来就会很繁琐，不简洁，而且也容易因为考虑不全而出错。如何来解决这个问题呢？</p>
<p>技巧三中提到的哨兵就要登场了。哨兵，解决的是国家之间的边界问题。同理，这里说的哨兵也是解决“边界问题”的，不直接参与业务逻辑。</p>
<p>还记得如何表示一个空链表吗？head=null表示链表中没有结点了。其中head表示头结点指针，指向链表中的第一个结点</p>
<p>如果我们引入哨兵结点，在任何时候，不管链表是不是空，head指针都会一直指向这个哨兵结点。我们也把这种有哨兵结点的链表叫<strong>带头链表</strong>。相反，没有哨兵结点的链表就叫作<strong>不带头链表</strong></p>
<p>下图是一个带头链表，哨兵结点是不存储数据的。因为哨兵结点一直存在，所以插入第一个结点和插入其他结点，删除最后一个结点和删除其他结点，都可以统一为相同的代码实现逻辑了<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/07链表（下）：如何轻松写出正确的链表代码？/带头链表.png" alt></p>
<p>实际上，这种利用哨兵简化编程难庋的技巧，在很多代码实现中都有用到，比如插入排序、归并排序、动态规划等。</p>
<p>代码一：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在数组a中，查找key，返回key所在的位置</span></span><br><span class="line"><span class="comment">// 其中，n表示数组a的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span>* a, <span class="keyword">int</span> n, <span class="keyword">char</span> key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 边界条件处理，如果a为空，或者n&lt;=0，说明数组中没有数据，就不用while循环比较了</span></span><br><span class="line">  <span class="keyword">if</span>(a == null || n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 这里有两个比较操作：i&lt; n和a[i]==key.</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] == key) &#123;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    ++i;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码二：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在数组a中，查找key，返回key所在的位置</span></span><br><span class="line"><span class="comment">// 其中，n表示数组a的长度</span></span><br><span class="line"><span class="comment">// 举2个例子，可以拿例子走一下代码</span></span><br><span class="line"><span class="comment">// a = &#123;4, 2, 3, 5, 9, 6&#125;  n=6 key = 7</span></span><br><span class="line"><span class="comment">// a = &#123;4, 2, 3, 5, 9, 6&#125;  n=6 key = 6</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span>* a, <span class="keyword">int</span> n, <span class="keyword">char</span> key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(a == null || n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 这里因为要将a[n-1]的值替换成key，所以要特殊处理这个值</span></span><br><span class="line">  <span class="keyword">if</span> (a[n<span class="number">-1</span>] == key) &#123;</span><br><span class="line">    <span class="keyword">return</span> n<span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 把a[n-1]的值临时保存在变量tmp中，以便之后恢复。tmp=6。</span></span><br><span class="line">  <span class="comment">// 之所以这样做的目的是：希望find()代码不要改变a数组中的内容</span></span><br><span class="line">  <span class="keyword">char</span> tmp = a[n<span class="number">-1</span>];</span><br><span class="line">  <span class="comment">// 把key的值放到a[n-1]中，此时a = &#123;4, 2, 3, 5, 9, 7&#125;</span></span><br><span class="line">  a[n<span class="number">-1</span>] = key;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// while 循环比起代码一，少了i&lt; n这个比较操作</span></span><br><span class="line">  <span class="keyword">while</span> (a[i] != key) &#123;</span><br><span class="line">    ++i;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 恢复a[n-1]原来的值,此时a= &#123;4, 2, 3, 5, 9, 6&#125;</span></span><br><span class="line">  a[n<span class="number">-1</span>] = tmp;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (i == n<span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果i == n-1说明，在0...n-2之间都没有key，所以返回-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否则，返回i，就是等于key值的元素的下标</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对比两段代码，在字符串a很长的时候，比如几万、几十万，你觉得哪段代码运行得更快点呢？答案是代码二，因为两段代码中执行次数最多就是 while循环那—部分。第二段代码中，我们通过一个哨兵a[n-1]=key，成功省掉了一个比较语句i&lt; n,不要小看这一条语句，当累积执行万次、几十万次时，累积的时间就很明显了。</p>
<p>当然，这只是为了举例说明哨兵的作用，你写代码的时候千万不要写第二段那样的代码，为可读性太差了。大部分情况下，我们并不需要如此追求极致的性能。</p>
<h3 id="技巧四：重点留意边界条件处理"><a href="#技巧四：重点留意边界条件处理" class="headerlink" title="技巧四：重点留意边界条件处理"></a>技巧四：重点留意边界条件处理</h3><p>软件开发中，代码在一些边界或者异常情况下，最容易产生Bug。链表代码也不例外。要实现没有Bug的链表代码，一定要在编写的过程中以及编写完成之后，检查边界条件是否考虑全面，以及代码在边界条件下是否能正确运行。</p>
<p>经常用来检查链表代码是否正确的边界条件有这样几个:</p>
<ul>
<li>如果链表为空时，代码是否能正常工作？</li>
<li>如果链表只包含一个结点时，代码是否能正常工作？</li>
<li>如果链表只包含两个结点时，代码是否能正常工作？</li>
<li>代码逻辑在处理头结点和尾结点的时候，是否能正常工作？</li>
</ul>
<p>当你写完链表代码之后，除了看下你写的代码在正常的情况下能否工作，还要看下在上面列举的几个边界条件下，代码仍然能否正确工作。如果这些边界条件下都没有问题，那基本上可以认为没有问题了。</p>
<h3 id="技巧五：举例画图，辅助思考"><a href="#技巧五：举例画图，辅助思考" class="headerlink" title="技巧五：举例画图，辅助思考"></a>技巧五：举例画图，辅助思考</h3><p>对于稍微复杂的链表操作，比如前面我们提到的单链表反转，指针一会儿指这，一会儿指那，一会儿就被绕晕了。总感觉脑容量不够，想不清楚。所以这个时候就要使用大招了，<strong>举例法</strong>和<strong>画图法</strong></p>
<p>可以找一个具体的例子，把它画在纸上，释放一些脑容量，留更多的给逻辑思考，这样就会感觉到思路清晣很多。比如往单链表中插λ一个数据这样—个操作，我一般都是把各种情况都举一个例子，画出插入前和插入后的链表变化，如图所示<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/07链表（下）：如何轻松写出正确的链表代码？/画图.png" alt></p>
<h3 id="技巧六：多写多练，没有捷径"><a href="#技巧六：多写多练，没有捷径" class="headerlink" title="技巧六：多写多练，没有捷径"></a>技巧六：多写多练，没有捷径</h3><p>如果已经理解并掌握了我前面所讲的方法，但是手写链表代码还是会出现各种各样的错误，也不要着急。因为新手开始学的时候，这种状况会持续一段时间</p>
<p>作者精选了5个常见的链表操作。只要把这几个操作都能写熟练，不熟就多写几遍，练多了也就不会害怕写链表代码。</p>
<ul>
<li>单链表反转</li>
<li>链表中环的检测</li>
<li>两个有序的链表合并</li>
<li>删除链表倒数第n个结点</li>
<li>求链表的中间结点</li>
</ul>
<h3 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h3><p>主要学习了正确写链表代码的六个技巧。分别是理解指针或引用的含义、警惕指针丢失和内存泄漏、利用哨兵简化实现难度、重点留意边界条件处理，以及举例画图、辅助思考，还有多写多练。写链表代码是最考验逻辑思维能力的。因为，链表代码到处都是指针的操作、边界条件的处理，稍有不慎就容易产生Bug。链表代码写得好坏，可以看出一个人写代码是否够细心，考虑问题是否全面，思维是否缜密。所以，这也是很多面试官喜欢让人手写链表代码的原因。所以一定要自己写代码实现一下，才有效果。</p>
]]></content>
      <categories>
        <category>DataStructureAndAlgorithm</category>
      </categories>
      <tags>
        <tag>LinkList</tag>
      </tags>
  </entry>
  <entry>
    <title>06链表（上）：如何实现LRU缓存淘汰算法？</title>
    <url>/articles/79fba95f.html/</url>
    <content><![CDATA[<blockquote>
<p>声名：本文大部分内容出自于极客时间网站王争的专栏《数据结构与算法之美》，这里本人主要记录自己的学习过程，添加个人见解，并作为自己的学习笔记。如有侵权，立马删除。</p>
</blockquote>
<p>链表(Linked list),这个是比数组稍微复杂点的数据结构，它有一个经典的应用场景，那就是LRU缓存淘汰算法。</p>
<a id="more"></a>
<p>缓存是一种提高数据读取性的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的CPU缓存、数据库缓存、浏览器缓存等等。</p>
<p>缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？这就需要缓存淘汰策略来决定。常见的策略有三种：先进先出策略FIFO(First in， First out)、最少使用策略LFU(Least Frequently Used)、最近最少使用策略LRU(Least Recently Used)。</p>
<h3 id="数组和链表"><a href="#数组和链表" class="headerlink" title="数组和链表"></a>数组和链表</h3><p>数组和链表都是非常基础、非常常用的数据结构,我们常常会放到一块儿来比较；那么两者有什么区别呢？<br>从<strong>底层的存储结构</strong>来看一看<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/06链表（上）：如何实现LRU缓存淘汰算法？/内存分布.png" alt><br>从图中我们看到，数组需要一块<strong>连续的内存空间</strong>来存储，对内存的要求比较高。如果我们申请一个100MB大小的数组，当内存中没有连续的、足够大的存储空间时，即便内存的剩余总可用空间大于100MB，仍然会申请失败。<br>而链表恰恰相反，它并不需要一块连续的内存空间，它通过“指针”将一组<strong>零散的内存块</strong>串联起来使用，所以如果我们申请的是100MB大小的链表，根本不会有问题。</p>
<h3 id="常见的链表结构"><a href="#常见的链表结构" class="headerlink" title="常见的链表结构"></a>常见的链表结构</h3><h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><p>首先我们来看下最简单、最常用的单链表，我们刚刚讲到，链表通过指针将<strong>一组零散的内存块</strong>串联在一起。其中，我们把内存块称为链表的“<strong>结点</strong>”。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。如图所示，我们把这个记录下个结点地址的指针叫作<strong>后继指针next</strong>。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/06链表（上）：如何实现LRU缓存淘汰算法？/单链表.png" alt="单链表"><br>从单链表图中，我们可以发现，其中有两个结点是比较特殊的，它们分别是第一个结点和最后一个结点。我们习惯性地把第一个结点叫作<strong>头结点</strong>，把最后一个结点叫作<strong>尾结点</strong>。其中，头结点用来记录链表的基地址。有了它，我们就可以遍历得到整条链表。而尾结点特殊的地方是：指针不是指向下—个结点，而是指向一个<strong>空地址NULL</strong>，表示这是链表上最后一个结点。</p>
<p>与数组一样，链表也支持数据的<strong>查找、插入和删除</strong>操作</p>
<p>我们知道，在进行数组的插入、删除操作时，为了保持内存数据的连续性，需要做大量的数据搬移，所以时间复杂度是O(n)。而在链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空冋本身就不是连续的。所以，在链表中插入和删除一个数据是非常快速的。</p>
<p>针对链表的插入和删除操作，我们只需要考虑相邻节点的指针改变。所以对应的时间复杂度为O(1)。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/06链表（上）：如何实现LRU缓存淘汰算法？/插入删除.png" alt><br>但是，有利就有弊。链表要想随机访问第k个元素，就没有数组那么高效了。因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。</p>
<p>你可以把链表想象成一个队伍，队伍中的每个人都只知道自己后面的人是谁，所以当我们希望知道排在第k位的人是谁的时候，我们就需要从第一个人开始，一个一个地往下数。所以，链表随机访问的性能没有数组好，需要O(n)的时间复杂度。</p>
<h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><p><strong>循环链表是一种特殊的单链表</strong>。实际上，循环链表也很简单。它跟单链表唯一的区别就在尾结点。我们知道，单链表的尾结点指针指址，表示这就是最后的结点了。而循环链表的尾结点指针是指向链表的头结点。从循环链表图中，我们可以看出，它像一个环一样首尾相连，所以叫作“循环”链表。</p>
<p><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/06链表（上）：如何实现LRU缓存淘汰算法？/循环链表.png" alt></p>
<p>单链表相比，循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。比如菩名的<a href="https://baike.baidu.com/item/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98/3857719?fr=aladdin" target="_blank" rel="noopener">@约瑟夫可题</a>。尽管用单链表也可以实现，但是用循环链表实现的话，代码就会简洁很多。</p>
<h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><p>双向链表是在实际软件开发中，更加常用的链表结构。</p>
<p>单向链表只有一个方向，结点只有一个后继指针next指向后面的结点。而双向链表，顾名思义，它支持两个方向，每个结点不止有一个后继指针next指向后面的结点，还有一个前驱指针prev指向前面的结点。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/06链表（上）：如何实现LRU缓存淘汰算法？/双向链表.png" alt></p>
<p>从图中可以看出来，双向链表需要额外的两个空间来存储后继结点和前驱结点的地址，所以如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样也带来了双向链表操作的灵活性。那相比单链表，双向链表适合解决哪种问题呢？<br>从结构上来看，双向链表可以支持O(1)时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。<br>你可能会说，我刚讲到单链表的插入、删除操作的时间复杂度已经是O(1)了，双向链表还能再怎么高效呢？别着急，刚刚的分析比较偏理论，很多数据结构和算法书籍中都会这么讲，但是这种说法实际上是不准确的，或者说是有先决条件的.</p>
<p>我们来看下<strong>删除操作</strong><br>在实际的软件开发中，从链表中删除一个数据无外乎这两种情况</p>
<ul>
<li>删除结点中“值等于某个给定值”的结点；</li>
<li>删除给定指针指向的节点</li>
</ul>
<p>对于第一种情况，不管是单链表还是双向链表，为了查找到值等于给定值的结点，都需要从头结点开始一个一个依次遍历对比，直到找到值等于给定值的结点，然后再通过我前面讲的指针操作将其删除。<br>尽管单纯的删除操作时间复杂度是O(1)，但遍历查找的时间是主要的耗时点，对应的时间复度为O(n)。根据时间复杂度分析中的加法法则，删除值等于给定值的结点对应的链表操作的总时间复杂度为O(n).</p>
<p>对于第二种情况，我们已经找到了要删除的结点，但是删除某个结点q需要知道其前驱结点，而单链表并不支持直接获取前驱结点，所以，为了找到前驱结点，我们还是要从头结点开始遍历链表，直到p-&gt;next=q，说明p是q的前驱结点.</p>
<p>但是对于双向链表来说，这种情况就比较有优势了。因为双向链表中的结点已经保存了前驱结点的指针，不需要像单链表那样遍历。所以，针对第二种情况，单链表删除操作需要O（n）的时间复杂度，而双向链表只需要在O（1）的时间复杂度内就搞定了.</p>
<p>同理，如果我们希望在链表的某个指定结点前面插入一个结点，双向链表比单链表有很大的优势。双向链表可以在O（1）时间复杂度搞定，而单向链表需要O（n）的时间复杂度。除了插入、删除操作有优势之外，对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。因为，我们可以记录上次查找的位置p，每次查询时，根据要查找的值与p的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据</p>
<p>现在，你有没有觉得双向链表要比单链表更加高效呢？这就是为什么在实际的软件开发中，双向链表尽管比较费内存，但还是比单链表的应用更加广泛的原因。如果你熟悉Java语言，你肯定用过 LinkedHashMap这个容器。如果你深入研究 LinkedHashMap的实现原理，就会发现其中就用到了双向链表这种数据结构。</p>
<p>实际上，这里有一个更加重要的知识点需要我们掌握，那就是用<strong>空间换时问</strong>的设计思想。当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高、但时间复杂度相对很低的算法或者数据结构。相反，如果內存比较紧缺，比如代码跑在手机或者单片机上，这个时候，就要反过来用时间换空间的设计思路</p>
<p>还是开篇缓存的例子。缓存实际上就是利用了<strong>空间换时间</strong>的设计思想。如果我们把数据存储在硬盘上，会比较节省内存，但每次查找数据都要询问一次硬盘，会比较慢。但如果我们通过缓存技术，事先将数据加载在内存中，虽然会比较耗费内存空间，但是每次数据查询的速度就大大提高了</p>
<p>所以总结一下，对于执行较慢的程序，可以通过消耗更多的内存（空间换时间）来进行优化；而消耗过多内存的程序，可以通过消耗更多的时间（时间换空间）来降低内存的消耗。</p>
<h4 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h4><p>顾名思义，双向循环链表就是将循环链表和双向链表整合后的新的数据结构</p>
<p><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/06链表（上）：如何实现LRU缓存淘汰算法？/双向循环链表.png" alt></p>
<h3 id="链表VS数组"><a href="#链表VS数组" class="headerlink" title="链表VS数组"></a>链表VS数组</h3><p>数组和链表是两种截然不同的内存组织方式。正是因为内存存储的区别，它们插入、删除、随机访问操作的时间复杂度正好相反。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/06链表（上）：如何实现LRU缓存淘汰算法？/链表vs数组.png" alt></p>
<p>不过，数组和链表的对比，并不能局限于时间复杂度。而且，在实际的软件开发中，不能仅仅利用复杂度分析就决定使用哪个数据结构来存储数据。数组简单易用，在实现上使用的是连续的内存空间，可以借助CPU的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对CPU缓存不友好，没法有效预读。</p>
<p>数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（ out of memory）”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容，这也是它与数组最大的区别。</p>
<p>上节说到Java中的 ArrayList容器，也可以支持动态扩容啊？然而当我们往支持动态扩容的数组中插入一个数据时，如果数组中没有空闲空间了，就会申请一个更大的空间，将数据拷贝过去，而数据拷贝的操作是非常耗时的。</p>
<p>举一个稍微极端的例子。如果我们用 ArrayList存储了了1GB大小的数据，这个时候已经没有空闲空间了，当我们再插入数据的时候， ArrayList会申请一个1.5GB大小的存储空间并且把原来那1GB的数据拷贝到新申请的空间上。这就会很耗时了。</p>
<p>除此之外，如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以內存消耗会翻倍。而且对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是Java语言，就有可能会导致频繁的GC（ Garbage Collection，垃圾回收）</p>
<p>所以，在我们实际的开发中，针对不同类型的项目，要根据具体情况，权衡究竟是选择数组还是链表</p>
<h3 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h3><p>如何基于链表实现LRU缓存淘汰算法？<br>解答：思路是这样的：我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。<br>1.如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。<br>2.如果此数据没有在缓存链表中，又可以分为两种情况：</p>
<ul>
<li>如果此时缓存未满，则将此结点直接插入到链表的头部；</li>
<li>如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。<br>这样我们就用链表实现了一个LRU缓存。现在我们来看下缓存访问的时间复杂度是多少。因为不管缓存有没有满，我们都需要遍历遍链表，所以这种基于链表的实现思路，缓存访问的时间复杂度为O（n)。实际上，我们可以继续优化这个实现思路，比如引入<strong>散列表</strong>（ Hash table）来记录每个数据的位置，将缓存访问的时间复杂度降到O（1）。这个后面会学习到。</li>
</ul>
<h3 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h3><p>今天我们学习了一种跟数组“相反”的数据结构，链表。它跟数组一样，也是非常基础、非常常用的数据结构。不过链表要比数组稍微复杂，从普通的单链表衍生出来好几种链表结构，比如双向链表、循环链表、双向循环链表，和数组相比，链表更适合插入、删除操作频繁的场景，查询的时间复杂度较高。不过，在具体软件开发中，要对数组和链表的各种性能进行对比，综合来选择使用两者中的哪一个。</p>
]]></content>
      <categories>
        <category>DataStructureAndAlgorithm</category>
      </categories>
      <tags>
        <tag>Linklist</tag>
      </tags>
  </entry>
  <entry>
    <title>08栈：如何实现浏览器的前进和后退功能？</title>
    <url>/articles/6f14fc65.html/</url>
    <content><![CDATA[<blockquote>
<p>声名：本文大部分内容出自于极客时间网站王争的专栏《数据结构与算法之美》，这里本人主要记录自己的学习过程，添加个人见解，并作为自己的学习笔记。如有侵权，立马删除。</p>
</blockquote>
<a id="more"></a>
<h3 id="问题导引"><a href="#问题导引" class="headerlink" title="问题导引"></a>问题导引</h3><p>当你用浏览器访问多个子页面的时候，就会有前进、后退功能，当你依次访问完一串页面a-b-c之后，点击浏览器的后退按钮，就可以查看之前浏览过的页面b和a。当你后退到页面a，点击前进按钮，就可以重新查看页面b和c。但是，如果你后退到页面b后，点击了新的页面d，那就无法再通过前进、后退功能查看页面c了。</p>
<font color="#FF8C00" size="3">假设你是 Chrome浏览器的开发工程师，你会如何实现这个功能呢？</font>

<h3 id="如何理解“栈”"><a href="#如何理解“栈”" class="headerlink" title="如何理解“栈”"></a>如何理解“栈”</h3><p>关于“栈”，一个非常贴切的例子就是一摞叠在一起的盘子。我们平时放盘子的时候，都是从下往上一个个放；取的时候，我们是从上往下一个一个地依次取，不能从中间任意抽出。<strong>后进者先出，先进者后岀</strong>，这就是典型的“栈”结构。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/08栈：如何实现浏览器的前进和后退功能？/栈.png" alt></p>
<p>从栈的操作特性上来看，<strong>栈是一种“操作受限”的线性表</strong>，只允许在一端插入和删除数据。</p>
<p>相比数组和链表，栈带给我们的只有限制，并没有任何优势。那我们直接使用数组或者链表不就好了吗？为什么还要用这个“操作受限”的“栈”呢？</p>
<p>事实上，从功能上来说，数组或链表确实可以替代栈，但你要知道，特定的数据结构是对特定场景的抽象，而且，数组或链表暴露了太多的操作接口，操作上的确灵活自由，但使用时就比较不可控，自然也就更容易出错。</p>
<p><strong>当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构。</strong></p>
<h3 id="如何实现一个“栈”"><a href="#如何实现一个“栈”" class="headerlink" title="如何实现一个“栈”"></a>如何实现一个“栈”</h3><p>从刚才栈的定义里，我们可以看出，栈主要包合两个操作，<strong>入栈和出栈</strong>，也就是在栈顶插入个数据和从栈顶删除一个数据。理解了栈的定义之后，如何用代码实现一个栈呢？</p>
<p>实际上，栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作<strong>顺序栈</strong>，用链表实现的栈，我们叫作<strong>链式栈</strong>。</p>
<p>这里实现一个基于数组的顺序栈,这段代码是用Java来实现的，但是不涉及任何高级语法，并且还用中文做了详细的注释.<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基于数组实现的顺序栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String[] items;  <span class="comment">// 数组</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> count;       <span class="comment">// 栈中元素个数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> n;           <span class="comment">//栈的大小</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化数组，申请一个大小为n的数组空间</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> String[n];</span><br><span class="line">    <span class="keyword">this</span>.n = n;</span><br><span class="line">    <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入栈操作</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">push</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数组空间不够了，直接返回false，入栈失败。</span></span><br><span class="line">    <span class="keyword">if</span> (count == n) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 将item放到下标为count的位置，并且count加一</span></span><br><span class="line">    items[count] = item;</span><br><span class="line">    ++count;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 出栈操作</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 栈为空，则直接返回null</span></span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 返回下标为count-1的数组元素，并且栈中元素个数count减一</span></span><br><span class="line">    String tmp = items[count-<span class="number">1</span>];</span><br><span class="line">    --count;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>来分析下栈的时间复杂度和空间复杂度。</p>
<p>不管是顺序栈还是链式栈，我们存储数据只需要一个大小为η的数组就够了。在入栈和出栈过程中，只需要一两个临时变量存储空间，所以空间复杂度是O（1）。</p>
<p>注意，这里存储数据需要一个大小为n的数组，并不是说空间复杂度就是O(n)。因为，这n个空间是必须的，无法省掉。所以我们说空间复杂度的时候，是指除了原本的数据存储空外，算法运行还需要额外的存储空间。</p>
<p>时间复杂度也不难。不管是顺序栈还是链式栈，入栈、出栈只涉及栈顶个别数据的操作，所以时间复杂度都是O（1）。</p>
<h3 id="支持动态扩容的顺序栈"><a href="#支持动态扩容的顺序栈" class="headerlink" title="支持动态扩容的顺序栈"></a>支持动态扩容的顺序栈</h3><p>刚才那个是基于数组实现的栈，是一个固定大小的栈，也就是说，在初始化栈时需要事先指定栈的大小。当栈满之后，就无法再往栈里添加数据了。尽管链式栈的大小不受限，但要存储next指针，内存消耗相对较多。所以有必要研究下支持动态扩容的顺序栈。</p>
<p>我们在数组那一节，实现一个支持动态扩容的数组是这样做的，当数组空间不够时，我们就重新申请一块更大的内存，将原来数组中数据统统拷贝过去。这样就实现了个支持动态扩容的数组。</p>
<p>所以，如果要实现一个支持动态扩容的栈，我们只需要底层依赖—个支持动态扩容的数组就可以了。当栈满了之后，我们就申请一个更大的数组，将原来的数据搬移到新数组中。这里有一张图，可以对照着理解一下<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/08栈：如何实现浏览器的前进和后退功能？/动态扩容栈.png" alt></p>
<p>实际上，支持动态扩容的顺序栈，我们平时开发中并不常用到，这一小节的重点是复杂度分析。对于复杂度分析，不能死记硬背，要自己掌握分析方法，能自己分析才是真正的掌握了。</p>
<p>对于出栈操作来说，我们不会涉及内存的重新申请和数据的搬移，所以出栈的时间复杂度仍然是O（1）。但是，对于入栈操作来说，情况就不一样了。当栈中有空闲空间时，入栈操作的时间复杂度为O（1）。但当空间不够时，就需要重新申请內存和数据搬移，所以时间复杂度就变成了O（n）。</p>
<p>也就是说，对于入栈操作来说，最好情况时间复杂度是（1），最坏情况时间复杂度是O（m）。这个入栈操作的平均情况下的时间复杂度可以用摊还分析法来分析。</p>
<p>为了分析的方便，我们需要事先做一些假设和定义：</p>
<ul>
<li>栈空间不够时，我们重新申请一个是原来大小两倍的数组；</li>
<li>为了简化分析，假设只有入栈操作没有出栈操作</li>
<li>定义不涉及内存搬移的入栈操作为 simple-push操作，时间复杂度为O（1）</li>
</ul>
<p>如果当前栈大小为K，并且已满，当再有新的数据要入栈时，就需要重新申请2倍大小的内存，并且做K个数据的搬移操作，然后再入栈。但是，接下来的K-1次入栈操作，我们都不需要再重新申请内存和搬移数据，所以这K-1次入栈操作都只需要一个 simple-push操作就可以完成。这里有一张图<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/08栈：如何实现浏览器的前进和后退功能？/入栈时间复杂度.png" alt></p>
<p>以看出来，这K次入栈操作，总共涉及了K个数据的搬移，以及K次 simple push操作。将K个数据搬移均摊到K次入栈操作，那每个入栈操作只需要一个数据搬移和一个 simple-push操作。以此类推，入栈操作的均摊时间复杂度就为o（1）。</p>
<p>通过这个例子的实战分析，也印证了前面讲到的，均摊时间复杂度一般都等于最好情况时间复杂度。因为在大部分情况下，入栈操作的时间复杂度O都是O（1），只有在个别时刻才会退化为O（n），所以把耗时多的入栈操作的时间均摊到其他入栈操作上，平均情况下的耗时就接近O（1）。</p>
<h3 id="栈在函数调用中的应用"><a href="#栈在函数调用中的应用" class="headerlink" title="栈在函数调用中的应用"></a>栈在函数调用中的应用</h3><p>前面讲的都比较偏理论，我们现在来看下，栈在软件工程中的实际应用。栈作为一个比较基础的数据结构，应用场景还是蛮多的。其中，比较经典的一个应用场景就是<strong>函数调用栈</strong>。</p>
<p>我们知道，操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构，用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。为了更好地理解一块来看下这段代码的执行过程。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">1</span>; </span><br><span class="line">   <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">   ret = add(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">   res = a + ret;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%d"</span>, res);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">   sum = x + y;</span><br><span class="line">   <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从代码中我们可以看出，main()函数调用了add()函数，获取计算结果，并且与临时变量a相加，最后打印res的值。为了清晰地看到这个过程对应的函数栈里出栈、入栈的操作，下面的图显示的是，在执行到add()函数时，函数调用栈的情况。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/08栈：如何实现浏览器的前进和后退功能？/栈中函数调用.png" alt></p>
<h3 id="栈在表达式求值中的应用"><a href="#栈在表达式求值中的应用" class="headerlink" title="栈在表达式求值中的应用"></a>栈在表达式求值中的应用</h3><p>我们再来看栈的另一个常见的应用场景，编译器如何利用栈来实现<strong>表达式求值</strong>。</p>
<p>为了方便解释，将算术表达式简化为只包含加减乘除四则运算，比如：34+13*9+44-12/3。对于这个四则运算，我们人脑可以很快求解出答案，但是对于计算机来说，理解这个表达式本身就是个挺难的事儿。</p>
<p>实际上，编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。</p>
<p>如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。</p>
<p>下图3+5*8-6 这个表达式的计算过程：<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/08栈：如何实现浏览器的前进和后退功能？/演示过程.png" alt></p>
<h3 id="栈在括号匹配中的应用"><a href="#栈在括号匹配中的应用" class="headerlink" title="栈在括号匹配中的应用"></a>栈在括号匹配中的应用</h3><p>除了用栈来实现表达式求值，我们还可以借助栈来检查表达式中的括号是否匹配。</p>
<p>我们同样简化一下背景。我们假设表达式中只包含三种括号，圆括号 ()、方括号[]和花括号{}，并且它们可以任意嵌套。比如，{[] ()[{}]}或[{()}([])]等都为合法格式，而{[}()]或[({)]为不合法的格式。那现在给你一个包含三种括号的表达式字符串，如何检查它是否合法呢？</p>
<p>这里也可以用栈来解决。我们用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。</p>
<p>当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式。</p>
<h3 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h3><p>理解了栈的概念，我们再回来看看开篇的思考题，如何实现浏览器的前进、后退功能？其实，用两个栈就可以非常完美地解决这个问题。</p>
<p>我们使用两个栈，X 和 Y，我们把首次浏览的页面依次压入栈 X，当点击后退按钮时，再依次从栈 X 中出栈，并将出栈的数据依次放入栈 Y。当我们点击前进按钮时，我们依次从栈 Y 中取出数据，放入栈 X 中。当栈 X 中没有数据时，那就说明没有页面可以继续后退浏览了。当栈 Y 中没有数据，那就说明没有页面可以点击前进按钮浏览了。</p>
<p>比如你顺序查看了a,b,C三个页面，我们就依次把a,b,c压入栈，这个时候，两个栈的数据就是这个样子</p>
<p><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/08栈：如何实现浏览器的前进和后退功能？/浏览器1.png" alt></p>
<p>当你通过浏览器的后退按钮，从页面 c 后退到页面 a 之后，我们就依次把 c 和 b 从栈 X 中弹出，并且依次放入到栈 Y。这个时候，两个栈的数据就是这个样子：</p>
<p><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/08栈：如何实现浏览器的前进和后退功能？/浏览器2.png" alt></p>
<p>这个时候你又想看页面 b，于是你又点击前进按钮回到 b 页面，我们就把 b 再从栈 Y 中出栈，放入栈 X 中。此时两个栈的数据是这个样子：</p>
<p><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/08栈：如何实现浏览器的前进和后退功能？/浏览器3.png" alt></p>
<p>这个时候，你通过页面 b 又跳转到新的页面 d 了，页面 c 就无法再通过前进、后退按钮重复查看了，所以需要清空栈 Y。此时两个栈的数据这个样子：</p>
<p><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/08栈：如何实现浏览器的前进和后退功能？/浏览器4.png" alt></p>
<h3 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h3><p>栈是一种操作受限的数据结构，只支持入栈和出栈操作。后进先出是它最大的特点。栈既可以通过数组实现，也可以通过链表来实现。不管基于数组还是链表，入栈、出栈的时间复杂度都为 O(1)。除此之外，我们还讲了一种支持动态扩容的顺序栈，需要重点掌握它的均摊时间复杂度分析方法。</p>
<h3 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h3><p>1.我们在讲栈的应用时，讲到用函数调用栈来保存临时变量，为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？</p>
<blockquote>
<p>答：其实，我们不一定非要用栈来保存临时变量，只不过如果这个函数调用符合后进先出的特性，用栈这种数据结构来实现，是最顺理成章的选择。<br>从调用函数进入被调用函数，对于数据来说，变化的是什么呢？是作用域。所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。而要实现这个，用栈就非常方便。在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。</p>
</blockquote>
<p>2.我们都知道，JVM 内存管理中有个“堆栈”的概念。栈内存用来存储局部变量和方法调用，堆内存用来存储 Java 中的对象。那 JVM 里面的“栈”跟我们这里说的“栈”是不是一回事呢？如果不是，那它为什么又叫作“栈”呢？</p>
<h3 id="笔记小结"><a href="#笔记小结" class="headerlink" title="笔记小结"></a>笔记小结</h3><blockquote>
<p>一、什么是栈？<br>1.后进者先出，先进者后出，这就是典型的“栈”结构。<br>2.从栈的操作特性来看，是一种“操作受限”的线性表，只允许在端插入和删除数据。<br>二、为什么需要栈？<br>1.栈是一种操作受限的数据结构，其操作特性用数组和链表均可实现。<br>2.任何数据结构都是对特定应用场景的抽象，数组和链表虽然使用起来更加灵活，但却暴露了几乎所有的操作，难免会引发错误操作的风险。<br>3.所以，当某个数据集合只涉及在某端插入和删除数据，且满足后进者先出，先进者后出的操作特性时，我们应该首选栈这种数据结构。<br>三、如何实现栈？<br>1.栈的API<br>public class Stack<Item> {<br>//压栈<br>public void push(Item item){}<br>//弹栈<br>public Item pop(){}<br>//是否为空<br>public boolean isEmpty(){}<br>//栈中数据的数量<br>public int size(){}<br>//返回栈中最近添加的元素而不删除它<br>public Item peek(){}<br>}<br>2.数组实现（自动扩容）<br>时间复杂度分析：根据均摊复杂度的定义，可以得数组实现（自动扩容）符合大多数情况是O(1)级别复杂度，个别情况是O(n)级别复杂度，比如自动扩容时，会进行完整数据的拷贝。<br>空间复杂度分析：在入栈和出栈的过程中，只需要一两个临时变量存储空间，所以O(1)级别。我们说空间复杂度的时候，是指除了原本的数据存储空间外，算法运行还需要额外的存储空间。<br>实现代码：（见另一条留言）<br>3.链表实现<br>时间复杂度分析：压栈和弹栈的时间复杂度均为O(1)级别，因为只需更改单个节点的索引即可。<br>空间复杂度分析：在入栈和出栈的过程中，只需要一两个临时变量存储空间，所以O(1)级别。我们说空间复杂度的时候，是指除了原本的数据存储空间外，算法运行还需要额外的存储空间。<br>实现代码：（见另一条留言）<br>四、栈的应用<br>1.栈在函数调用中的应用<br>操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构，用来存储函数调用时的临时变量。每进入一个函数，就会将其中的临时变量作为栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。<br>2.栈在表达式求值中的应用（比如：34+13*9+44-12/3）<br>利用两个栈，其中一个用来保存操作数，另一个用来保存运算符。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较，若比运算符栈顶元素优先级高，就将当前运算符压入栈，若比运算符栈顶元素的优先级低或者相同，从运算符栈中取出栈顶运算符，从操作数栈顶取出2个操作数，然后进行计算，把计算完的结果压入操作数栈，继续比较。<br>3.栈在括号匹配中的应用（比如：{}{<a href>()</a>}）<br>用栈保存为匹配的左括号，从左到右一次扫描字符串，当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号，如果能匹配上，则继续扫描剩下的字符串。如果扫描过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。<br>当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明未匹配的左括号为非法格式。<br>4.如何实现浏览器的前进后退功能？<br>我们使用两个栈X和Y，我们把首次浏览的页面依次压如栈X，当点击后退按钮时，再依次从栈X中出栈，并将出栈的数据一次放入Y栈。当点击前进按钮时，我们依次从栈Y中取出数据，放入栈X中。当栈X中没有数据时，说明没有页面可以继续后退浏览了。当Y栈没有数据，那就说明没有页面可以点击前进浏览了。<br>五、思考</Item></p>
<ol>
<li>我们在讲栈的应用时，讲到用函数调用栈来保存临时变量，为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？<br>答：因为函数调用的执行顺序符合后进者先出，先进者后出的特点。比如函数中的局部变量的生命周期的长短是先定义的生命周期长，后定义的生命周期短；还有函数中调用函数也是这样，先开始执行的函数只有等到内部调用的其他函数执行完毕，该函数才能执行结束。<br>正是由于函数调用的这些特点，根据数据结构是特定应用场景的抽象的原则，我们优先考虑栈结构。<br>2.我们都知道，JVM 内存管理中有个“堆栈”的概念。栈内存用来存储局部变量和方法调用，堆内存用来存储 Java 中的对象。那 JVM 里面的“栈”跟我们这里说的“栈”是不是一回事呢？如果不是，那它为什么又叫作“栈”呢？<br>答：JVM里面的栈和我们这里说的是一回事，被称为方法栈。和前面函数调用的作用是一致的，用来存储方法中的局部变量。</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>DataStructureAndAlgorithm</category>
      </categories>
      <tags>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>09队列：队列在线程池等有限资源池中的应用</title>
    <url>/articles/1a4380b6.html/</url>
    <content><![CDATA[<blockquote>
<p>声名：本文大部分内容出自于极客时间网站王争的专栏《数据结构与算法之美》，这里本人主要记录自己的学习过程，添加个人见解，并作为自己的学习笔记。如有侵权，立马删除。</p>
</blockquote>
<a id="more"></a>
<h3 id="问题导引"><a href="#问题导引" class="headerlink" title="问题导引"></a>问题导引</h3><p>我们知道，CPU资源是有限的，任务的处理速度与线程个数并不是线性正相关。相反，过多的线程反而会导致 CPU频繁切换，处理性能下降。所以，线程池的大小一般都是综合考虑要处理任务的特点和硬件环境，来事先设置的。</p>
<font color="#FF8C00" size="3">当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢</font>

<p>实际上，这些问题并不复杂，其底层的数据结构就是队列（queue）。</p>
<h3 id="如何理解“队列”？"><a href="#如何理解“队列”？" class="headerlink" title="如何理解“队列”？"></a>如何理解“队列”？</h3><p>队列这个概念非常好理解。可以把它想象成排队买票，先来的先买，后来的人只能站末尾，不允许插队。<strong>先进者先出</strong>，这就是典型的“队列”。</p>
<p>我们知道，栈只支持两个基本操作：<strong>入栈 push()和出栈 pop()</strong>。队列跟栈非常相似，支持的操作也很有限，最基本的操作也是两个：<strong>入队 enqueue()</strong>，放一个数据到队列尾部；<strong>出队 dequeue()</strong>，从队列头部取一个元素。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/09队列：队列在线程池等有限资源池中的应用/队列.png" alt></p>
<p>所以，队列跟栈一样，也是一种<strong>操作受限的线性表数据结构</strong>。</p>
<p>队列的概念很好理解，基本操作也很容易掌握。作为一种非常基础的数据结构，队列的应用也非常广泛，特别是一些具有某些额外特性的队列，比如循环队列、阻塞队列、并发队列。它们在很多偏底层系统、框架、中间件的开发中，起着关键性的作用。比如高性能队列 Disruptor、Linux 环形缓存，都用到了循环并发队列；Java concurrent 并发包利用 ArrayBlockingQueue 来实现公平锁等。</p>
<h3 id="顺序队列和链式队列"><a href="#顺序队列和链式队列" class="headerlink" title="顺序队列和链式队列"></a>顺序队列和链式队列</h3><p>我们知道，队列跟栈一样，也是一种抽象的数据结构。它具有<strong>先进先出</strong>的特性，支持在队尾插入元素，在队头删除元素，那究竟该如何实现一个队列呢？</p>
<p>跟栈一样，队列可以用数组来实现，也可以用链表来实现。用数组实现的栈叫作顺序栈，用链表实现的栈叫作链式栈。同样，用数组实现的队列叫作<strong>顺序队列</strong>，用链表实现的队列叫作<strong>链式队列</strong>。</p>
<p>我们先来看下基于数组的实现方法。基于Java语言实现了一下，不过并不包含Java语言的高级语法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用数组实现的队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 数组：items，数组大小：n</span></span><br><span class="line">  <span class="keyword">private</span> String[] items;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// head表示队头下标，tail表示队尾下标</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 申请一个大小为capacity的数组</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    items = <span class="keyword">new</span> String[capacity];</span><br><span class="line">    n = capacity;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入队</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果tail == n 表示队列已经满了</span></span><br><span class="line">    <span class="keyword">if</span> (tail == n) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    items[tail] = item;</span><br><span class="line">    ++tail;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 出队</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果head == tail 表示队列为空</span></span><br><span class="line">    <span class="keyword">if</span> (head == tail) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 为了让其他语言的同学看的更加明确，把--操作放到单独一行来写了</span></span><br><span class="line">    String ret = items[head];</span><br><span class="line">    ++head;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>比起栈的数组实现，队列的数组实现稍微有点儿复杂。对于栈来说，我们只需要一个<strong>栈顶指针</strong>就可以了。但是队列需要两个指针：一个是 head 指针，指向队头；一个是 tail 指针，指向队尾。</p>
<p>你可以结合下面这幅图来理解。当 a、b、c、d 依次入队之后，队列中的 head 指针指向下标为 0 的位置，tail 指针指向下标为 4 的位置。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/09队列：队列在线程池等有限资源池中的应用/队列指针.png" alt><br>当我们调用两次出队操作之后，队列中 head 指针指向下标为 2 的位置，tail 指针仍然指向下标为 4 的位置。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/09队列：队列在线程池等有限资源池中的应用/队列指针2.png" alt></p>
<p>上面你会发现了，随着不停地进行入队、出队操作，head 和 tail 都会持续往后移动。当 tail 移动到最右边，即使数组中还有空闲空间，也无法继续往队列中添加数据了。这个问题该如何解决呢</p>
<p>在数组那一节，我们也遇到过类似的问题，就是数组的删除操作会导致数组中的数据不连续。我们采用数据搬移！但是，每次进行出队操作都相当于删除数组下标为 0 的数据，要搬移整个队列中的数据，这样出队操作的时间复杂度就会从原来的 O(1) 变为 O(n)。对此</p>
<p>我们在出队时可以不用搬移数据。如果没有空闲空间了，我们只需要在入队时，再集中触发一次数据的搬移操作。借助这个思想，出队函数 dequeue() 保持不变，我们稍加改造一下入队函数 enqueue() 的实现，就可以轻松解决刚才的问题了。下面是具体的代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 入队操作，将item放入队尾</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// tail == n表示队列末尾没有空间了</span></span><br><span class="line">  <span class="keyword">if</span> (tail == n) &#123;</span><br><span class="line">    <span class="comment">// tail ==n &amp;&amp; head==0，表示整个队列都占满了</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 数据搬移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head; i &lt; tail; ++i) &#123;</span><br><span class="line">      items[i-head] = items[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 搬移完之后重新更新head和tail</span></span><br><span class="line">    tail -= head;</span><br><span class="line">    head = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  items[tail] = item;</span><br><span class="line">  ++tail;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>从代码中我们看到，当队列的 tail 指针移动到数组的最右边后，如果有新的数据入队，我们可以将 head 到 tail 之间的数据，整体搬移到数组中 0 到 tail-head 的位置。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/09队列：队列在线程池等有限资源池中的应用/数据搬移.png" alt></p>
<p>这种实现思路中，出队操作的时间复杂度仍然是 O(1)，但入队操作的时间复杂度还是 O(1) 吗？</p>
<blockquote>
<p>如果队尾没有满，可以直接入队，时间复杂度为O(1)。<br>如果队尾已满的情况下，就必须进行数据搬移了，tail=n,搬移的时间复杂度为O(n).<br>总体情况来看，tail的可能是0~n的任意值，在0~n-1的时候队列入队的时间复杂度都是O(1)，不需要搬移直接入队即可；只有当tail=n的时候时间复杂度才迅速飙升为O(n)，即需要进行n次搬移，此时n次的搬移如果均摊到0~n-1这n次上，其实总体的均摊复杂度还是O(1)。</p>
</blockquote>
<p>接下来，我们再来看下<strong>基于链表的队列实现方法</strong>。</p>
<p>基于链表的实现，我们同样需要两个指针：head 指针和 tail 指针。它们分别指向链表的第一个结点和最后一个结点。如图所示，入队时，tail-&gt;next= new_node, tail = tail-&gt;next；出队时，head = head-&gt;next。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/09队列：队列在线程池等有限资源池中的应用/链式队列入队出队.png" alt></p>
<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>我们刚才用数组来实现队列的时候，在 tail==n 时，会有数据搬移操作，这样入队操作性能就会受到影响。那有没有办法能够避免数据搬移呢？我们来看看循环队列的解决思路。</p>
<p>循环队列，顾名思义，它长得像一个环。原本数组是有头有尾的，是一条直线。现在我们把首尾相连，扳成了一个环。如下图所示<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/09队列：队列在线程池等有限资源池中的应用/循环队列.png" alt></p>
<p>我们可以看到，图中这个队列的大小为 8，当前 head=4，tail=7。当有一个新的元素 a 入队时，我们放入下标为 7 的位置。但这个时候，我们并不把 tail 更新为 8，而是将其在环中后移一位，到下标为 0 的位置。当再有一个元素 b 入队时，我们将 b 放入下标为 0 的位置，然后 tail 加 1 更新为 1。所以，在 a，b 依次入队之后，循环队列中的元素就变成了下面的样子：<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/09队列：队列在线程池等有限资源池中的应用/循环队列入队.png" alt></p>
<p>通过这样的方法，我们成功避免了数据搬移操作。看起来不难理解，但是循环队列的代码实现难度要比前面讲的非循环队列难多了。要想写出没有 bug 的循环队列的实现代码，最关键的是，<strong>确定好队空和队满的判定条件</strong>。</p>
<p>在用数组实现的非循环队列中，队满的判断条件是 tail == n，队空的判断条件是 head == tail。那针对循环队列，如何判断队空和队满呢？</p>
<p>队列为空的判断条件仍然是 head == tail。但队列满的判断条件就稍微有点复杂了。下图为队满的情况：</p>
<p><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/09队列：队列在线程池等有限资源池中的应用/循环队列队满.png" alt></p>
<p>就像图中队满的情况，tail=3，head=4，n=8，所以总结一下规律就是：(3+1)%8=4。多画几张队满的图，你就会发现，当队满时，<strong>(tail+1)%n=head</strong>。<br>当队列满时，图中的 tail 指向的位置实际上是没有存储数据的。所以，循环队列会浪费一个数组的存储空间。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircularQueue</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 数组：items，数组大小：n</span></span><br><span class="line">  <span class="keyword">private</span> String[] items;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// head表示队头下标，tail表示队尾下标</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 申请一个大小为capacity的数组</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CircularQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    items = <span class="keyword">new</span> String[capacity];</span><br><span class="line">    n = capacity;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入队</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 队列满了</span></span><br><span class="line">    <span class="keyword">if</span> ((tail + <span class="number">1</span>) % n == head) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    items[tail] = item;</span><br><span class="line">    tail = (tail + <span class="number">1</span>) % n;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 出队</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果head == tail 表示队列为空</span></span><br><span class="line">    <span class="keyword">if</span> (head == tail) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    String ret = items[head];</span><br><span class="line">    head = (head + <span class="number">1</span>) % n;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="阻塞队列和并发队列"><a href="#阻塞队列和并发队列" class="headerlink" title="阻塞队列和并发队列"></a>阻塞队列和并发队列</h3><p>队列这种数据结构很基础，平时的业务开发不大可能从零实现一个队列，甚至都不会直接用到。而一些具有特殊特性的队列应用却比较广泛，比如阻塞队列和并发队列。</p>
<p><strong>阻塞队列</strong>其实就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。</p>
<p><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/09队列：队列在线程池等有限资源池中的应用/阻塞队列.png" alt></p>
<p>可以发现，上述的定义就是一个“生产者 - 消费者模型”！是的，我们可以使用阻塞队列，轻松实现一个“生产者 - 消费者模型”！</p>
<p>这种基于阻塞队列实现的“生产者 - 消费者模型”，可以有效地协调生产和消费的速度。当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了。这个时候，生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续“生产”。</p>
<p>而且不仅如此，基于阻塞队列，我们还可以通过协调“生产者”和“消费者”的个数，来提高数据的处理效率。比如前面的例子，我们可以多配置几个“消费者”，来应对一个“生产者”。</p>
<p><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/09队列：队列在线程池等有限资源池中的应用/阻塞队列2.png" alt></p>
<p>前面我们讲了阻塞队列，在多线程情况下，会有多个线程同时操作队列，这个时候就会存在线程安全问题，那如何实现一个线程安全的队列呢？</p>
<p>线程安全的队列我们叫作并发队列。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。</p>
<h3 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h3><p>我们现在回过来看下开篇的问题。线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略又是如何实现的呢？</p>
<p>我们一般有两种处理策略。第一种是非阻塞的处理方式，直接拒绝任务请求；另一种是阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。那如何存储排队的请求呢？</p>
<p>我们希望公平地处理每个排队的请求，先进者先服务，所以队列这种数据结构很适合来存储排队请求。我们前面说过，队列有基于链表和基于数组这两种实现方式。这两种实现方式对于排队请求又有什么区别呢？</p>
<p>基于链表的实现方式，可以实现一个支持无限排队的无界队列（unbounded queue），但是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。</p>
<p>而基于数组实现的有界队列（bounded queue），队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。不过，设置一个合理的队列大小，也是非常有讲究的。队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能。</p>
<p>除了前面讲到队列应用在线程池请求排队的场景之外，队列可以应用在任何有限资源池中，用于排队请求，比如数据库连接池等。<strong>实际上，对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。</strong></p>
<h3 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h3><p>队列最大的特点就是先进先出，主要的两个操作是入队和出队。跟栈一样，它既可以用数组来实现，也可以用链表来实现。用数组实现的叫顺序队列，用链表实现的叫链式队列。特别是长得像一个环的循环队列。在数组实现队列的时候，会有数据搬移操作，要想解决数据搬移的问题，我们就需要像环一样的循环队列。</p>
<p>循环队列是重点。写出没有 bug 的循环队列实现代码，关键要确定好队空和队满的判定条件，具体的代码你要能写出来。</p>
<p>除此之外，我们有几种高级的队列结构，阻塞队列、并发队列，底层都还是队列这种数据结构，只不过在之上附加了很多其他功能。阻塞队列就是入队、出队操作可以阻塞，并发队列就是队列的操作多线程安全。</p>
]]></content>
      <categories>
        <category>DataStructureAndAlgorithm</category>
      </categories>
      <tags>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title>10递归：如何用三行代码找到“最终推荐人”？</title>
    <url>/articles/34b47931.html/</url>
    <content><![CDATA[<blockquote>
<p>声名：本文大部分内容出自于极客时间网站王争的专栏《数据结构与算法之美》，这里本人主要记录自己的学习过程，添加个人见解，并作为自己的学习笔记。如有侵权，立马删除。</p>
</blockquote>
<a id="more"></a>
<h3 id="问题导引"><a href="#问题导引" class="headerlink" title="问题导引"></a>问题导引</h3><p>推荐注册返佣金的这个功能大家都很熟悉吧。这个功能中，用户 A 推荐用户 B 来注册，用户 B 又推荐了用户 C 来注册。我们可以说，用户 C 的“最终推荐人”为用户 A，用户 B 的“最终推荐人”也为用户 A，而用户 A 没有“最终推荐人”。</p>
<p>一般来说，我们会通过数据库来记录这种推荐关系。在数据库表中，我们可以记录两行数据，其中 actor_id 表示用户 id，referrer_id 表示推荐人 id。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/10递归：如何用三行代码找到“最终推荐人”？/推荐用户.png" alt></p>
<p>基于这个背景，所给的问题是，给定一个用户 ID，如何查找这个用户的“最终推荐人”？ 带着这个问题，来学习递归（Recursion）这个数据结构！</p>
<h3 id="如何理解“递归”？"><a href="#如何理解“递归”？" class="headerlink" title="如何理解“递归”？"></a>如何理解“递归”？</h3><p>递归是一种应用非常广泛的算法（或者编程技巧）。后面我们要学的很多数据结构和算法的编码实现都要用到递归，比如 DFS 深度优先搜索、前中后序二叉树遍历等等。所以，搞懂递归非常重要，否则，后面复杂一些的数据结构和算法学起来就会比较吃力。</p>
<p>举个简单的例子，比如去电影院看电影，不知道自己坐第几排，电影院又黑没法数，这时候递归就派上用场了。</p>
<p>你可以问前面一排的人他是第几排，只要在他的数字上加一，就知道自己在哪一排了。但是，前面的人也看不清啊，所以他也问他前面的人。就这样一排一排往前问，直到问到第一排的人，说我在第一排，然后再这样一排一排再把数字传回来。直到你前面的人告诉你他在哪一排，于是你就知道答案了。虽然这有点听起来很扯，但是这不失为一个递归案例。</p>
<p>这就是一个非常标准的递归求解问题的分解过程，去的过程叫“递”，回来的过程叫“归”。基本上，所有的递归问题都可以用递推公式来表示。刚刚这个生活中的例子，我们用递推公式将它表示出来就是这样的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(n) &#x3D; f(n-1) + 1, 其中f(1) &#x3D; 1</span><br></pre></td></tr></table></figure><br>f(n) 表示你想知道自己在哪一排，f(n-1) 表示前面一排所在的排数，f(1)=1 表示第一排的人知道自己在第一排。有了这个递推公式，我们就可以很轻松地将它改为递归代码，如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> f(n<span class="number">-1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="递归需要满足的三个条件"><a href="#递归需要满足的三个条件" class="headerlink" title="递归需要满足的三个条件"></a>递归需要满足的三个条件</h3><h4 id="1-一个问题的解可以分解为几个子问题的解"><a href="#1-一个问题的解可以分解为几个子问题的解" class="headerlink" title="1.一个问题的解可以分解为几个子问题的解"></a>1.一个问题的解可以分解为几个子问题的解</h4><p>何为子问题？子问题就是数据规模更小的问题。比如，前面讲的电影院的例子，你要知道，“自己在哪一排”的问题，可以分解为“前一排的人在哪一排”这样一个子问题。</p>
<h4 id="2-这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样"><a href="#2-这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样" class="headerlink" title="2.这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样"></a>2.这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</h4><p>比如电影院那个例子，你求解“自己在哪一排”的思路，和前面一排人求解“自己在哪一排”的思路，是一模一样的。</p>
<h4 id="3-存在递归终止条件"><a href="#3-存在递归终止条件" class="headerlink" title="3.存在递归终止条件"></a>3.存在递归终止条件</h4><p>把问题分解为子问题，把子问题再分解为子子问题，一层一层分解下去，不能存在无限循环，这就需要有终止条件。</p>
<p>还是电影院的例子，第一排的人不需要再继续询问任何人，就知道自己在哪一排，也就是 f(1)=1，这就是递归的终止条件。</p>
<h3 id="如何编写递归代码"><a href="#如何编写递归代码" class="headerlink" title="如何编写递归代码"></a>如何编写递归代码</h3><p>写递归代码最关键的是<strong>写出递推公式，找到终止条件</strong>，剩下将递推公式转化为代码就很简单了。</p>
<p>假如这里有 n 个台阶，每次你可以跨 1 个台阶或者 2 个台阶，请问走这 n 个台阶有多少种走法？如果有 7 个台阶，你可以 2，2，2，1 这样子上去，也可以 1，2，1，1，2 这样子上去，总之走法有很多，那如何用编程求得总共有多少种走法呢？</p>
<p>我们仔细想下，实际上，可以根据第一步的走法把所有走法分为两类，第一类是第一步走了 1 个台阶，另一类是第一步走了 2 个台阶。所以 n 个台阶的走法就等于先走 1 阶后，n-1 个台阶的走法 加上先走 2 阶后，n-2 个台阶的走法。用公式表示就是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(n) &#x3D; f(n-1) + f(n-2)</span><br></pre></td></tr></table></figure><br>有了递推公式，递归代码基本上就完成了一半。我们再来看下终止条件。当有一个台阶时，我们不需要再继续递归，就只有一种走法。所以 f(1)=1。这个递归终止条件足够吗？我们可以用 n=2，n=3 这样比较小的数试验一下。</p>
<p>n=2 时，f(2)=f(1)+f(0)。如果递归终止条件只有一个 f(1)=1，那 f(2) 就无法求解了。所以除了 f(1)=1 这一个递归终止条件外，还要有 f(0)=1，表示走 0 个台阶有一种走法，不过这样子看起来就不符合正常的逻辑思维了。所以，我们可以把 f(2)=2 作为一种终止条件，表示走 2 个台阶，有两种走法，一步走完或者分两步来走。</p>
<p>所以，递归终止条件就是 f(1)=1，f(2)=2。这个时候，可以再拿 n=3，n=4 来验证一下，这个终止条件是否足够并且正确。</p>
<p>我们把递归终止条件和刚刚得到的递推公式放到一起就是这样的:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(1) &#x3D; 1;</span><br><span class="line">f(2) &#x3D; 2;</span><br><span class="line">f(n) &#x3D; f(n-1)+f(n-2)</span><br></pre></td></tr></table></figure><br>有了这个公式，我们转化成递归代码就简单多了。最终的递归代码是这样的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int f(int n) &#123;</span><br><span class="line">  if (n &#x3D;&#x3D; 1) return 1;</span><br><span class="line">  if (n &#x3D;&#x3D; 2) return 2;</span><br><span class="line">  return f(n-1) + f(n-2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>总结一下，<font color="#FF8C00" size="3">写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。
</font></p>
<p>刚讲的电影院的例子，我们的递归调用只有一个分支，也就是说“一个问题只需要分解为一个子问题”，我们很容易能够想清楚“递“和”归”的每一个步骤，所以写起来、理解起来都不难。</p>
<p>但是，当我们面对的是一个问题要分解为多个子问题的情况，递归代码就没那么好理解了</p>
<p>计算机擅长做重复的事情，所以递归正和它的胃口。而我们人脑更喜欢平铺直叙的思维方式。当我们看到递归时，我们总想把递归平铺展开，脑子里就会循环，一层一层往下调，然后再一层一层返回，试图想搞清楚计算机每一步都是怎么执行的，这样就很容易被绕进去。</p>
<p>对于递归代码，这种试图想清楚整个递和归过程的做法，实际上是进入了一个思维误区。很多时候，我们理解起来比较吃力，主要原因就是自己给自己制造了这种理解障碍。那正确的思维方式应该是怎样的呢？</p>
<p>如果一个问题 A 可以分解为若干子问题 B、C、D，你可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A。而且，你只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。</p>
<p>因此，<strong>编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。</strong></p>
<h3 id="递归代码要警惕堆栈溢出"><a href="#递归代码要警惕堆栈溢出" class="headerlink" title="递归代码要警惕堆栈溢出"></a>递归代码要警惕堆栈溢出</h3><p>在实际的软件开发中，编写递归代码时，我们会遇到很多问题，比如堆栈溢出。而堆栈溢出会造成系统性崩溃，后果会非常严重。为什么递归代码容易造成堆栈溢出呢？我们又该如何预防堆栈溢出呢？</p>
<p>在“栈”那一节中，函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。</p>
<p>比如前面的讲到的电影院的例子，如果我们将系统栈或者 JVM 堆栈大小设置为 1KB，在求解 f(19999) 时便会出现如下堆栈报错：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.StackOverflowError</span><br></pre></td></tr></table></figure></p>
<p>那么，如何避免出现堆栈溢出呢？我们可以通过在代码中限制递归调用的最大深度的方式来解决这个问题。递归调用超过一定深度（比如 1000）之后，我们就不继续往下再递归了，直接返回报错。还是电影院那个例子，我们可以改造成下面这样子，就可以避免堆栈溢出了。不过，下面代码是伪代码，为了代码简洁，有些边界条件没有考虑，比如 x&lt;=0。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局变量，表示递归的深度。</span></span><br><span class="line"><span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  ++depth；</span><br><span class="line">  <span class="keyword">if</span> (depth &gt; <span class="number">1000</span>) <span class="keyword">throw</span> exception;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> f(n-<span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>但这种做法并不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。如果实时计算，代码过于复杂，就会影响代码的可读性。所以，如果最大深度比较小，比如 10、50，就可以用这种方法，否则这种方法并不是很实用。</p>
<h3 id="递归代码要警惕重复计算"><a href="#递归代码要警惕重复计算" class="headerlink" title="递归代码要警惕重复计算"></a>递归代码要警惕重复计算</h3><p>除此之外，使用递归时还会出现重复计算的问题。刚才我讲的第二个递归代码的例子，如果我们把整个递归过程分解一下的话，那就是这样的：<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/10递归：如何用三行代码找到“最终推荐人”？/递归示例.png" alt></p>
<p>从图中，我们可以直观地看到，想要计算 f(5)，需要先计算 f(4) 和 f(3)，而计算 f(4) 还需要计算 f(3)，因此，f(3) 就被计算了很多次，这就是重复计算问题。</p>
<p>为了避免重复计算，我们可以通过一个数据结构（比如散列表）来保存已经求解过的 f(k)。当递归调用到 f(k) 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算，这样就能避免刚讲的问题了。</p>
<p>按照上面的思路，改造一下刚才的代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// hasSolvedList可以理解成一个Map，key是n，value是f(n)</span></span><br><span class="line">  <span class="keyword">if</span> (hasSolvedList.containsKey(n)) &#123;</span><br><span class="line">    <span class="keyword">return</span> hasSolvedList.get(n);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> ret = f(n-<span class="number">1</span>) + f(n-<span class="number">2</span>);</span><br><span class="line">  hasSolvedList.put(n, ret);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>除了堆栈溢出、重复计算这两个常见的问题。递归代码还有很多别的问题。</p>
<p>在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积聚成一个可观的时间成本。在空间复杂度上，因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销，比如我们前面讲到的电影院递归代码，空间复杂度并不是 O(1)，而是 O(n)。</p>
<h3 id="怎么将递归代码改写为非递归代码？"><a href="#怎么将递归代码改写为非递归代码？" class="headerlink" title="怎么将递归代码改写为非递归代码？"></a>怎么将递归代码改写为非递归代码？</h3><p>我们刚说了，递归有利有弊，利是递归代码的表达力很强，写起来非常简洁；而弊就是空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题。所以，在开发过程中，我们要根据实际情况来选择是否需要用递归的方式来实现。</p>
<p>那我们是否可以把递归代码改写为非递归代码呢？比如刚才那个电影院的例子，我们抛开场景，只看 f(x) =f(x-1)+1 这个递推公式。我们这样改写：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    ret = ret + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>同样，第二个例子也可以改为非递归的实现方式。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> pre = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">int</span> prepre = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    ret = pre + prepre;</span><br><span class="line">    prepre = pre;</span><br><span class="line">    pre = ret;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>是不是所有的递归代码都可以改为这种迭代循环的非递归写法呢？笼统地讲，是的。因为递归本身就是借助栈来实现的，只不过我们使用的栈是系统或者虚拟机本身提供的，我们没有感知罢了。如果我们自己在内存堆上实现栈，手动模拟入栈、出栈过程，这样任何递归代码都可以改写成看上去不是递归代码的样子。但是这种思路实际上是将递归改为了“手动”递归，本质并没有变，而且也并没有解决前面讲到的某些问题，徒增了实现的复杂度。</p>
<h3 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h3><p>如何找到“最终推荐人”？,方案如下<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">findRootReferrerId</span><span class="params">(<span class="keyword">long</span> actorId)</span> </span>&#123;</span><br><span class="line">  Long referrerId = select referrer_id from [table] where actor_id = actorId;</span><br><span class="line">  <span class="keyword">if</span> (referrerId == <span class="keyword">null</span>) <span class="keyword">return</span> actorId;</span><br><span class="line">  <span class="keyword">return</span> findRootReferrerId(referrerId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>用三行代码就能搞定了，不过在实际项目中，上面的代码并不能工作，为什么呢？这里面有两个问题。</p>
<p>第一，如果递归很深，可能会有堆栈溢出的问题。</p>
<p>第二，如果数据库里存在脏数据，我们还需要处理由此产生的无限递归问题。比如 demo 环境下数据库中，测试工程师为了方便测试，会人为地插入一些数据，就会出现脏数据。如果 A 的推荐人是 B，B 的推荐人是 C，C 的推荐人是 A，这样就会发生死循环。</p>
<p>第一个问题，可以用限制递归深度来解决。第二个问题，也可以用限制递归深度来解决。不过，还有一个更高级的处理方法，就是自动检测 A-B-C-A 这种“环”的存在，后面会讲。</p>
<h3 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h3><p>递归是一种非常高效、简洁的编码技巧。只要是满足“三个条件”的问题就可以通过递归代码来解决。</p>
<p>不过递归代码也比较难写、难理解。编写递归代码的关键就是不要把自己绕进去，正确姿势是写出递推公式，找出终止条件，然后再翻译成递归代码。</p>
<p>递归代码虽然简洁高效，但是，递归代码也有很多弊端。比如，堆栈溢出、重复计算、函数调用耗时多、空间复杂度高等，所以，在编写递归代码的时候，一定要控制好这些副作用。</p>
<h3 id="笔记小结"><a href="#笔记小结" class="headerlink" title="笔记小结"></a>笔记小结</h3><blockquote>
<p>一、什么是递归？<br>1.递归是一种非常高效、简洁的编码技巧，一种应用非常广泛的算法，比如DFS深度优先搜索、前中后序二叉树遍历等都是使用递归。<br>2.方法或函数调用自身的方式称为递归调用，调用称为递，返回称为归。<br>3.基本上，所有的递归问题都可以用递推公式来表示，比如<br>f(n) = f(n-1) + 1;<br>f(n) = f(n-1) + f(n-2);<br>f(n)=n*f(n-1);<br>二、为什么使用递归？递归的优缺点？<br>1.优点：代码的表达力很强，写起来简洁。<br>2.缺点：空间复杂度高、有堆栈溢出风险、存在重复计算、过多的函数调用会耗时较多等问题。<br>三、什么样的问题可以用递归解决呢？<br>一个问题只要同时满足以下3个条件，就可以用递归来解决：<br>1.问题的解可以分解为几个子问题的解。何为子问题？就是数据规模更小的问题。<br>2.问题与子问题，除了数据规模不同，求解思路完全一样<br>3.存在递归终止条件<br>四、如何实现递归？<br>1.递归代码编写<br>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。<br>2.递归代码理解<br>对于递归代码，若试图想清楚整个递和归的过程，实际上是进入了一个思维误区。<br>那该如何理解递归代码呢？如果一个问题A可以分解为若干个子问题B、C、D，你可以假设子问题B、C、D已经解决。而且，你只需要思考问题A与子问题B、C、D两层之间的关系即可，不需要一层层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。<br>因此，理解递归代码，就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。<br>五、递归常见问题及解决方案<br>1.警惕堆栈溢出：可以声明一个全局变量来控制递归的深度，从而避免堆栈溢出。<br>2.警惕重复计算：通过某种数据结构来保存已经求解过的值，从而避免重复计算。<br>六、如何将递归改写为非递归代码？<br>笼统的讲，所有的递归代码都可以改写为迭代循环的非递归写法。如何做？抽象出递推公式、初始值和边界条件，然后用迭代循环实现。</p>
</blockquote>
]]></content>
      <categories>
        <category>DataStructureAndAlgorithm</category>
      </categories>
      <tags>
        <tag>Recursion</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>11排序（上）：为什么插入排序比冒泡排序更受欢迎？</title>
    <url>/articles/baedad64.html/</url>
    <content><![CDATA[<blockquote>
<p>声名：本文大部分内容出自于极客时间网站王争的专栏《数据结构与算法之美》，这里本人主要记录自己的学习过程，添加个人见解，并作为自己的学习笔记。如有侵权，立马删除。<br><a id="more"></a></p>
</blockquote>
<p>排序对于任何一个程序员来说，可能都不会陌生。你学的第一个算法，可能就是排序。大部分编程语言中，也都提供了排序函数。排序非常重要，在平常的项目中，我们也经常会用到排序。排序算法太多了，有很多可能你连名字都没听说过，比如猴子排序、睡眠排序、面条排序等。这里只会学习到也是最经典的、最常用的：冒泡排序、插入排序、选择排序、归并排序、快速排序、计数排序、基数排序、桶排序。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/11排序（上）：为什么插入排序比冒泡排序更受欢迎？/排序复杂度.png" alt></p>
<h3 id="问题导向"><a href="#问题导向" class="headerlink" title="问题导向"></a>问题导向</h3><p>插入排序和冒泡排序的时间复杂度相同，都是 O($n^2$)，在实际的软件开发里，为什么我们更倾向于使用插入排序算法而不是冒泡排序算法呢？</p>
<h3 id="如何分析一个“排序算法”？"><a href="#如何分析一个“排序算法”？" class="headerlink" title="如何分析一个“排序算法”？"></a>如何分析一个“排序算法”？</h3><p>学习排序算法，我们除了学习它的算法原理、代码实现之外，更重要的是要学会如何评价、分析一个排序算法。那分析一个排序算法，要从哪几个方面入手呢？</p>
<font color="#FF8C00" size="4">排序算法的执行效率</font>

<p>对于排序算法执行效率的分析，我们一般会从这几个方面来衡量：</p>
<h4 id="1-最好情况、最坏情况、平均情况时间复杂度"><a href="#1-最好情况、最坏情况、平均情况时间复杂度" class="headerlink" title="1. 最好情况、最坏情况、平均情况时间复杂度"></a>1. 最好情况、最坏情况、平均情况时间复杂度</h4><p>我们在分析排序算法的时间复杂度时，要分别给出最好情况、最坏情况、平均情况下的时间复杂度。除此之外，你还要说出最好、最坏时间复杂度对应的要排序的原始数据是什么样的。</p>
<p>为什么要区分这三种时间复杂度呢？第一，有些排序算法会区分，为了好对比，所以我们最好都做一下区分。第二，对于要排序的数据，有的接近有序，有的完全无序。有序度不同的数据，对于排序的执行时间肯定是有影响的，我们要知道排序算法在不同数据下的性能表现。 </p>
<h4 id="2-时间复杂度的系数、常数-、低阶"><a href="#2-时间复杂度的系数、常数-、低阶" class="headerlink" title="2.时间复杂度的系数、常数 、低阶"></a>2.时间复杂度的系数、常数 、低阶</h4><p>我们知道，时间复杂度反应的是数据规模 n 很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。但是实际的软件开发中，我们排序的可能是 10 个、100 个、1000 个这样规模很小的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来。</p>
<h4 id="3-比较次数和交换（或移动）次数"><a href="#3-比较次数和交换（或移动）次数" class="headerlink" title="3.比较次数和交换（或移动）次数"></a>3.比较次数和交换（或移动）次数</h4><p>基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。所以，如果我们在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。</p>
<p><font color="#FF8C00" size="4">排序算法的内存消耗</font><br>算法的内存消耗可以通过空间复杂度来衡量，排序算法也不例外。不过，针对排序算法的空间复杂度，我们还引入了一个新的概念，原地排序（Sorted in place）。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。我们今天学的三种排序算法，都是原地排序算法。</p>
<p><font color="#FF8C00" size="4">排序算法的稳定性</font><br>仅仅用执行效率和内存消耗来衡量排序算法的好坏是不够的。针对排序算法，我们还有一个重要的度量指标，稳定性。这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。</p>
<p>我通过一个例子来解释一下。比如我们有一组数据 2，9，3，4，8，3，按照大小排序之后就是 2，3，3，4，8，9。</p>
<p>这组数据里有两个 3。经过某种排序算法排序之后，如果两个 3 的前后顺序没有改变，那我们就把这种排序算法叫作<strong>稳定的排序算法</strong>；如果前后顺序发生变化，那对应的排序算法就叫作<strong>不稳定的排序算法</strong>。</p>
<p>很多数据结构和算法课程，在讲排序的时候，都是用整数来举例，但在真正软件开发中，我们要排序的往往不是单纯的整数，而是一组对象，我们需要按照对象的某个 key 来排序。</p>
<p>比如说，我们现在要给电商交易系统中的“订单”排序。订单有两个属性，一个是下单时间，另一个是订单金额。如果我们现在有 10 万条订单数据，我们希望按照金额从小到大对订单数据排序。对于金额相同的订单，我们希望按照下单时间从早到晚有序。对于这样一个排序需求，我们怎么来做呢？</p>
<p>最先想到的方法是：我们先按照金额对订单数据进行排序，然后，再遍历排序之后的订单数据，对于每个金额相同的小区间再按照下单时间排序。这种排序思路理解起来不难，但是实现起来会很复杂。</p>
<p>借助稳定排序算法，这个问题可以非常简洁地解决。解决思路是这样的：我们先按照下单时间给订单排序，注意是按照下单时间，不是金额。排序完成之后，我们用稳定排序算法，按照订单金额重新排序。两遍排序之后，我们得到的订单数据就是按照金额从小到大排序，金额相同的订单按照下单时间从早到晚排序的。为什么呢？</p>
<p><strong>稳定排序算法可以保持金额相同的两个对象，在排序之后的前后顺序不变。</strong>第一次排序之后，所有的订单按照下单时间从早到晚有序了。在第二次排序中，我们用的是稳定的排序算法，所以经过第二次排序之后，相同金额的订单仍然保持下单时间从早到晚有序。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/11排序（上）：为什么插入排序比冒泡排序更受欢迎？/稳定排序.png" alt></p>
<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p>这里先学习到也是最经典的、最常用的三种排序算法：冒泡排序，插入排序，选择排序</p>
<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。</p>
<p>举一个例子，看下冒泡排序的整个过程。我们要对一组数据 4，5，6，3，2，1，从小到大进行排序。第一次冒泡操作的详细过程就是这样：<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/11排序（上）：为什么插入排序比冒泡排序更受欢迎？/冒泡1.png" alt></p>
<p>可以看出，经过一次冒泡操作之后，6 这个元素已经存储在正确的位置上。要想完成所有数据的排序，我们只要进行 6 次这样的冒泡操作就行了。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/11排序（上）：为什么插入排序比冒泡排序更受欢迎？/冒泡2.png" alt></p>
<p>实际上，刚讲的冒泡过程还可以优化。当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。这里还有另外一个例子，这里面给 6 个元素排序，只需要 4 次冒泡操作就可以了。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/11排序（上）：为什么插入排序比冒泡排序更受欢迎？/冒泡3.png" alt></p>
<p>冒泡排序算法的原理比较容易理解，具体的代码如下<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序，a表示数组，n表示数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="comment">// 提前退出冒泡循环的标志位</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>]) &#123; <span class="comment">// 交换</span></span><br><span class="line">        <span class="keyword">int</span> tmp = a[j];</span><br><span class="line">        a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">        a[j+<span class="number">1</span>] = tmp;</span><br><span class="line">        flag = <span class="keyword">true</span>;  <span class="comment">// 表示有数据交换      </span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">break</span>;  <span class="comment">// 没有数据交换，提前退出</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>冒泡排序是原地排序算法吗？</strong><br>冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。</p>
<p><strong>冒泡排序是稳定的排序算法吗？</strong><br>在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。</p>
<p><strong>冒泡排序的时间复杂度是多少？</strong><br>最好情况下，要排序的数据已经是有序的了，我们只需要进行一次冒泡操作，就可以结束了，所以最好情况时间复杂度是 O(n)。而最坏的情况是，要排序的数据刚好是倒序排列的，我们需要进行 n 次冒泡操作，所以最坏情况时间复杂度为 O($n^2$)。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/11排序（上）：为什么插入排序比冒泡排序更受欢迎？/冒泡时间复杂度.png" alt></p>
<p>好、最坏情况下的时间复杂度很容易分析，那平均情况下的时间复杂是多少呢？我们前面讲过，平均时间复杂度就是加权平均期望时间复杂度，分析的时候要结合概率论的知识。对于包含 n 个数据的数组，这 n 个数据就有 n! 种排列方式。不同的排列方式，冒泡排序执行的时间肯定是不同的。比如我们前面举的那两个例子，其中一个要进行 6 次冒泡，而另一个只需要 4 次。如果用概率论方法定量分析平均时间复杂度，涉及的数学推理和计算就会很复杂。这里还有一种思路，通过“<strong>有序度</strong>”和“<strong>逆序度</strong>”*这两个概念来进行分析</p>
<p><strong>有序度</strong>是数组中具有有序关系的元素对的个数。有序元素对用数学表达式表示就是这样：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有序元素对：a[i] &lt;&#x3D; a[j], 如果i &lt; j。</span><br></pre></td></tr></table></figure><br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/11排序（上）：为什么插入排序比冒泡排序更受欢迎？/有序度.png" alt="有序度"></p>
<p>同理，对于一个倒序排列的数组，比如 6，5，4，3，2，1，有序度是 0；对于一个完全有序的数组，比如 1，2，3，4，5，6，有序度就是<strong>n*(n-1)/2</strong>，也就是 15。我们把这种完全有序的数组的有序度叫作<strong>满有序度</strong>。</p>
<p><strong>逆序度</strong>的定义正好跟有序度相反（默认从小到大为有序）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">逆序元素对：a[i] &gt; a[j], 如果i &lt; j。</span><br></pre></td></tr></table></figure><br>关于这三个概念，我们还可以得到一个公式：<strong>逆序度 = 满有序度 - 有序度</strong>。我们排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了</p>
<p>还是拿前面举的那个冒泡排序的例子来说明。要排序的数组的初始状态是 4，5，6，3，2，1 ，其中，有序元素对有 (4，5) (4，6)(5，6)，所以有序度是 3。n=6，所以排序完成之后终态的满有序度为 n*(n-1)/2=15。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/11排序（上）：为什么插入排序比冒泡排序更受欢迎？/有序度2.png" alt="有序度2"></p>
<p>冒泡排序包含两个操作原子，<strong>比较</strong>和<strong>交换</strong>。每交换一次，有序度就加 1。不管算法怎么改进，交换次数总是确定的，即为<strong>逆序度，也就是n*(n-1)/2–初始有序度</strong>。此例中就是 15–3=12，要进行 12 次交换操作。</p>
<p>对于包含 n 个数据的数组进行冒泡排序，平均交换次数是多少呢？最坏情况下，初始状态的有序度是 0，所以要进行 n<em>(n-1)/2 次交换。最好情况下，初始状态的有序度是 n</em>(n-1)/2，就不需要进行交换。我们可以取个中间值 n*(n-1)/4，来表示初始有序度既不是很高也不是很低的平均情况。</p>
<p>话说，平均情况下，需要 n*(n-1)/4 次交换操作，比较操作肯定要比交换操作多，而复杂度的上限是 O($n^2$)，所以平均情况下的时间复杂度就是 O($n^2$)。</p>
<p>这个平均时间复杂度推导过程其实并不严格，但是很多时候很实用，毕竟概率论的定量分析太复杂，不太好用。学到快排的时候，还会再次用这种“不严格”的方法来分析平均时间复杂度。</p>
<h4 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h4><p>先来看一个问题。一个有序的数组，我们往里面添加一个新的数据后，如何继续保持数据有序呢？很简单，我们只要遍历数组，找到数据应该插入的位置将其插入即可。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/11排序（上）：为什么插入排序比冒泡排序更受欢迎？/插入排序.png" alt="插入排序"></p>
<p>这是一个动态排序的过程，即动态地往有序集合中添加数据，我们可以通过这种方法保持集合中的数据一直有序。而对于一组静态数据，我们也可以借鉴上面讲的插入方法，来进行排序，于是就有了插入排序算法。</p>
<p>那插入排序具体是如何借助上面的思想来实现排序的呢？</p>
<p>首先，我们将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。</p>
<p>如图所示，要排序的数据是 4，5，6，1，3，2，其中左侧为已排序区间，右侧是未排序区间。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/11排序（上）：为什么插入排序比冒泡排序更受欢迎？/插入排序2.png" alt="插入排序2"></p>
<p>插入排序也包含两种操作，一种是<strong>元素的比较</strong>，一种是<strong>元素的移</strong>动。当我们需要将一个数据 a 插入到已排序区间时，需要拿 a 与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点之后，我们还需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置给元素 a 插入。</p>
<p>对于不同的查找插入点方法（从头到尾、从尾到头），元素的比较次数是有区别的。但对于一个给定的初始序列，移动操作的次数总是固定的，就等于逆序度。拿刚才的例子，如下图表所示，满有序度是 n*(n-1)/2=15，初始序列的有序度是 5，所以逆序度是 10。插入排序中，数据移动的个数总和也等于 10=3+3+4。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/11排序（上）：为什么插入排序比冒泡排序更受欢迎？/插入排序3.png" alt="插入排序3"></p>
<p>插入排序的代码如下<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入排序，a表示数组，n表示数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> value = a[i];</span><br><span class="line">    <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 查找插入的位置</span></span><br><span class="line">    <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j] &gt; value) &#123;</span><br><span class="line">        a[j+<span class="number">1</span>] = a[j];  <span class="comment">// 数据移动</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[j+<span class="number">1</span>] = value; <span class="comment">// 插入数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>插入排序是原地排序算法吗？</strong><br>从实现过程可以很明显地看出，插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，也就是说，这是一个原地排序算法。<br><strong>插入排序是稳定的排序算法吗？</strong>在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。<br><strong>插入排序的时间复杂度是多少？</strong>如果要排序的数据已经是有序的，我们并不需要搬移任何数据。如果我们从尾到头在有序数据组里面查找插入位置，每次只需要比较一个数据就能确定插入的位置。所以这种情况下，最好是时间复杂度为 O(n)。注意，<strong>这里是从尾到头遍历已经有序的数据</strong>。</p>
<p>如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，所以最坏情况时间复杂度为 O($n^2$)。</p>
<p>数组中插入一个数据的平均时间复杂度是O($n^2$)。类比下，对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入操作，所以平均时间复杂度为 O($n^2$)。</p>
<h4 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h4><p>选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/11排序（上）：为什么插入排序比冒泡排序更受欢迎？/选择排序.png" alt="选择排序"></p>
<p>上面的三个问题答案如下：选择排序空间复杂度为 O(1)，是一种原地排序算法。选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n2)</p>
<p>那选择排序是稳定的排序算法吗？</p>
<p>答案是否定的，选择排序是一种不稳定的排序算法。上图中，可以看出来，选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。</p>
<p>比如 5，8，5，2，9 这样一组数据，使用选择排序算法来排序的话，第一次找到最小元素 2，与第一个 5 交换位置，那第一个 5 和中间的 5 顺序就变了，所以就不稳定了。正是因此，相对于冒泡排序和插入排序，选择排序就稍微逊色了。</p>
<h3 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h3><p>我们来看开篇的问题：冒泡排序和插入排序的时间复杂度都是 O(n2)，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎呢？</p>
<p>我们前面分析冒泡排序和插入排序的时候讲到，冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度。插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。</p>
<p>但是，从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。我们来看这段操作：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">冒泡排序中数据的交换操作：</span><br><span class="line"><span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>]) &#123; <span class="comment">// 交换</span></span><br><span class="line">   <span class="keyword">int</span> tmp = a[j];</span><br><span class="line">   a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">   a[j+<span class="number">1</span>] = tmp;</span><br><span class="line">   flag = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">插入排序中数据的移动操作：</span><br><span class="line"><span class="keyword">if</span> (a[j] &gt; value) &#123;</span><br><span class="line">  a[j+<span class="number">1</span>] = a[j];  <span class="comment">// 数据移动</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们把执行一个赋值语句的时间粗略地计为单位时间（unit_time），然后分别用冒泡排序和插入排序对同一个逆序度是 K 的数组进行排序。用冒泡排序，需要 K 次交换操作，每次需要 3 个赋值语句，所以交换操作总耗时就是 3*K 单位时间。而插入排序中数据移动操作只需要 K 个单位时间。这个只是我们非常理论的分析。</p>
<p>实验上，针对上面的冒泡排序和插入排序的 Java 代码，随机生成 10000 个数组，每个数组中包含 200 个数据，然后在机器上分别用冒泡和插入排序算法来排序，冒泡排序算法大约 700ms 才能执行完成，而插入排序只需要 100ms 左右就能搞定！</p>
<p>所以，虽然冒泡排序和插入排序在时间复杂度上是一样的，都是 O($n^2$)，但是如果我们希望把性能优化做到极致，那肯定首选插入排序。插入排序的算法思路也有很大的优化空间，我们只是讲了最基础的一种。</p>
<h3 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h3><p>要想分析、评价一个排序算法，需要从执行效率、内存消耗和稳定性三个方面来看。我们分析了三种时间复杂度是 O(n2) 的排序算法，冒泡排序、插入排序、选择排序。后面的重点是需要掌握的是它们的分析方法。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/11排序（上）：为什么插入排序比冒泡排序更受欢迎？/排序比较.png" alt="排序比较"></p>
<p>这三种时间复杂度为 O(n2) 的排序算法中，冒泡排序、选择排序，可能就纯粹停留在理论的层面了，学习的目的也只是为了开拓思维，实际开发中应用并不多，但是插入排序还是挺有用的。后面讲排序优化的时候，有些编程语言中的排序函数的实现原理会用到插入排序算法。</p>
<p>我们学的这三种排序算法，实现代码都非常简单，对于小规模数据的排序，用起来非常高效。但是在大规模数据排序的时候，这个时间复杂度还是稍微有点高，所以我们更倾向于用后面要学的时间复杂度为 O(nlogn) 的排序算法。</p>
<h3 id="笔记小结"><a href="#笔记小结" class="headerlink" title="笔记小结"></a>笔记小结</h3><blockquote>
<p>一、几种经典排序算法及其时间复杂度级别<br>冒泡、插入、选择 O(n^2) 基于比较<br>快排、归并 O(nlogn) 基于比较<br>计数、基数、桶 O(n) 不基于比较<br>二、如何分析一个排序算法？<br>1.学习排序算法的思路？明确原理、掌握实现以及分析性能。<br>2.如何分析排序算法性能？从执行效率、内存消耗以及稳定性3个方面分析排序算法的性能。<br>3.执行效率：从以下3个方面来衡量<br>1）最好情况、最坏情况、平均情况时间复杂度<br>2）时间复杂度的系数、常数、低阶：排序的数据量比较小时考虑<br>3）比较次数和交换（或移动）次数<br>4.内存消耗：通过空间复杂度来衡量。针对排序算法的空间复杂度，引入原地排序的概念，原地排序算法就是指空间复杂度为O(1)的排序算法。<br>5.稳定性：如果待排序的序列中存在值等的元素，经过排序之后，相等元素之间原有的先后顺序不变，就说明这个排序算法时稳定的。<br>三、冒泡排序<br>1.排序原理<br>1）冒泡排序只会操作相邻的两个数据。<br>2）对相邻两个数据进行比较，看是否满足大小关系要求，若不满足让它俩互换。<br>3）一次冒泡会让至少一个元素移动到它应该在的位置，重复n次，就完成了n个数据的排序工作。<br>4）优化：若某次冒泡不存在数据交换，则说明已经达到完全有序，所以终止冒泡。<br>2.代码实现（见下一条留言）<br>3.性能分析<br>1）执行效率：最小时间复杂度、最大时间复杂度、平均时间复杂度<br>最小时间复杂度：数据完全有序时，只需进行一次冒泡操作即可，时间复杂度是O(n)。<br>最大时间复杂度：数据倒序排序时，需要n次冒泡操作，时间复杂度是O(n^2)。<br>平均时间复杂度：通过有序度和逆序度来分析。<br>什么是有序度？<br>有序度是数组中具有有序关系的元素对的个数，比如[2,4,3,1,5,6]这组数据的有序度就是11，分别是[2,4][2,3][2,5][2,6][4,5][4,6][3,5][3,6][1,5][1,6][5,6]。同理，对于一个倒序数组，比如[6,5,4,3,2,1]，有序度是0；对于一个完全有序的数组，比如[1,2,3,4,5,6]，有序度为n<em>(n-1)/2，也就是15，完全有序的情况称为满有序度。<br>什么是逆序度？逆序度的定义正好和有序度相反。核心公式：逆序度=满有序度-有序度。<br>排序过程，就是有序度增加，逆序度减少的过程，最后达到满有序度，就说明排序完成了。<br>冒泡排序包含两个操作原子，即比较和交换，每交换一次，有序度加1。不管算法如何改进，交换的次数总是确定的，即逆序度。<br>对于包含n个数据的数组进行冒泡排序，平均交换次数是多少呢？最坏的情况初始有序度为0，所以要进行n</em>(n-1)/2交换。最好情况下，初始状态有序度是n<em>(n-1)/2，就不需要进行交互。我们可以取个中间值n</em>(n-1)/4，来表示初始有序度既不是很高也不是很低的平均情况。<br>换句话说，平均情况下，需要n*(n-1)/4次交换操作，比较操作可定比交换操作多，而复杂度的上限是O(n^2)，所以平均情况时间复杂度就是O(n^2)。<br>以上的分析并不严格，但很实用，这就够了。<br>2）空间复杂度：每次交换仅需1个临时变量，故空间复杂度为O(1)，是原地排序算法。<br>3）算法稳定性：如果两个值相等，就不会交换位置，故是稳定排序算法。<br>四、插入排序<br>1.算法原理<br>首先，我们将数组中的数据分为2个区间，即已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想就是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间中的元素一直有序。重复这个过程，直到未排序中元素为空，算法结束。<br>2.代码实现（见下一条留言）<br>3.性能分析<br>1）时间复杂度：最好、最坏、平均情况<br>如果要排序的数组已经是有序的，我们并不需要搬移任何数据。只需要遍历一遍数组即可，所以时间复杂度是O(n)。如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，因此时间复杂度是O(n^2)。而在一个数组中插入一个元素的平均时间复杂都是O(n)，插入排序需要n次插入，所以平均时间复杂度是O(n^2)。<br>2）空间复杂度：从上面的代码可以看出，插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是O(1)，是原地排序算法。<br>3）算法稳定性：在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现的元素的后面，这样就保持原有的顺序不变，所以是稳定的。</p>
</blockquote>
]]></content>
      <categories>
        <category>DataStructureAndAlgorithm</category>
      </categories>
      <tags>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>14排序优化：如何实现一个通用的、高性能的排序函数？</title>
    <url>/articles/b435c06c.html/</url>
    <content><![CDATA[<blockquote>
<p>声名：本文大部分内容出自于极客时间网站王争的专栏《数据结构与算法之美》，这里本人主要记录自己的学习过程，添加个人见解，并作为自己的学习笔记。如有侵权，立马删除。</p>
</blockquote>
<a id="more"></a>
<p>几乎所有的编程语言都会提供排序函数，比如 C 语言中 qsort()，C++ STL 中的 sort()、stable_sort()，还有 Java 语言中的 Collections.sort()。在平时的开发中，我们也都是直接使用这些现成的函数来实现业务逻辑中的排序功能。这些排序函数是如何实现的吗？底层都利用了哪种排序算法呢？这些问题我们还是需要了解的。</p>
<h3 id="问题导向"><a href="#问题导向" class="headerlink" title="问题导向"></a>问题导向</h3><p>如何实现一个通用的、高性能的排序函数？</p>
<h3 id="如何选择合适的排序算法？"><a href="#如何选择合适的排序算法？" class="headerlink" title="如何选择合适的排序算法？"></a>如何选择合适的排序算法？</h3><p>我们先回顾一下前面讲过的几种排序算法。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/14排序优化：如何实现一个通用的、高性能的排序函数？/排序算法比较.png" alt="排序算法比较"></p>
<p>首先线性排序算法的时间复杂度比较低，适用场景比较特殊。所以如果要写一个通用的排序函数，不能选择线性排序算法。如果对小规模数据进行排序，可以选择时间复杂度是 O(n2) 的算法；如果对大规模数据进行排序，时间复杂度是 O(nlogn) 的算法更加高效。所以，为了兼顾任意规模数据的排序，一般都会首选时间复杂度是 O(nlogn) 的排序算法来实现排序函数。</p>
<p>时间复杂度是 O(nlogn) 的排序算法不止一个，有归并排序、快速排序，后面学堆的时候还有堆排序。堆排序和快速排序都有比较多的应用，比如 Java 语言采用堆排序实现排序函数，C 语言使用快速排序实现排序函数。使用归并排序的情况其实并不多。我们知道，快排在最坏情况下的时间复杂度是 O(n2)，而归并排序可以做到平均情况、最坏情况下的时间复杂度都是 O(nlogn)，从这点上看起来很诱人。</p>
<p>但是归并排序并不是原地排序算法，空间复杂度是 O(n)。所以，粗略点、夸张点讲，如果要排序 100MB 的数据，除了数据本身占用的内存之外，排序算法还要额外再占用 100MB 的内存空间。所以还剩下快速排序算法，但是快速排序算法在最坏的情况下的是时间复杂度达到了O(n2),我们需要想办法解决“复杂度恶化”的问题。</p>
<h3 id="如何优化快速排序？"><a href="#如何优化快速排序？" class="headerlink" title="如何优化快速排序？"></a>如何优化快速排序？</h3><p>最坏情况下快速排序的时间复杂度是 O(n2),这是因为如果数据原来就是有序的或者接近有序的，每次分区点都选择最后一个数据，那快速排序算法就会变得非常糟糕，时间复杂度就会退化为 O(n2)。实际上，<strong>这种 O(n2) 时间复杂度出现的主要原因还是因为我们分区点选的不够合理</strong>。</p>
<p>最理想的分区点是：<strong>被分区点分开的两个分区中，数据的数量差不多</strong>。</p>
<p>如果很粗暴地直接选择第一个或者最后一个数据作为分区点，不考虑数据的特点，肯定会出现之前讲的那样，在某些情况下，排序的最坏情况时间复杂度是 O(n2)。为了提高排序算法的性能，我们也要尽可能地让每次分区都比较平均。这里介绍两个比较常用、比较简单的分区算法，<strong>三数取中法</strong>和<strong>随机法</strong></p>
<h4 id="三数取中法"><a href="#三数取中法" class="headerlink" title="三数取中法"></a>三数取中法</h4><p>我们从区间的首、尾、中间，分别取出一个数，然后对比大小，取这 3 个数的中间值作为分区点。这样每间隔某个固定的长度，取数据出来比较，将中间值作为分区点的分区算法，肯定要比单纯取某一个数据更好。但是，如果要排序的数组比较大，那“三数取中”可能就不够了，可能要“五数取中”或者“十数取中”。</p>
<h4 id="随机法"><a href="#随机法" class="headerlink" title="随机法"></a>随机法</h4><p>随机法就是每次从要排序的区间中，随机选择一个元素作为分区点。这种方法并不能保证每次分区点都选的比较好，但是从概率的角度来看，也不大可能会出现每次分区点都选的很差的情况，所以平均情况下，这样选的分区点是比较好的。时间复杂度退化为最糟糕的 O(n2) 的情况，出现的可能性不大。</p>
<p>我们知道，快速排序是用递归来实现的。递归需要警惕堆栈溢出。为了避免快速排序里，递归过深而堆栈过小，导致堆栈溢出，我们有两种解决办法：第一种是限制递归深度。一旦递归过深，超过了我们事先设定的阈值，就停止递归。第二种是通过在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈的过程，这样就没有了系统栈大小的限制。</p>
<h3 id="举例分析排序函数"><a href="#举例分析排序函数" class="headerlink" title="举例分析排序函数"></a>举例分析排序函数</h3><p>我们拿<a href="https://zh.wikipedia.org/zh/GNU_C%E5%87%BD%E5%BC%8F%E5%BA%AB" target="_blank" rel="noopener">Glibc</a>中的qsort()函数举例说明一下。虽说 qsort() 从名字上看，很像是基于快速排序算法实现的，实际上它并不仅仅用了快排这一种算法。</p>
<p>源码里qsort() 会优先使用归并排序来排序输入数据，因为归并排序的空间复杂度是 O(n)，所以对于小数据量的排序，比如 1KB、2KB 等，归并排序额外需要 1KB、2KB 的内存空间，这个问题不大。现在计算机的内存都挺大的，我们很多时候追求的是速度。这就是一个典型空间换时间的应用。</p>
<p>但如果数据量太大，就跟我们前面提到的，排序 100MB 的数据，这个时候我们再用归并排序就不合适了。所以，要排序的数据量比较大的时候，qsort() 会改为用快速排序算法来排序。</p>
<p>但如果数据量太大，就跟我们前面提到的，排序 100MB 的数据，这个时候我们再用归并排序就不合适了。所以，<strong>要排序的数据量比较大的时候，qsort() 会改为用快速排序算法来排序</strong>。另外qsort() 选择分区点的方法就是“三数取中法”</p>
<p>还有我们前面提到的递归太深会导致堆栈溢出的问题，qsort() 是通过自己实现一个堆上的栈，手动模拟递归来解决的。</p>
<p>实际上，qsort() 并不仅仅用到了归并排序和快速排序，它还用到了插入排序。在快速排序的过程中，当要排序的区间中元素的个数小于等于 4 时，qsort() 就退化为插入排序，不再继续用递归来做快速排序，因为，<strong>在小规模数据面前，O(n2) 时间复杂度的算法并不一定比 O(nlogn) 的算法执行时间长</strong>。</p>
<p>我们学习复杂度分析的时候有说过，算法的性能可以通过时间复杂度来分析，但是，这种复杂度分析是比较偏理论的，如果我们深究的话，实际上时间复杂度并不等于代码实际的运行时间。</p>
<p>时间复杂度代表的是一个增长趋势，如果画成增长曲线图，你会发现 O(n2) 比 O(nlogn) 要陡峭，也就是说增长趋势要更猛一些。但是，我们前面讲过，在大 O 复杂度表示法中，我们会省略低阶、系数和常数，也就是说，O(nlogn) 在没有省略低阶、系数、常数之前可能是 O(knlogn + c)，而且 k 和 c 有可能还是一个比较大的数。</p>
<p>假设 k=1000，c=200，当我们对小规模数据（比如 n=100）排序时，n2的值实际上比 knlogn+c 还要小。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">knlogn+c &#x3D; 1000 * 100 * log100 + 200 远大于10000</span><br><span class="line"></span><br><span class="line">n^2 &#x3D; 100*100 &#x3D; 10000</span><br></pre></td></tr></table></figure></p>
<p>所以，对于小规模数据的排序，O($n^2$) 的排序算法并不一定比 O(nlogn) 排序算法执行的时间长。对于小数据量的排序，我们选择比较简单、不需要递归的插入排序算法.</p>
<p>我们前面学到哨兵机制可以来简化代码，提高执行效率，在 qsort() 插入排序的算法实现中，也利用了这种编程技巧。虽然哨兵可能只是少做一次判断，但是毕竟排序函数是非常常用、非常基础的函数，性能的优化要做到极致。</p>
<h3 id="笔记小结"><a href="#笔记小结" class="headerlink" title="笔记小结"></a>笔记小结</h3><p>一、如何选择合适的排序算法？<br>1.排序算法一览表<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/14排序优化：如何实现一个通用的、高性能的排序函数？/排序算法比较.png" alt="排序算法比较"><br>2.为什选择快速排序？<br>1）线性排序时间复杂度很低但使用场景特殊，如果要写一个通用排序函数，不能选择线性排序。<br>2）为了兼顾任意规模数据的排序，一般会首选时间复杂度为O(nlogn)的排序算法来实现排序函数。<br>3）同为O(nlogn)的快排和归并排序相比，归并排序不是原地排序算法，所以最优的选择是快排。<br>二、如何优化快速排序？<br>导致快排时间复杂度降为O(n)的原因是分区点选择不合理，最理想的分区点是：被分区点分开的两个分区中，数据的数量差不多。如何优化分区点的选择？有2种常用方法，如下：<br>1.三数取中法<br>①从区间的首、中、尾分别取一个数，然后比较大小，取中间值作为分区点。<br>②如果要排序的数组比较大，那“三数取中”可能就不够用了，可能要“5数取中”或者“10数取中”。<br>2.随机法：每次从要排序的区间中，随机选择一个元素作为分区点。<br>3.警惕快排的递归发生堆栈溢出，有2中解决方法，如下：<br>①限制递归深度，一旦递归超过了设置的阈值就停止递归。<br>②在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈过程，这样就没有系统栈大小的限制。<br>三、通用排序函数实现技巧<br>1.数据量不大时，可以采取用空间换时间的思路<br>2.数据量大时，优化快排分区点的选择<br>3.防止堆栈溢出，可以选择在堆上手动模拟调用栈解决<br>4.在排序区间中，当元素个数小于某个常数是，可以考虑使用O(n^2)级别的插入排序<br>5.用哨兵简化代码，每次排序都减少一次判断，尽可能把性能优化到极致</p>
]]></content>
      <categories>
        <category>DataStructureAndAlgorithm</category>
      </categories>
      <tags>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>12排序（下）：如何用快排思想在O(n)内查找第K大元素？</title>
    <url>/articles/be987358.html/</url>
    <content><![CDATA[<blockquote>
<p>声名：本文大部分内容出自于极客时间网站王争的专栏《数据结构与算法之美》，这里本人主要记录自己的学习过程，添加个人见解，并作为自己的学习笔记。如有侵权，立马删除。</p>
</blockquote>
<a id="more"></a>
<p>我们学习了冒泡排序、插入排序、选择排序这三种排序算法，它们的时间复杂度都是 O(n2)，比较高，适合小规模数据的排序。现在学习时间复杂度为 O(nlogn) 的排序算法，<strong>归并排序</strong>和<strong>快速排序</strong>。这两种排序算法适合大规模的数据排序，比上面那三种排序算法要更常用。</p>
<p>归并排序和快速排序都用到了分治思想，非常巧妙。我们可以借鉴这个思想，来解决非排序的问题，比如：<font color="#FF8C00" size="3">如何在 O(n) 的时间复杂度内查找一个无序数组中的第 K 大元素？</font></p>
<h3 id="归并排序-Merge-Sort"><a href="#归并排序-Merge-Sort" class="headerlink" title="归并排序(Merge Sort)"></a>归并排序(Merge Sort)</h3><p>归并排序的思想是:如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。</p>
<p><img src="/articles/be987358.html/12排序（下）：如何用快排思想在O(n" alt="归并排序分解图">内查找第K大元素？/归并排序分解图.png)</p>
<p>归并排序使用的就是<strong>分治思想</strong>。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。</p>
<p>从刚才的描述，你有没有感觉到，分治思想跟我们前面d的递归思想很像。分治算法一般都是用递归来实现的。<strong>分治是一种解决问题的处理思想，递归是一种编程技巧</strong>，这两者并不冲突。</p>
<h4 id="用递归代码来实现归并排序"><a href="#用递归代码来实现归并排序" class="headerlink" title="用递归代码来实现归并排序"></a>用递归代码来实现归并排序</h4><p>写递归代码的技巧就是，分析得出递推公式，然后找到终止条件，最后将递推公式翻译成递归代码。所以，要想写出归并排序的代码，我们先写出归并排序的递推公式。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">递推公式：</span><br><span class="line">merge_sort(p…r) &#x3D; merge(merge_sort(p…q), merge_sort(q+1…r))</span><br><span class="line">终止条件：</span><br><span class="line">p &gt;&#x3D; r 不用再继续分解</span><br></pre></td></tr></table></figure><br>merge_sort(p…r) 表示，给下标从 p 到 r 之间的数组排序。我们将这个排序问题转化为了两个子问题，merge_sort(p…q) 和 merge_sort(q+1…r)，其中下标 q 等于 p 和 r 的中间位置，也就是 (p+r)/2。当下标从 p 到 q 和从 q+1 到 r 这两个子数组都排好序之后，我们再将两个有序的子数组合并在一起，这样下标从 p 到 r 之间的数据就也排好序了。</p>
<p>有了递推公式，转化成代码就简单多了,这里只给出伪代码，可以翻译成你熟悉的编程语言。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 归并排序算法, A是数组，n表示数组大小</span></span><br><span class="line">merge_sort(A, n) &#123;</span><br><span class="line">  merge_sort_c(A, <span class="number">0</span>, n-<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归调用函数</span></span><br><span class="line">merge_sort_c(A, p, r) &#123;</span><br><span class="line">  <span class="comment">// 递归终止条件</span></span><br><span class="line">  <span class="keyword">if</span> p &gt;= r  then <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取p到r之间的中间位置q</span></span><br><span class="line">  q = (p+r) / <span class="number">2</span></span><br><span class="line">  <span class="comment">// 分治递归</span></span><br><span class="line">  merge_sort_c(A, p, q)</span><br><span class="line">  merge_sort_c(A, q+<span class="number">1</span>, r)</span><br><span class="line">  <span class="comment">// 将A[p...q]和A[q+1...r]合并为A[p...r]</span></span><br><span class="line">  merge(A[p...r], A[p...q], A[q+<span class="number">1</span>...r])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>merge(A[p…r], A[p…q], A[q+1…r]) 这个函数的作用就是，将已经有序的 A[p…q]和 A[q+1…r]合并成一个有序的数组，并且放入 A[p…r]。那这个过程具体该如何做呢？</p>
<p>如图所示，我们申请一个临时数组tmp，大小与 A[p…r]相同。我们用两个游标 i 和 j，分别指向 A[p…q]和 A[q+1…r]的第一个元素。比较这两个元素 A[i]和 A[j]，如果 A[i]&lt;=A[j]，我们就把 A[i]放入到临时数组 tmp，并且 i 后移一位，否则将 A[j]放入到数组 tmp，j 后移一位。</p>
<p>继续上述比较过程，直到其中一个子数组中的所有数据都放入临时数组中，再把另一个数组中的数据依次加入到临时数组的末尾，这个时候，临时数组中存储的就是两个子数组合并之后的结果了。最后再把临时数组 tmp 中的数据拷贝到原数组 A[p…r]中。<br><img src="/articles/be987358.html/12排序（下）：如何用快排思想在O(n" alt="归并排序合并">内查找第K大元素？/归并排序合并.png)</p>
<p>merge() 函数写成伪代码，就是下面这样：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">merge(A[p...r], A[p...q], A[q+1...r]) &#123;</span><br><span class="line">  var i :&#x3D; p，j :&#x3D; q+1，k :&#x3D; 0 &#x2F;&#x2F; 初始化变量i, j, k</span><br><span class="line">  var tmp :&#x3D; new array[0...r-p] &#x2F;&#x2F; 申请一个大小跟A[p...r]一样的临时数组</span><br><span class="line">  while i&lt;&#x3D;q AND j&lt;&#x3D;r do &#123;</span><br><span class="line">    if A[i] &lt;&#x3D; A[j] &#123;</span><br><span class="line">      tmp[k++] &#x3D; A[i++] &#x2F;&#x2F; i++等于i:&#x3D;i+1</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      tmp[k++] &#x3D; A[j++]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 判断哪个子数组中有剩余的数据</span><br><span class="line">  var start :&#x3D; i，end :&#x3D; q</span><br><span class="line">  if j&lt;&#x3D;r then start :&#x3D; j, end:&#x3D;r</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 将剩余的数据拷贝到临时数组tmp</span><br><span class="line">  while start &lt;&#x3D; end do &#123;</span><br><span class="line">    tmp[k++] &#x3D; A[start++]</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 将tmp中的数组拷贝回A[p...r]</span><br><span class="line">  for i:&#x3D;0 to r-p do &#123;</span><br><span class="line">    A[p+i] &#x3D; tmp[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>merge() 合并函数如果借助哨兵，代码就会简洁很多.</p>
<h3 id="归并排序的性能分析"><a href="#归并排序的性能分析" class="headerlink" title="归并排序的性能分析"></a>归并排序的性能分析</h3><p><strong>第一，归并排序是稳定的排序算法吗？</strong><br>结合前面那张图和归并排序的伪代码,归并排序稳不稳定关键要看 merge() 函数，也就是两个有序子数组合并成一个有序数组的那部分代码。</p>
<p>在合并的过程中，如果 A[p…q]和 A[q+1…r]之间有值相同的元素，那我们可以像伪代码中那样，先把 A[p…q]中的元素放入 tmp 数组。这样就保证了值相同的元素，在合并前后的先后顺序不变。所以，归并排序是一个稳定的排序算法。</p>
<p><strong>第二，归并排序的时间复杂度是多少？</strong><br>归并排序涉及递归，时间复杂度的分析稍微有点复杂。我们借此机会来学习一下如何分析递归代码的时间复杂度。</p>
<p>在递归那一节我们讲过，递归的适用场景是，一个问题 a 可以分解为多个子问题 b、c，那求解问题 a 就可以分解为求解问题 b、c。问题 b、c 解决之后，我们再把 b、c 的结果合并成 a 的结果。</p>
<p>如果我们定义求解问题 a 的时间是 T(a)，求解问题 b、c 的时间分别是 T(b) 和 T( c)，那我们就可以得到这样的递推关系式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T(a) &#x3D; T(b) + T(c) + K</span><br></pre></td></tr></table></figure></p>
<p>其中 K 等于将两个子问题 b、c 的结果合并成问题 a 的结果所消耗的时间。</p>
<p>从刚刚的分析，我们可以得到一个重要的结论：<strong>不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式。</strong></p>
<p>套用这个公式，我们来分析一下归并排序的时间复杂度。我们假设对 n 个元素进行归并排序需要的时间是 T(n)，那分解成两个子数组排序的时间都是 T(n/2)。我们知道，merge() 函数合并两个有序子数组的时间复杂度是 O(n)。所以，套用前面的公式，归并排序的时间复杂度的计算公式就是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T(1) &#x3D; C；   n&#x3D;1时，只需要常量级的执行时间，所以表示为C。</span><br><span class="line">T(n) &#x3D; 2*T(n&#x2F;2) + n； n&gt;1</span><br></pre></td></tr></table></figure><br>通过这个公式，如何来求解 T(n) 呢？那我们再进一步分解一下计算过程。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T(n) &#x3D; 2*T(n&#x2F;2) + n</span><br><span class="line">     &#x3D; 2*(2*T(n&#x2F;4) + n&#x2F;2) + n &#x3D; 4*T(n&#x2F;4) + 2*n</span><br><span class="line">     &#x3D; 4*(2*T(n&#x2F;8) + n&#x2F;4) + 2*n &#x3D; 8*T(n&#x2F;8) + 3*n</span><br><span class="line">     &#x3D; 8*(2*T(n&#x2F;16) + n&#x2F;8) + 3*n &#x3D; 16*T(n&#x2F;16) + 4*n</span><br><span class="line">     ......</span><br><span class="line">     &#x3D; 2^k * T(n&#x2F;2^k) + k * n</span><br><span class="line">     ......</span><br></pre></td></tr></table></figure></p>
<p>通过这样一步一步分解推导，我们可以得到 T(n) = 2^kT(n/2^k)+kn。当 T(n/2^k)=T(1) 时，也就是 n/2^k=1，我们得到 k=log2n 。我们将 k 值代入上面的公式，得到 T(n)=Cn+nlog2n 。如果我们用大 O 标记法来表示的话，T(n) 就等于 O(nlogn)。所以归并排序的时间复杂度是 O(nlogn)。</p>
<p>从我们的原理分析和伪代码可以看出，归并排序的执行效率与要排序的原始数组的有序程度无关，所以其时间复杂度是非常稳定的，不管是最好情况、最坏情况，还是平均情况，时间复杂度都是 O(nlogn)。</p>
<p><strong>* 归并排序的空间复杂度是多少？</strong></p>
<p>归并排序的时间复杂度任何情况下都是 O(nlogn)，看起来非常优秀。（即便是快速排序，最坏情况下，时间复杂度也是 O(n2)。）但是，归并排序并没有像快排那样，应用广泛，这是为什么呢？因为它有一个致命的“弱点”，那就是归并排序不是原地排序算法。</p>
<p>这是因为归并排序的合并函数，在合并两个有序数组为一个有序数组时，需要借助额外的存储空间。</p>
<p>实际上，递归代码的空间复杂度并不能像时间复杂度那样累加。刚刚我们忘记了最重要的一点，那就是，尽管每次合并操作都需要申请额外的内存空间，但在合并完成之后，临时开辟的内存空间就被释放掉了。在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过 n 个数据的大小，所以空间复杂度是 O(n)。</p>
<h3 id="快速排序-Quicksort"><a href="#快速排序-Quicksort" class="headerlink" title="快速排序(Quicksort)"></a>快速排序(Quicksort)</h3><p>我们再来看快速排序算法（Quicksort），我们习惯性把它简称为“快排”。快排利用的也是分治思想。乍看起来，它有点像归并排序，但是思路其实完全不一样。现在，我们先来看下快排的核心思想。<br>快排的思想是这样的：如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。</p>
<p>我们遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。<br><img src="/articles/be987358.html/12排序（下）：如何用快排思想在O(n" alt="快排">内查找第K大元素？/快排.png)</p>
<p>根据分治、递归的处理思想，我们可以用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1，就说明所有的数据都有序了。</p>
<p>如果我们用递推公式来将上面的过程写出来的话，就是这样：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">递推公式：</span><br><span class="line">quick_sort(p…r) &#x3D; quick_sort(p…q-1) + quick_sort(q+1… r)</span><br><span class="line"></span><br><span class="line">终止条件：</span><br><span class="line">p &gt;&#x3D; r</span><br></pre></td></tr></table></figure><br>将递推公式转化成递归代码。跟归并排序一样，还是用伪代码来实现:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 快速排序，A是数组，n表示数组的大小</span><br><span class="line">quick_sort(A, n) &#123;</span><br><span class="line">  quick_sort_c(A, 0, n-1)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 快速排序递归函数，p,r为下标</span><br><span class="line">quick_sort_c(A, p, r) &#123;</span><br><span class="line">  if p &gt;&#x3D; r then return</span><br><span class="line">  </span><br><span class="line">  q &#x3D; partition(A, p, r) &#x2F;&#x2F; 获取分区点</span><br><span class="line">  quick_sort_c(A, p, q-1)</span><br><span class="line">  quick_sort_c(A, q+1, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>归并排序中有一个 merge() 合并函数，我们这里有一个 partition() 分区函数。partition() 分区函数实际上我们前面已经讲过了，就是随机选择一个元素作为 pivot（一般情况下，可以选择 p 到 r 区间的最后一个元素），然后对 A[p…r]分区，函数返回 pivot 的下标。</p>
<p>如果我们不考虑空间消耗的话，partition() 分区函数可以写得非常简单。我们申请两个临时数组 X 和 Y，遍历 A[p…r]，将小于 pivot 的元素都拷贝到临时数组 X，将大于 pivot 的元素都拷贝到临时数组 Y，最后再将数组 X 和数组 Y 中数据顺序拷贝到 A[p…r]。<br><img src="/articles/be987358.html/12排序（下）：如何用快排思想在O(n" alt="快排分区">内查找第K大元素？/快排分区.png)</p>
<p>但是，如果按照这种思路实现的话，partition() 函数就需要很多额外的内存空间，所以快排就不是原地排序算法了。如果我们希望快排是原地排序算法，那它的空间复杂度得是 O(1)，那 partition() 分区函数就不能占用太多额外的内存空间，我们就需要在 A[p…r]的原地完成分区操作。</p>
<p>原地分区函数的实现思路非常巧妙，伪代码如下。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">partition(A, p, r) &#123;</span><br><span class="line">  pivot :&#x3D; A[r]</span><br><span class="line">  i :&#x3D; p</span><br><span class="line">  for j :&#x3D; p to r-1 do &#123;</span><br><span class="line">    if A[j] &lt; pivot &#123;</span><br><span class="line">      swap A[i] with A[j]</span><br><span class="line">      i :&#x3D; i+1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  swap A[i] with A[r]</span><br><span class="line">  return i</span><br></pre></td></tr></table></figure><br>C++版本的快排代码<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br></pre></td></tr></table></figure><br>这里可以联想到数组，在数组某个位置插入元素，需要搬移数据，非常耗时。当时我们学习了一种处理技巧，就是交换，在 O(1) 的时间复杂度内完成插入操作。这里我们也借助这个思想，只需要将 A[i]与 A[j]交换，就可以在 O(1) 时间复杂度内将 A[j]放到下标为 i 的位置。如图所示<br><img src="/articles/be987358.html/12排序（下）：如何用快排思想在O(n" alt="交换位置">内查找第K大元素？/交换位置.png)</p>
<p>因为分区的过程涉及交换操作，如果数组中有两个相同的元素，比如序列 6，8，7，6，3，5，9，4，在经过第一次分区操作之后，两个 6 的相对先后顺序就会改变。所以，快速排序并不是一个稳定的排序算法。</p>
<p>现在，再来看另外一个问题：快排和归并用的都是分治思想，递推公式和递归代码也非常相似，那它们的区别在哪里呢？<br><img src="/articles/be987358.html/12排序（下）：如何用快排思想在O(n" alt="快排和归并的区别">内查找第K大元素？/快排和归并的区别.png)</p>
<p>可以发现，归并排序的处理过程是<strong>由下到上</strong>的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是<strong>由上到下</strong>的，先分区，然后再处理子问题。归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法。我们前面讲过，归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。</p>
<h3 id="快速排序的性能分析"><a href="#快速排序的性能分析" class="headerlink" title="快速排序的性能分析"></a>快速排序的性能分析</h3><p>快排是一种原地、不稳定的排序算法。现在，我们集中精力来看快排的时间复杂度。</p>
<p>快排也是用递归来实现的。对于递归代码的时间复杂度，前面总结的公式，这里也还是适用的。如果每次分区操作，都能正好把数组分成大小接近相等的两个小区间，那快排的时间复杂度递推求解公式跟归并是相同的。所以，快排的时间复杂度也是 O(nlogn)。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T(1) &#x3D; C；   n&#x3D;1时，只需要常量级的执行时间，所以表示为C。</span><br><span class="line">T(n) &#x3D; 2*T(n&#x2F;2) + n； n&gt;1</span><br></pre></td></tr></table></figure><br>但是，公式成立的前提是每次分区操作，我们选择的 pivot 都很合适，正好能将大区间对等地一分为二。但实际上这种情况是很难实现的。</p>
<p>举一个比较极端的例子。如果数组中的数据原来已经是有序的了，比如 1，3，5，6，8。如果我们每次选择最后一个元素作为 pivot，那每次分区得到的两个区间都是不均等的。我们需要进行大约 n 次分区操作，才能完成快排的整个过程。每次分区我们平均要扫描大约 n/2 个元素，这种情况下，快排的时间复杂度就从 O(nlogn) 退化成了 O(n2)。</p>
<p>这两个极端情况下的时间复杂度，一个是分区极其均衡，一个是分区极其不不均衡。它们分别对应快排的最好情况时间复杂度和最坏情况时间复杂度。</p>
<p>那快排的平均情况时间复杂度是多少呢？我们假设每次分区操作都将区间分成大小为 9:1 的两个小区间。我们继续套用递归时间复杂度的递推公式，就会变成这样：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T(1) &#x3D; C；   n&#x3D;1时，只需要常量级的执行时间，所以表示为C。</span><br><span class="line">T(n) &#x3D; T(n&#x2F;10) + T(9*n&#x2F;10) + n； n&gt;1</span><br></pre></td></tr></table></figure><br>这个公式的递推求解的过程非常复杂，虽然可以求解，但不推荐用这种方法。实际上，递归的时间复杂度的求解方法除了递推公式之外，还有递归树。这里有一个结论：T(n) 在大部分情况下的时间复杂度都可以做到 O(nlogn)，只有在极端情况下，才会退化到 O(n2)</p>
<h3 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h3><p>快排核心思想就是分治和分区，我们可以利用分区的思想，来解答开篇的问题：O(n) 时间复杂度内求无序数组中的第 K 大元素。比如，4， 2， 5， 12， 3 这样一组数据，第 3 大元素就是 4。</p>
<p>我们选择数组区间 A[0…n-1]的最后一个元素 A[n-1]作为 pivot，对数组 A[0…n-1]原地分区，这样数组就分成了三部分，A[0…p-1]、A[p]、A[p+1…n-1]。</p>
<p>如果 p+1=K，那 A[p]就是要求解的元素；如果 K&gt;p+1, 说明第 K 大元素出现在 A[p+1…n-1]区间，我们再按照上面的思路递归地在 A[p+1…n-1]这个区间内查找。同理，如果K&lt; p+1，那我们就在 A[0…p-1]区间查找。</p>
<p><img src="/articles/be987358.html/12排序（下）：如何用快排思想在O(n" alt="开篇解答">内查找第K大元素？/开篇解答.png)</p>
<p>为什么上述解决思路的时间复杂度是 O(n)？</p>
<p>第一次分区查找，我们需要对大小为 n 的数组执行分区操作，需要遍历 n 个元素。第二次分区查找，我们只需要对大小为 n/2 的数组执行分区操作，需要遍历 n/2 个元素。依次类推，分区遍历元素的个数分别为、n/2、n/4、n/8、n/16.……直到区间缩小为 1。</p>
<h3 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h3><p>归并排序和快速排序是两种稍微复杂的排序算法，它们用的都是分治的思想，代码都是通过递归来实现，过程非常相似。理解归并排序的重点是理解递推公式和 merge() 合并函数。同理，理解快排的重点也是理解递推公式，还有 partition() 分区函数。</p>
<p>归并排序算法是一种在任何情况下时间复杂度都比较稳定的排序算法，这也使它存在致命的缺点，即归并排序不是原地排序算法，空间复杂度比较高，是 O(n)。正因为此，它也没有快排应用广泛。</p>
<p>快速排序算法虽然最坏情况下的时间复杂度是 O(n2)，但是平均情况下时间复杂度都是 O(nlogn)。不仅如此，快速排序算法时间复杂度退化到 O(n2) 的概率非常小，我们可以通过合理地选择 pivot 来避免这种情况。</p>
<h3 id="笔记小结"><a href="#笔记小结" class="headerlink" title="笔记小结"></a>笔记小结</h3><blockquote>
<p>总结：归并排序和快速排序<br>一、分治思想<br>1.分治思想：分治，顾明思意，就是分而治之，将一个大问题分解成小的子问题来解决，小的子问题解决了，大问题也就解决了。<br>2.分治与递归的区别：分治算法一般都用递归来实现的。分治是一种解决问题的处理思想，递归是一种编程技巧。<br>二、归并排序<br>1.算法原理<br>先把数组从中间分成前后两部分，然后对前后两部分分别进行排序，再将排序好的两部分合并到一起，这样整个数组就有序了。这就是归并排序的核心思想。如何用递归实现归并排序呢？写递归代码的技巧就是分写得出递推公式，然后找到终止条件，最后将递推公式翻译成递归代码。递推公式怎么写？如下<br>递推公式：merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))<br>终止条件：p &gt;= r 不用再继续分解<br>2.性能分析<br>1）算法稳定性：<br>归并排序稳不稳定关键要看merge()函数，也就是两个子数组合并成一个有序数组的那部分代码。在合并的过程中，如果 A[p…q] 和 A[q+1…r] 之间有值相同的元素，那我们就可以像伪代码中那样，先把 A[p…q] 中的元素放入tmp数组，这样 就保证了值相同的元素，在合并前后的先后顺序不变。所以，归并排序是一种稳定排序算法。<br>2）时间复杂度：分析归并排序的时间复杂度就是分析递归代码的时间复杂度<br>如何分析递归代码的时间复杂度？<br>递归的适用场景是一个问题a可以分解为多个子问题b、c，那求解问题a就可以分解为求解问题b、c。问题b、c解决之后，我们再把b、c的结果合并成a的结果。若定义求解问题a的时间是T(a)，则求解问题b、c的时间分别是T(b)和T(c)，那就可以得到这样的递推公式：T(a) = T(b) + T(c) + K，其中K等于将两个子问题b、c的结果合并成问题a的结果所消耗的时间。这里有一个重要的结论：不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式。套用这个公式，那么归并排序的时间复杂度就可以表示为：<br>T(1) = C； n=1 时，只需要常量级的执行时间，所以表示为 C。<br>T(n) = 2<em>T(n/2) + n； n&gt;1，其中n就是merge()函数合并两个子数组的的时间复杂度O(n)。<br>T(n) = 2</em>T(n/2) + n<br>     = 2<em>(2</em>T(n/4) + n/2) + n = 4<em>T(n/4) + 2</em>n<br>     = 4<em>(2</em>T(n/8) + n/4) + 2<em>n = 8</em>T(n/8) + 3<em>n<br>     = 8</em>(2<em>T(n/16) + n/8) + 3</em>n = 16<em>T(n/16) + 4</em>n<br>     ……<br>     = 2^k <em> T(n/2^k) + k </em> n<br>     ……<br>当T(n/2^k)=T(1) 时，也就是 n/2^k=1，我们得到k=log2n。将k带入上面的公式就得到T(n)=Cn+nlog2n。如用大O表示法，T(n)就等于O(nlogn)。所以，归并排序的是复杂度时间复杂度就是O(nlogn)。<br>3）空间复杂度：归并排序算法不是原地排序算法，空间复杂度是O(n)<br>为什么？因为归并排序的合并函数，在合并两个数组为一个有序数组时，需要借助额外的存储空间。为什么空间复杂度是O(n)而不是O(nlogn)呢？如果我们按照分析递归的时间复杂度的方法，通过递推公式来求解，那整个归并过程需要的空间复杂度就是O(nlogn)，但这种分析思路是有问题的！因为，在实际上，递归代码的空间复杂度并不是像时间复杂度那样累加，而是这样的过程，即在每次合并过程中都需要申请额外的内存空间，但是合并完成后，临时开辟的内存空间就被释放掉了，在任意时刻，CPU只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时空间再大也不会超过n个数据的大小，所以空间复杂度是O(n)。</p>
</blockquote>
]]></content>
      <categories>
        <category>DataStructureAndAlgorithm</category>
      </categories>
      <tags>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>13线性排序：如何根据年龄给100万用户数据排序?</title>
    <url>/articles/adeb2f2f.html/</url>
    <content><![CDATA[<blockquote>
<p>声名：本文大部分内容出自于极客时间网站王争的专栏《数据结构与算法之美》，这里本人主要记录自己的学习过程，添加个人见解，并作为自己的学习笔记。如有侵权，立马删除。</p>
</blockquote>
<a id="more"></a>
<p>在前面的学习中，我们学习了冒泡排序，插入排序和选择排序等时间复杂度为O(n2)的排序算法，还学习了时间复杂度为O(nlogn)归并排序和快速排序算法，现在学习下时间复杂度为O(n)排序算法：桶排序、计数排序和基数排序，由于这些排序算法的是时间复杂度是线性的，所以称这些算法为<strong>线性排序</strong>（Linear Sort),这些算法有个共同的特点，不涉及元素间的比较。现在来一一介绍它们。</p>
<h3 id="桶排序-Bucket-sort"><a href="#桶排序-Bucket-sort" class="headerlink" title="桶排序(Bucket sort)"></a>桶排序(Bucket sort)</h3><p>桶排序的核心思想就是将要排序的数据分到几个有序的桶里，每个桶的数据再单独进行排序。桶内排序完毕后，将每个桶的数据按照顺序依次取出，那么最终的数据就是有序的。</p>
<p><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/13线性排序：如何根据年龄给100万用户数据排序/桶排序.png" alt="桶排序"></p>
<h4 id="桶排序的时间复杂度"><a href="#桶排序的时间复杂度" class="headerlink" title="桶排序的时间复杂度"></a>桶排序的时间复杂度</h4><p>分析一波，如果要排序的数据有n个,将他们均匀的分到m个桶中，那每个桶就有k=n/m个元素，每个桶中的数据使用快速排序算法，时间复杂度就为O(k <em> logk),m个桶的总的时间复杂度就为O(m </em> k <em> logk),m </em> k = n,所以整个桶排序的时间复杂度为O(nlog(n/m)),当通道个数接近数据个数n时，log(n/m)是一个非常小的常量，则这个时候桶排序的时间复杂度就接近O(n),实际上当m较小时，桶排序的时间复杂度是接近O(nlogn)的。<br>dou</p>
<h4 id="桶排序的优劣势"><a href="#桶排序的优劣势" class="headerlink" title="桶排序的优劣势"></a>桶排序的优劣势</h4><p>桶排序的时间复杂度是O(n),在时间复杂度方面，看起来比之前的排序算法都优秀，但是实际上桶排序对于数据的要求是非常苛刻的。</p>
<p>首先，要排序的数据需要很容易就能划分成m个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内的数据都排序完之后，桶与桶之间的数据不需要再进行排序。</p>
<p>其次，数据在各个桶之间的分布是比较均匀的。如果数据经过桶的划分之后，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了。在极端情况下，如果数据都被划分到一个桶里，那就退化为O（nlogn）的排序算法了。</p>
<p>在实际的应用中，<strong>桶排序比较适合用在外部排序中</strong>，所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将全部数据加载到内存中。</p>
<p>比如说我们有 10GB 的订单数据，我们希望按订单金额（假设金额都是正整数）进行排序，但是我们的内存有限，只有几百 MB，没办法一次性把 10GB 的数据都加载到内存中。这个时候<strong>桶排序</strong>就比较有优势了.</p>
<p>我们可以先扫描一遍文件，看订单金额所处的数据范围。假设经过扫描之后我们得到，订单金额最小是 1 元，最大是 10 万元。我们将所有订单根据金额划分到 100 个桶里，第一个桶我们存储金额在 1 元到 1000 元之内的订单，第二桶存储金额在 1001 元到 2000 元之内的订单，以此类推。每一个桶对应一个文件，并且按照金额范围的大小顺序编号命名（00，01，02…99）。</p>
<p>理想的情况下，如果订单金额在 1 到 10 万之间均匀分布，那订单会被均匀划分到 100 个文件中，每个小文件中存储大约 100MB 的订单数据，我们就可以将这 100 个小文件依次放到内存中，用快排来排序。等所有文件都排好序之后，我们只需要按照文件编号，从小到大依次读取每个小文件中的订单数据，并将其写入到一个文件中，那这个文件中存储的就是按照金额从小到大排序的订单数据了。</p>
<p>但是有可能订单按照金额在 1 元到 10 万元之间并不一定是均匀分布的 ，所以 10GB 订单数据是无法均匀地被划分到 100 个文件中的。有可能某个金额区间的数据特别多，划分之后对应的文件就会很大，没法一次性读入内存。</p>
<p>针对这些划分之后还是比较大的文件，我们可以继续划分，比如，订单金额在 1 元到 1000 元之间的比较多，我们就将这个区间继续划分为 10 个小区间，1 元到 100 元，101 元到 200 元，201 元到 300 元…901 元到 1000 元。如果划分之后，101 元到 200 元之间的订单还是太多，无法一次性读入内存，那就继续再划分，直到所有的文件都能读入内存为止。</p>
<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>计数排序在某种情况下是桶排序的一种特殊情况。当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。</p>
<p>高考查分系统就是一个例子，我们查分数的时候，系统会显示我们的成绩以及所在省的排名。假设我们所在的省有50万考生，我们想通过成绩快速排序得出名次，可以这样做，考生的满分是750分，最小是 0 分，这个数据的范围很小，所以我们可以分成751个桶，对应分数从0分到750分。根据考生的成绩，我们将这50万考生划分到这701个桶里。桶内的数据都是分数相同的考生，所以并不需要再进行排序。我们只需要依次扫描每个桶，将桶内的考生依次输出到一个数组中，就实现了50万考生的排序。因为只涉及扫描遍历操作，所以时间复杂度是 O(n)。</p>
<p>计数排序的算法思想跟桶排序非常类似，只是桶的大小粒度不一样。不过，为什么这个排序算法叫“计数”排序呢？</p>
<p>想弄明白这个问题，我们就要来看计数排序算法的实现方法。还拿考生那个例子来解释。为了方便说明，假设只有 8 个考生，分数在 0 到 5 分之间。这 8 个考生的成绩我们放在一个数组 A[8]中，它们分别是：2，5，3，0，2，3，0，3。</p>
<p>考生的成绩从 0 到 5 分，我们使用大小为 6 的数组 C[6]表示桶，其中下标对应分数。不过，C[6]内存储的并不是考生，而是对应的考生个数。像刚刚举的那个例子，我们只需要遍历一遍考生分数，就可以得到 C[6]的值。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/13线性排序：如何根据年龄给100万用户数据排序/计数排序.png" alt="计数排序"></p>
<p>从图中可以看出，分数为 3 分的考生有 3 个，小于 3 分的考生有 4 个，所以，成绩为 3 分的考生在排序之后的有序数组 R[8]中，会保存下标 4，5，6 的位置。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/13线性排序：如何根据年龄给100万用户数据排序/计数排序2.png" alt="计数排序2"></p>
<p>那我们如何快速计算出，每个分数的考生在有序数组中对应的存储位置呢?思路是这样的：我们对 C[6]数组顺序求和，C[6]存储的数据就变成了下面这样子。C[k]里存储小于等于分数 k 的考生个数。</p>
<p><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/13线性排序：如何根据年龄给100万用户数据排序/计数排序3.png" alt="计数排序3"></p>
<p>我们从后到前依次扫描数组 A。比如，当扫描到 3 时，我们可以从数组 C 中取出下标为 3 的值 7，也就是说，到目前为止，包括自己在内，分数小于等于 3 的考生有 7 个，也就是说 3 是数组 R 中的第 7 个元素（也就是数组 R 中下标为 6 的位置）。当 3 放入到数组 R 中后，小于等于 3 的元素就只剩下了 6 个了，所以相应的 C[3]要减 1，变成 6。以此类推，当我们扫描到第 2 个分数为 3 的考生的时候，就会把它放入数组 R </p>
<p>以此类推，当我们扫描到第 2 个分数为 3 的考生的时候，就会把它放入数组 R 中的第 6 个元素的位置（也就是下标为 5 的位置）。当我们扫描完整个数组 A 后，数组 R 内的数据就是按照分数从小到大有序排列的了。</p>
<p><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/13线性排序：如何根据年龄给100万用户数据排序/计数排序4.jpg" alt="计数排序4"></p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计数排序，a是数组，n是数组大小。假设数组中存储的都是非负整数。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countingSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查找数组中数据的范围</span></span><br><span class="line">  <span class="keyword">int</span> max = a[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (max &lt; a[i]) &#123;</span><br><span class="line">      max = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[max + <span class="number">1</span>]; <span class="comment">// 申请一个计数数组c，下标大小[0,max]</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= max; ++i) &#123;</span><br><span class="line">    c[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算每个元素的个数，放入c中</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    c[a[i]]++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 依次累加</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= max; ++i) &#123;</span><br><span class="line">    c[i] = c[i-<span class="number">1</span>] + c[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 临时数组r，存储排序之后的结果</span></span><br><span class="line">  <span class="keyword">int</span>[] r = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">  <span class="comment">// 计算排序的关键步骤，有点难理解</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">int</span> index = c[a[i]]-<span class="number">1</span>;</span><br><span class="line">    r[index] = a[i];</span><br><span class="line">    c[a[i]]--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将结果拷贝给a数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    a[i] = r[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>总结一下，计数排序只能用在数据范围不大的场景中，<strong>如果数据范围 k 比要排序的数据 n 大很多</strong>，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。</p>
<p>比如，还是拿考生这个例子。如果考生成绩精确到小数后一位，我们就需要将所有的分数都先乘以 10，转化成整数，然后再放到 7510 个桶内。再比如，如果要排序的数据中有负数，数据的范围是[-1000, 1000]，那我们就需要先对每个数据都加 1000，转化成非负整数。</p>
<h3 id="基数排序（Radix-sort）"><a href="#基数排序（Radix-sort）" class="headerlink" title="基数排序（Radix sort）"></a>基数排序（Radix sort）</h3><p>假设我们有 10 万个手机号码，希望将这 10 万个手机号码从小到大排序，有什么比较快速的排序方法呢？</p>
<p>我们之前讲的快排，时间复杂度可以做到 O(nlogn),桶排序和计数排序由于范围太大，显然不适合，针对这个排序问题现在我就来介绍一种新的排序算法，基数排序。</p>
<p>刚刚这个问题里有这样的规律：假设要比较两个手机号码 a，b 的大小，如果在前面几位中，a 手机号码已经比 b 手机号码大了，那后面的几位就不用看了。</p>
<p>借助稳定排序算法，这里有一个巧妙的实现思路。先按照最后一位来排序手机号码，然后，再按照倒数第二位重新排序，以此类推，最后按照第一位重新排序。经过 11 次排序之后，手机号码就都有序了。</p>
<p>手机号码稍微有点长，画图比较不容易看清楚，这里使用字符串字排序的例子，<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/13线性排序：如何根据年龄给100万用户数据排序/基排序.png" alt="基排序"></p>
<p>注意，这里按照每位来排序的排序算法要是稳定的，否则这个实现思路就是不正确的。因为如果是非稳定排序算法，那最后一次排序只会考虑最高位的大小顺序，完全不管其他位的大小关系，那么低位的排序就完全没有意义了。</p>
<p>根据每一位来排序，我们可以用刚讲过的桶排序或者计数排序，它们的时间复杂度可以做到 O(n)。如果要排序的数据有 k 位，那我们就需要 k 次桶排序或者计数排序，总的时间复杂度是 O(k*n)。当 k 不大的时候，比如手机号码排序的例子，k 最大就是 11，所以基数排序的时间复杂度就近似于 O(n)。</p>
<p>实际上，有时候要排序的数据并不都是等长的，比如我们排序牛津字典中的 20 万个英文单词，最短的只有 1 个字母,最长的有 45 个字母，中文翻译是尘肺病.对于这种不等长的数据,我们可以把所有的单词补齐到相同长度，位数不够的可以在后面补“0”，因为根据ASCII 值，所有字母都大于“0”，所以补“0”不会影响到原有的大小顺序。这样就可以继续用基数排序了。</p>
<p>总结一下，基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了。</p>
<h3 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h3><p>3种线性时间复杂度的排序算法，有桶排序、计数排序、基数排序。它们对要排序的数据都有比较苛刻的要求，应用不是非常广泛。</p>
<p>桶排序和计数排序的排序思想是非常相似的，都是针对范围不大的数据，将数据划分成不同的桶来实现排序。基数排序要求数据可以划分成高低位，位之间有递进关系。比较两个数，我们只需要比较高位，高位相同的再比较低位。而且每一位的数据范围不能太大，因为基数排序算法需要借助桶排序或者计数排序来完成每一个位的排序工作。</p>
<h3 id="笔记小结"><a href="#笔记小结" class="headerlink" title="笔记小结"></a>笔记小结</h3><p>桶排序:</p>
<ol>
<li>原理: 根据数据范围，分成若干个数据段的桶，通过遍历讲数据放到对应的桶中。每个桶里都进行快排或归并。</li>
<li>时间复杂度: 最好o(n), 最坏o(nlogn), 平均o(n)，一般桶分的越细越多复杂度就会最好。</li>
<li>内存消耗: o(n)</li>
<li>稳定性: 取决于每个桶的排序方式，快排就不稳定，归并就稳定。</li>
<li>适用场景: 数据范围不大的。内存吃紧的，如磁盘的读写可以分成多个小文件并对每个小文件排序，然后直接写到大文件里，这个时候内存消耗不再是o(n)了。</li>
</ol>
<p>计数排序:</p>
<ol>
<li>原理: 特殊的桶排序，即每个下标代表一个数据范围，其值就是这个数据的个数。</li>
<li>时间复杂度: 都是o(n)</li>
<li>内存消耗: o(n)</li>
<li>稳定性: 稳定，只要整理最后结果时从后开始遍历即可。</li>
<li>适用场景: 数据范围不大的，如年龄排序。</li>
</ol>
<p>基数排序:</p>
<ol>
<li>原理: 对数据的每一位进行桶排序或计数排序，对每位排序后结果就是有序的。</li>
<li>时间复杂度: 最好o(n), 最坏o(nlogn), 平均o(n)</li>
<li>内存消耗: o(n)</li>
<li>稳定性: 稳定。否则就排不成的。</li>
<li>适用场景: 是在桶排序和计数排序基础上进行的，保证每位数据范围不大，并且位数也不是很多。</li>
</ol>
<p>桶排序———&gt;分桶+快速排序—&gt;取出结果<br>计数排序———&gt;分桶+计数—&gt;<br>先统计计数，再取出来，实现排序<br>基数排序———&gt;在每个位上桶排序—&gt;</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://mp.weixin.qq.com/s/KU-AUGOnLeRtE_hivl2uSA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/KU-AUGOnLeRtE_hivl2uSA</a></p>
]]></content>
      <categories>
        <category>DataStructureAndAlgorithm</category>
      </categories>
      <tags>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>15二分查找（上）：如何用最省内存的方式实现快速查找功能？</title>
    <url>/articles/f7de8b62.html/</url>
    <content><![CDATA[<blockquote>
<p>声名：本文大部分内容出自于极客时间网站王争的专栏《数据结构与算法之美》，这里本人主要记录自己的学习过程，添加个人见解，并作为自己的学习笔记。如有侵权，立马删除。</p>
</blockquote>
<a id="more"></a>
<p>二分查找（Binary Search）也叫作折半查找。二分查找有两个要求，一个是数列有序，另一个是数列使用顺序存储结构（比如数组）。</p>
<h3 id="问题导向"><a href="#问题导向" class="headerlink" title="问题导向"></a>问题导向</h3><p>假设有1000万个整数数据，每个数据占8个字节，如何设计数据结构和算法，快速判断某个整数是否出现在这1000万数据中？ 我们希望这个功能不要占用太多的内存空间，最多不要超过 100MB，该怎么做呢？</p>
<h3 id="无处不在的二分思想"><a href="#无处不在的二分思想" class="headerlink" title="无处不在的二分思想"></a>无处不在的二分思想</h3><p>二分查找是一种非常简单易懂的快速查找算法，生活中到处可见。比如猜数字游戏，随机写一个0到99之间的数字，然后来猜这个数字是啥。猜的过程中，每猜一次，会告诉你猜的数字大了还是小了，直到猜中为止。假设我们要猜的数字是23，下面那张图显示了猜的过程<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/15二分查找（上）：如何用最省内存的方式实现快速查找功能？/猜数字.png" alt="猜数字"></p>
<p>7次就猜出来了，速度很快，这个例子用的就是二分思想，按照这个思想，即便让猜的是0到999的数字，最多也只要10次就能猜中。</p>
<p>这是一个生活中的例子，我们现在回到实际的开发场景中。假设有1000条订单数据，已经按照订单金额从小到大排序，每个订单金额都不同，并且最小单位是元。我们现在想知道是否存在金额等于 19 元的订单。如果存在，则返回订单数据，如果不存在则返回null。</p>
<p>最简单的办法当然是从第一个订单开始，一个一个遍历这 1000 个订单，直到找到金额等于 19 元的订单为止。但这样查找会比较慢，最坏情况下，可能要遍历完这 1000 条记录才能找到。现在我们用二分查找的思想来想一想这个问题。</p>
<p>我们先假设只有 10 个订单，订单金额分别是：8，11，19，23，27，33，45，55，67，98。</p>
<p>还是利用二分思想，<strong>每次都与区间的中间数据比对大小，缩小查找区间的范围</strong>。下面是查找过程的图。其中，low 和 high 表示待查找区间的下标，mid 表示待查找区间的中间元素下标。</p>
<p><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/15二分查找（上）：如何用最省内存的方式实现快速查找功能？/二分查找.png" alt></p>
<p><strong>二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。</strong></p>
<h3 id="O-logn-惊人的查找速度"><a href="#O-logn-惊人的查找速度" class="headerlink" title="O(logn) 惊人的查找速度"></a>O(logn) 惊人的查找速度</h3><p>二分查找是一种非常高效的查找算法，我们来分析一下它的时间复杂度。我们假设数据大小是 n，每次查找后数据都会缩小为原来的一半，也就是会除以 2。最坏情况下，直到查找区间被缩小为空，才停止。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/15二分查找（上）：如何用最省内存的方式实现快速查找功能？/时间复杂度.png" alt></p>
<p>可以看出来，这是一个等比数列。其中 n/2k=1 时，k 的值就是总共缩小的次数。而每一次缩小操作只涉及两个数据的大小比较，所以，经过了 k 次区间缩小操作，时间复杂度就是 O(k)。通过 n/2k=1，我们可以求得 k=log2n，所以时间复杂度就是 O(logn)。</p>
<p>O(logn) 这种对数时间复杂度。这是一种极其高效的时间复杂度，有的时候甚至比时间复杂度是常量级 O(1) 的算法还要高效。为什么这么说呢？因为 logn 是一个非常“恐怖”的数量级，即便 n 非常非常大，对应的 logn 也很小。比如 n 等于 2 的 32 次方，这个数很大了吧？大约是 42 亿。也就是说，如果我们在 42 亿个数据中用二分查找一个数据，最多需要比较 32 次。我们前面讲过，用大 O 标记法表示时间复杂度的时候，</p>
<p>用大 O 标记法表示时间复杂度的时候，会省略掉常数、系数和低阶。对于常量级时间复杂度的算法来说，O(1) 有可能表示的是一个非常大的常量值，比如 O(1000)、O(10000)。所以，常量级时间复杂度的算法有时候可能还没有 O(logn) 的算法执行效率高。</p>
<h3 id="二分查找的递归与非递归实现"><a href="#二分查找的递归与非递归实现" class="headerlink" title="二分查找的递归与非递归实现"></a>二分查找的递归与非递归实现</h3><p>最简单的情况就是有序数组中不存在重复元素，我们在其中用二分查找值等于给定值的数据。Java代码实现的一个最简单的二分查找算法如下。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[mid] == value) &#123;</span><br><span class="line">      <span class="keyword">return</span> mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) &#123;</span><br><span class="line">      low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>low、high、mid 都是指数组下标，其中 low 和 high 表示当前查找的区间范围，初始 low=0， high=n-1。mid 表示[low, high]的中间位置。我们通过对比 a[mid]与 value 的大小，来更新接下来要查找的区间范围，直到找到或者区间缩小为 0，就退出。<strong>这里有三个易错的地方</strong></p>
<h4 id="1-循环退出条件"><a href="#1-循环退出条件" class="headerlink" title="1.循环退出条件"></a>1.循环退出条件</h4><p>注意是 low&lt;=high，而不是 low&lt; high。</p>
<h4 id="2-mid-的取值"><a href="#2-mid-的取值" class="headerlink" title="2.mid 的取值"></a>2.mid 的取值</h4><p>实际上，mid=(low+high)/2 这种写法是有问题的。因为如果 low 和 high 比较大的话，两者之和就有可能会溢出。改进的方法是将 mid 的计算方式写成 low+(high-low)/2。更进一步，如果要将性能优化到极致的话，我们可以将这里的除以 2 操作转化成位运算 low+((high-low)&gt;&gt;1)。因为相比除法运算来说，计算机处理位运算要快得多。</p>
<h4 id="3-low-和-high-的更新"><a href="#3-low-和-high-的更新" class="headerlink" title="3.low 和 high 的更新"></a>3.low 和 high 的更新</h4><p>ow=mid+1，high=mid-1。注意这里的 +1 和 -1，如果直接写成 low=mid 或者 high=mid，就可能会发生死循环。比如，当 high=3，low=3 时，如果 a[3]不等于 value，就会导致一直循环不退出。</p>
<p>实际上，二分查找除了用循环来实现，还可以用递归来实现，过程也非常简单。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二分查找的递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> bsearchInternally(a, <span class="number">0</span>, n - <span class="number">1</span>, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">bsearchInternally</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (low &gt; high) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (a[mid] == value) &#123;</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) &#123;</span><br><span class="line">    <span class="keyword">return</span> bsearchInternally(a, mid+<span class="number">1</span>, high, value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> bsearchInternally(a, low, mid-<span class="number">1</span>, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="二分查找应用场景的局限性"><a href="#二分查找应用场景的局限性" class="headerlink" title="二分查找应用场景的局限性"></a>二分查找应用场景的局限性</h3><p>前面我们分析过，二分查找的时间复杂度是 O(logn)，查找数据的效率非常高。不过，并不是什么情况下都可以用二分查找，它的应用场景是有很大局限性的。</p>
<p><strong>首先，二分查找依赖的是顺序表结构，简单点说就是数组</strong>。二分查找也不能依赖链表这种数据结构，主要原因是二分查找算法需要按照下标随机访问元素。我们在数组和链表学过，数组按照下标随机访问数据的时间复杂度是 O(1)，而链表随机访问的时间复杂度是 O(n)。所以，如果数据使用链表存储，二分查找的时间复杂就会变得很高。二分查找只能用在数据是通过顺序表来存储的数据结构上。如果数据是通过其他数据结构存储的，则无法应用二分查找。</p>
<p><strong>其次，二分查找针对的是有序数据</strong>。二分查找对这一点的要求比较苛刻，数据必须是有序的。如果数据没有序，我们需要先排序。前面有讲过，排序的时间复杂度最低是 O(nlogn)。所以，如果我们针对的是一组静态的数据，没有频繁地插入、删除，我们可以进行一次排序，多次二分查找。这样排序的成本可被均摊，二分查找的边际成本就会比较低。</p>
<p><strong>二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景中</strong>。如果我们的数据集合有频繁的插入和删除操作，要想用二分查找，要么每次插入、删除操作之后保证数据仍然有序，要么在每次二分查找之前都先进行排序。针对这种动态数据集合，无论哪种方法，维护有序的成本都是很高的。针对动态变化的数据集合，二分查找将不再适用。</p>
<p><strong>再次，数据量太小不适合二分查找</strong>。如果要处理的数据量很小，完全没有必要用二分查找，顺序遍历就足够了。比如我们在一个大小为 10 的数组中查找一个元素，不管用二分查找还是顺序遍历，查找速度都差不多。只有数据量比较大的时候，二分查找的优势才会比较明显。也有例外。如果数据之间的比较操作非常耗时，不管数据量大小，我都推荐使用二分查找。比如，数组中存储的都是长度超过 300 的字符串，如此长的两个字符串之间比对大小，就会非常耗时。</p>
<p><strong>最后，数据量太大也不适合二分查找</strong>。二分查找的底层需要依赖数组这种数据结构，而数组为了支持随机访问的特性，要求内存空间连续，对内存的要求比较苛刻。比如，我们有 1GB 大小的数据，如果希望用数组来存储，那就需要 1GB 的连续内存空间。太大的数据用数组存储就比较吃力了，也就不能用二分查找了。</p>
<h3 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h3><p>这个问题并不难。我们的内存限制是 100MB，每个数据大小是 8 字节，最简单的办法就是将数据存储在数组中，内存占用差不多是 80MB，符合内存的限制。借助今天讲的内容，我们可以先对这 1000 万数据从小到大排序，然后再利用二分查找算法，就可以快速地查找想要的数据了。</p>
<p>虽然大部分情况下，用二分查找可以解决的问题，用散列表、二叉树都可以解决。但是，我们后面会讲，不管是散列表还是二叉树，都会需要比较多的额外的内存空间。如果用散列表或者二叉树来存储这 1000 万的数据，用 100MB 的内存肯定是存不下的。而二分查找底层依赖的是数组，除了数据本身之外，不需要额外存储其他信息，是最省内存空间的存储方式，所以刚好能在限定的内存大小下解决这个问题。</p>
<h3 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h3><p>二分查找是一种针对<strong>有序数据</strong>的高效查找算法，它的时间复杂度是 O(logn)。二分查找的核心思想有点类似分治思想。即每次都通过跟区间中的中间元素对比，将待查找的区间缩小为一半，直到找到要查找的元素，或者区间被缩小为 0。但是二分查找的代码实现比较容易写错。你需要着重掌握它的三个容易出错的地方：循环退出条件、mid 的取值，low 和 high 的更新。</p>
<p>二分查找虽然性能比较优秀，但应用场景也比较有限。底层必须依赖数组，并且还要求数据是有序的。对于较小规模的数据查找，我们直接使用顺序遍历就可以了，二分查找的优势并不明显。二分查找更适合处理静态数据，也就是没有频繁的数据插入、删除操作。</p>
<h3 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h3><p>如果数据使用链表存储，二分查找的时间复杂就会变得很高，那查找的时间复杂度究竟是多少呢？如果你自己推导一下，你就会深刻地认识到，为何我们会选择用数组而不是链表来实现二分查找了。</p>
<blockquote>
<p>解答：假设链表长度为n，二分查找每次都要找到中间点(计算中忽略奇偶数差异):<br>第一次查找中间点，需要移动指针n/2次；<br>第二次，需要移动指针n/4次；<br>第三次需要移动指针n/8次；<br>……<br>以此类推，一直到1次为值总共指针移动次数(查找次数) = n/2 + n/4 + n/8 + …+ 1，这显然是个等比数列，根据等比数列求和公式：Sum = n - 1.<br>最后算法时间复杂度是：O(n-1)，忽略常数，记为O(n)，时间复杂度和顺序查找时间复杂度相同。但是稍微思考下，在二分查找的时候，由于要进行多余的运算，严格来说，会比顺序查找时间慢</p>
</blockquote>
]]></content>
      <categories>
        <category>DataStructureAndAlgorithm</category>
      </categories>
      <tags>
        <tag>Search</tag>
      </tags>
  </entry>
  <entry>
    <title>17跳表：为什么Redis一定要用跳表来实现有序集合？</title>
    <url>/articles/35b6f02d.html/</url>
    <content><![CDATA[<blockquote>
<p>声名：本文大部分内容出自于极客时间网站王争的专栏《数据结构与算法之美》，这里本人主要记录自己的学习过程，添加个人见解，并作为自己的学习笔记。如有侵权，立马删除。</p>
</blockquote>
<a id="more"></a>
<p>我们在二分查找那节说过<strong>因为二分查找底层依赖的是数组随机访问的特性，所以只能用数组来实现</strong>，事实上，如果数据存储在链表这种数据结构，稍加改造，也可以实现类似<strong>二分</strong>的查找算法。我们把改造链表后的数据结构称之为<strong>跳表(skip list)</strong>。跳表这种数据结构对可能会比较陌生，因为一般的数据结构和算法书籍里都不怎么会讲。但是它确实是一种各方面性能都比较优秀的<strong>动态数据结构</strong>，可以支持快速的插入、删除、查找操作，写起来也不复杂，甚至可以替代<a href="https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91" target="_blank" rel="noopener">红黑树（Red-black tree）</a>。</p>
<h3 id="问题导向"><a href="#问题导向" class="headerlink" title="问题导向"></a>问题导向</h3><p>Redis 中的有序集合（Sorted Set）就是用跳表来实现的。如果你有一定基础，应该知道红黑树也可以实现快速的插入、删除和查找操作。那 Redis 为什么会选择用跳表来实现有序集合呢？ 为什么不用红黑树呢？</p>
<h3 id="什么是“跳表”"><a href="#什么是“跳表”" class="headerlink" title="什么是“跳表”"></a>什么是“跳表”</h3><p><strong>跳表是一个随机化的数据结构，实质就是一种可以进行二分查找的有序链表。跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能</strong>。对于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是 O(n)。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/17跳表：为什么Redis一定要用跳表来实现有序集合？/单链表.png" alt></p>
<p>如果像图中那样，对链表建立一级“索引”，查找起来就会更快一些.<strong>每两个结点</strong>提取一个结点到上一级，我们把抽出来的那一级叫作<strong>索引或索引层</strong>。如下图。图中的 down 表示 down 指针，指向下一级结点。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/17跳表：为什么Redis一定要用跳表来实现有序集合？/跳表.png" alt></p>
<p>如果我们现在要查找某个结点，比如 16。我们可以先在索引层遍历，当遍历到索引层中值为 13 的结点时，我们发现下一个结点是 17，那要查找的结点 16 肯定就在这两个结点之间。然后我们通过索引层结点的 down 指针，下降到原始链表这一层，继续遍历。这个时候，我们只需要再遍历 2 个结点，就可以找到值等于 16 的这个结点了。这样，原来如果要查找 16，需要遍历 10 个结点，现在只需要遍历 7 个结点。</p>
<p>从这个例子里，我们看出，加来一层索引之后，查找一个结点需要遍历的结点个数减少了，也就是说查找效率提高了。那如果我们再加一级索引呢？跟前面建立第一级索引的方式相似，我们在第一级索引的基础之上，每两个结点就抽出一个结点到第二级索引。现在我们再来查找 16，只需要遍历 6 个结点了，需要遍历的结点数量又减少了。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/17跳表：为什么Redis一定要用跳表来实现有序集合？/跳表2.png" alt></p>
<p>由于举的例子数据量不大，所以即便加了两级索引，查找效率的提升也并不明显。为了让能真切地感受索引提升查询效率。下面有一张包含 64 个结点的链表，按照前面讲的这种思路，建立了五级索引。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/17跳表：为什么Redis一定要用跳表来实现有序集合？/跳表3.png" alt></p>
<p>从图中我们可以看出，原来没有索引的时候，查找 62 需要遍历 62 个结点，现在只需要遍历 11 个结点，速度就很快了。所以，当链表的长度 n 比较大时，比如 1000、10000 的时候，在构建索引之后，查找效率的提升就会非常明显。前面讲的这种<strong>链表加多级索引</strong>的结构，就是跳表。通过例子可以比较清晰地知道，跳表确实是可以提高查询效率的。接下来定量地分析一下，用跳表查询到底有多快。</p>
<h4 id="跳表查询效率"><a href="#跳表查询效率" class="headerlink" title="跳表查询效率"></a>跳表查询效率</h4><p>先来看这样一个问题，如果链表里有 n 个结点，会有多少级索引呢？按照我们刚才讲的，每两个结点会抽出一个结点作为上一级索引的结点，那第一级索引的结点个数大约就是 n/2，第二级索引的结点个数大约就是 n/4，第三级索引的结点个数大约就是 n/8，依次类推，也就是说，<strong>第 k 级索引的结点个数是第 k-1 级索引的结点个数的 1/2，那第 k级索引结点的个数就是 n/(2^k)</strong>。假设索引有 h 级，最高级的索引有 2 个结点。通过上面的公式，我们可以得到 n/(2^h)=2，从而求得 h=log2n-1。如果包含原始链表这一层，整个跳表的高度就是 log2n。我们在跳表中查询某个数据的时候，如果每一层都要遍历 m 个结点，那在跳表中查询一个数据的时间复杂度就是<strong>O(m*logn)</strong>。</p>
<p>按照前面这种索引结构，我们每一级索引都最多只需要遍历 3 个结点，也就是说 m=3，关于m的取值我们来分析下：<br>假设我们要查找的数据是 x，在第 k 级索引中，我们遍历到 y 结点之后，发现 x 大于 y，小于后面的结点 z，所以我们通过 y 的 down 指针，从第 k 级索引下降到第 k-1 级索引。在第 k-1 级索引中，y 和 z 之间只有 3 个结点（包含 y 和 z），所以，我们在 K-1 级索引中最多只需要遍历 3 个结点，依次类推，每一级索引都最多只需要遍历 3 个结点。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/17跳表：为什么Redis一定要用跳表来实现有序集合？/跳表4.png" alt></p>
<p>通过上面的分析，我们得到 m=3，所以在跳表中查询任意数据的时间复杂度就是 O(logn)。这个查找的时间复杂度跟二分查找是一样的。换句话说，我们其实是基于单链表实现了二分查找.不过，天下没有免费的午餐，这种查询效率的提升，前提是建立了很多级索引，也就是我们<a href="https://www.wangng.com/articles/79fba95f.html/" target="_blank" rel="noopener">在第6节</a>讲过的空间换时间的设计思路。</p>
<h4 id="跳表空间复杂度"><a href="#跳表空间复杂度" class="headerlink" title="跳表空间复杂度"></a>跳表空间复杂度</h4><p>比起单纯的单链表，跳表需要存储多级索引，肯定要消耗更多的存储空间。现在我们来分析下，假设原始链表大小为 n，那第一级索引大约有 n/2 个结点，第二级索引大约有 n/4 个结点，以此类推，每上升一级就减少一半，直到剩下 2 个结点。如果我们把每层索引的结点数写出来，就是一个等比数列。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/17跳表：为什么Redis一定要用跳表来实现有序集合？/跳表5.png" alt></p>
<p>这几级索引的结点总和就是 n/2+n/4+n/8…+8+4+2=n-2。所以，跳表的空间复杂度是 O(n)。也就是说，如果将包含 n 个结点的单链表构造成跳表，我们需要额外再用接近 n 个结点的存储空间。事实上我们还可以减少复杂度。我们前面都是每两个结点抽一个结点到上级索引，如果我们每三个结点或五个结点，抽一个结点到上级索引，那结果如何呢？<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/17跳表：为什么Redis一定要用跳表来实现有序集合？/跳表6.png" alt><br>从图中可以看出，第一级索引需要大约 n/3 个结点，第二级索引需要大约 n/9 个结点。每往上一级，索引结点个数都除以 3。通过等比数列求和公式，<strong>总的索引结点大约就是 n/3+n/9+n/27+…+9+3+1=n/2。尽管空间复杂度还是 O(n)，但比上面的每两个结点抽一个结点的索引构建方法，要减少了一半的索引结点存储空间。</strong></p>
<p>实际上，在软件开发中，我们不必太在意索引占用的额外空间。在讲数据结构和算法时，我们习惯性地把要处理的数据看成整数，但是在实际的软件开发中，原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，所以当对象比索引结点大很多时，那索引占用的额外空间就可以忽略了。</p>
<h3 id="跳表的插入和删除"><a href="#跳表的插入和删除" class="headerlink" title="跳表的插入和删除"></a>跳表的插入和删除</h3><p>跳表这个动态数据结构，不仅支持查找操作，还支持动态的插入、删除操作，而且插入、删除操作的时间复杂度也是 O(logn)。我们现在来看下， 如何在跳表中插入一个数据，以及它是如何做到 O(logn) 的时间复杂度的？我们知道，<strong>在单链表中，一旦定位好要插入的位置，插入结点的时间复杂度是很低的，就是 O(1)</strong>。但是，这里为了保证原始链表中数据的有序性，我们需要先找到要插入的位置，这个查找操作就会比较耗时。</p>
<p>对于纯粹的单链表，需要遍历每个结点，来找到插入的位置。但是，对于跳表来说，我们讲过查找某个结点的的时间复杂度是 O(logn)，所以这里查找某个数据应该插入的位置，方法也是类似的，时间复杂度也是 O(logn)。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/17跳表：为什么Redis一定要用跳表来实现有序集合？/跳表7.png" alt></p>
<p>我们再来看删除操作。如果这个结点在索引中也有出现，<strong>我们除了要删除原始链表中的结点，还要删除索引中的</strong>。因为单链表中的删除操作需要拿到要删除结点的前驱结点，然后通过指针操作完成删除。所以在查找要删除的结点的时候，一定要获取前驱结点。当然，如果我们用的是双向链表，就不需要考虑这个问题了。</p>
<h3 id="跳表索引动态更新"><a href="#跳表索引动态更新" class="headerlink" title="跳表索引动态更新"></a>跳表索引动态更新</h3><p>当我们不停地往跳表中插入数据时，如果我们不更新索引，就有可能出现某 2 个索引结点之间数据非常多的情况。<strong>极端情况下，跳表还会退化成单链表</strong>。作为一种动态数据结构，我们需要某种手段来维护索引与原始链表大小之间的平衡，也就是说，如果链表中结点多了，索引结点就相应地增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/17跳表：为什么Redis一定要用跳表来实现有序集合？/跳表8.png" alt></p>
<p>如果你了解红黑树、AVL 树这样平衡二叉树，你就知道它们是通过<strong>左右旋的方式保持左右子树的大小平衡</strong>，而跳表是通过<strong>随机函数来维护前面提到的“平衡性”</strong>。当我们往跳表中插入数据的时候，我们可以选择同时将这个数据插入到部分索引层中。如何选择加入哪些索引层呢？我们通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那我们就将这个结点添加到第一级到第 K 级这 K 级索引中。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/17跳表：为什么Redis一定要用跳表来实现有序集合？/跳表9.png" alt></p>
<p>随机函数的选择很有讲究，从概率上来讲，能够保证跳表的索引大小和数据大小平衡性，不至于性能过度退化。至于随机函数的选择，我就不展开讲解了。如果你感兴趣的话，可以看看作者在 GitHub上的代码或者 Redis 中关于有序集合的跳表实现。跳表的实现还是稍微有点复杂的，你不用死记硬背代码，跳表的实现并不是重点。</p>
<h3 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h3><p>为什么 Redis 要用跳表来实现有序集合，而不是红黑树？</p>
<p>解答：<br>Redis 中的有序集合是通过跳表来实现的，严格点讲，其实还用到了散列表。不过散列表的知识点还没学到，所以我们现在暂且忽略这部分。如果你去查看 Redis 的开发手册，就会发现，Redis 中的有序集合支持的核心操作主要有下面这几个：</p>
<ul>
<li>插入一个数据；</li>
<li>删除一个数据；</li>
<li>查找一个数据；</li>
<li>按照区间查找数据（比如查找值在 [100, 356] 之间的数据）；</li>
<li>迭代输出有序序列</li>
</ul>
<p>其中，插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度跟跳表是一样的。但是，按照区间来查找数据这个操作，<strong>红黑树的效率没有跳表高</strong>。对于按照区间查找数据这个操作，跳表可以做到 O(logn) 的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了。这样做非常高效。</p>
<p>当然，Redis 之所以用跳表来实现有序集合，还有其他原因，比如，跳表更容易代码实现。虽然跳表的实现也不简单，但比起红黑树来说还是好懂、好写多了，而简单就意味着可读性好，不容易出错。还有，跳表更加灵活，它可以通过改变索引构建策略，有效平衡执行效率和内存消耗。</p>
<p>不过，跳表也不能完全替代红黑树。因为红黑树比跳表的出现要早一些，很多编程语言中的 Map 类型都是通过红黑树来实现的。我们做业务开发的时候，直接拿来用就可以了，不用费劲自己去实现一个红黑树，但是跳表并没有一个现成的实现，所以在开发中，如果你想使用跳表，必须要自己实现。</p>
<h3 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h3><p><strong>跳表使用空间换时间的设计思路，通过构建多级索引来提高查询的效率，实现了基于链表的“二分查找”。跳表是一种动态数据结构，支持快速的插入、删除、查找操作，时间复杂度都是 O(logn)。</strong>。跳表的空间复杂度是 O(n)。不过，跳表的实现非常灵活，可以通过改变索引构建策略，有效平衡执行效率和内存消耗。虽然跳表的代码实现并不简单，但是作为一种动态数据结构，比起红黑树来说，实现要简单多了。所以很多时候，我们为了代码的简单、易读，比起红黑树，我们更倾向用跳表。</p>
<h3 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h3><p>对于跳表的时间复杂度分析，我分析了每两个结点提取一个结点作为索引的时间复杂度。如果每三个或者五个结点提取一个结点作为上级索引，对应的在跳表中查询数据的时间复杂度是多少呢？</p>
<p>解答：</p>
<blockquote>
<p>如果每三个或者五个节点提取一个节点作为上级索引，那么对应的查询数据时间复杂度，应该也还是 O(logn)。假设每 5 个节点提取，那么最高一层有 5 个节点，而跳表高度为 log5n，每层最多需要查找 5 个节点，即 O(mlogn) 中的 m = 5，最终，时间复杂度为 O(logn)。空间复杂度也还是 O(logn)，虽然省去了一部分索引节点，但是似乎意义不大。</p>
</blockquote>
]]></content>
      <categories>
        <category>DataStructureAndAlgorithm</category>
      </categories>
      <tags>
        <tag>Skip list</tag>
      </tags>
  </entry>
  <entry>
    <title>16二分查找（下）：如何快速定位IP对应的省份地址？</title>
    <url>/articles/dfe8efa5.html/</url>
    <content><![CDATA[<blockquote>
<p>声名：本文大部分内容出自于极客时间网站王争的专栏《数据结构与算法之美》，这里本人主要记录自己的学习过程，添加个人见解，并作为自己的学习笔记。如有侵权，立马删除。</p>
</blockquote>
<a id="more"></a>
<h3 id="问题导像"><a href="#问题导像" class="headerlink" title="问题导像"></a>问题导像</h3><p>通过 IP 地址来查找 IP 归属地的功能并不复杂，它是通过维护一个很大的 IP 地址库来实现的。地址库中包括 IP 地址范围和归属地的对应关系。当我们想要查询 202.102.133.13 这个 IP 地址的归属地时，我们就在地址库中搜索，发现这个 IP 地址落在[202.102.133.0, 202.102.133.255]这个地址范围内，那我们就可以将这个 IP 地址范围对应的归属地“山东东营市”显示给用户了。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[202.102.133.0, 202.102.133.255]  山东东营市 </span><br><span class="line">[202.102.135.0, 202.102.136.255]  山东烟台 </span><br><span class="line">[202.102.156.34, 202.102.157.255] 山东青岛 </span><br><span class="line">[202.102.48.0, 202.102.48.255] 江苏宿迁 </span><br><span class="line">[202.102.49.15, 202.102.51.251] 江苏泰州 </span><br><span class="line">[202.102.56.0, 202.102.56.255] 江苏连云港</span><br></pre></td></tr></table></figure><br>现在的问题是，在庞大的地址库中逐一比对 IP 地址所在的区间，是非常耗时的。假设我们有 12 万条这样的 IP 区间与归属地的对应关系，如何快速定位出一个 IP 地址的归属地呢？</p>
<h3 id="常见的二分查找变形问题"><a href="#常见的二分查找变形问题" class="headerlink" title="常见的二分查找变形问题"></a>常见的二分查找变形问题</h3><p>上一节讲的二分查找是最简单的一种情况，在不存在重复元素的有序数组中，查找值等于给定值的元素。最简单的二分查找代码写起来不难，但是，二分查找的变形问题就没那么好写了。二分查找有几个典型的变形问题<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/16二分查找（下）：如何快速定位IP对应的省份地址？/二分查找变形问题.png" alt></p>
<h4 id="变体一：查找第一个值等于给定值的元素"><a href="#变体一：查找第一个值等于给定值的元素" class="headerlink" title="变体一：查找第一个值等于给定值的元素"></a>变体一：查找第一个值等于给定值的元素</h4><p>上一节中的二分查找是最简单的一种，即有序数据集合中不存在重复的数据，我们在其中查找值等于某个给定值的数据。如果我们将这个问题稍微修改下，有序数据集合中存在重复的数据，我们希望找到第一个值等于给定值的数据。比如下面这样一个有序数组，其中，a[5]，a[6]，a[7]的值都等于 8，是重复的数据。我们希望查找第一个等于 8 的数据，也就是下标是 5 的元素。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/16二分查找（下）：如何快速定位IP对应的省份地址？/变体1.png" alt></p>
<p>如果我们用上一节课讲的二分查找的代码实现，首先拿 8 与区间的中间值 a[4]比较，8 比 6 大，于是在下标 5 到 9 之间继续查找。下标 5 和 9 的中间位置是下标 7，a[7]正好等于 8，所以代码就返回了。尽管 a[7]也等于 8，但它并不是我们想要找的第一个等于 8 的元素，因为第一个值等于 8 的元素是数组下标为 5 的元素。我们上一节讲的二分查找代码就无法处理这种情况了。所以，针对这个变形问题，我们可以稍微改造一下上一节的代码。</p>
<p>网上有很多关于变形二分查找的实现方法，有很多写得非常简洁，比如下面这个写法。但是，尽管简洁，理解起来却非常烧脑，也很容易写错。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &gt;= value) &#123;</span><br><span class="line">      high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (low &lt; n &amp;&amp; a[low]==value) <span class="keyword">return</span> low;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>还有另一种写法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &gt; value) &#123;</span><br><span class="line">      high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) &#123;</span><br><span class="line">      low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ((mid == <span class="number">0</span>) || (a[mid - <span class="number">1</span>] != value)) <span class="keyword">return</span> mid;</span><br><span class="line">      <span class="keyword">else</span> high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>解释一下这段代码。a[mid]跟要查找的 value 的大小关系有三种情况：大于、小于、等于。对于 a[mid]&gt;value 的情况，我们需要更新 high= mid-1；对于 a[mid]&lt; value 的情况，我们需要更新 low=mid+1。这两点都很好理解。那当 a[mid]=value 的时候应该如何处理呢？如果我们查找的是任意一个值等于给定值的元素，当 a[mid]等于要查找的值时，a[mid]就是我们要找的元素。但是，如果我们求解的是第一个值等于给定值的元素，当 a[mid]等于要查找的值时，我们就需要确认一下这个 a[mid]是不是第一个值等于给定值的元素。</p>
<p>我们重点看第 11 行代码。如果 mid 等于 0，那这个元素已经是数组的第一个元素，那它肯定是我们要找的；如果 mid 不等于 0，但 a[mid]的前一个元素 a[mid-1]不等于 value，那也说明 a[mid]就是我们要找的第一个值等于给定值的元素。如果经过检查之后发现 a[mid]前面的一个元素 a[mid-1]也等于 value，那说明此时的 a[mid]肯定不是我们要查找的第一个值等于给定值的元素。那我们就更新 high=mid-1，因为要找的元素肯定出现在[low, mid-1]之间。</p>
<h4 id="变体二：查找最后一个值等于给定值的元素"><a href="#变体二：查找最后一个值等于给定值的元素" class="headerlink" title="变体二：查找最后一个值等于给定值的元素"></a>变体二：查找最后一个值等于给定值的元素</h4><p>如果你掌握了前面的写法，那这个问题你应该很轻松就能解决。<br>解法一：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &gt;= value) &#123;</span><br><span class="line">      high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> &lt; high &amp;&amp; a[high]==value) <span class="keyword">return</span> high;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>解法二：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &gt; value) &#123;</span><br><span class="line">      high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) &#123;</span><br><span class="line">      low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ((mid == n-<span class="number">1</span>) || (a[mid + <span class="number">1</span>] != value)) <span class="keyword">return</span> mid;</span><br><span class="line">      <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们还是重点看第 11 行代码。如果 a[mid]这个元素已经是数组中的最后一个元素了，那它肯定是我们要找的；如果 a[mid]的后一个元素 a[mid+1]不等于 value，那也说明 a[mid]就是我们要找的最后一个值等于给定值的元素。如果我们经过检查之后，发现 a[mid]后面的一个元素 a[mid+1]也等于 value，那说明当前的这个 a[mid]并不是最后一个值等于给定值的元素。我们就更新 low=mid+1，因为要找的元素肯定出现在[mid+1, high]之间。</p>
<h4 id="变体三：查找第一个大于等于给定值的元素"><a href="#变体三：查找第一个大于等于给定值的元素" class="headerlink" title="变体三：查找第一个大于等于给定值的元素"></a>变体三：查找第一个大于等于给定值的元素</h4><p>现在我们再来看另外一类变形问题。在有序数组中，查找第一个大于等于给定值的元素。比如，数组中存储的这样一个序列：3，4，6，7，10。如果查找第一个大于等于 5 的元素，那就是 6。际上，实现的思路跟前面的那两种变形问题的实现思路类似，代码写起来甚至更简洁<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &gt;= value) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((mid == <span class="number">0</span>) || (a[mid - <span class="number">1</span>] &lt; value)) <span class="keyword">return</span> mid;</span><br><span class="line">      <span class="keyword">else</span> high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果 a[mid]小于要查找的值 value，那要查找的值肯定在[mid+1, high]之间，所以，我们更新 low=mid+1。对于 a[mid]大于等于给定值 value 的情况，我们要先看下这个 a[mid]是不是我们要找的第一个值大于等于给定值的元素。如果 a[mid]前面已经没有元素，或者前面一个元素小于要查找的值 value，那 a[mid]就是我们要找的元素。这段逻辑对应的代码是第 7 行。如果 a[mid-1]也大于等于要查找的值 value，那说明要查找的元素在[low, mid-1]之间，所以，我们将 high 更新为 mid-1。</p>
<h4 id="变体四：查找最后一个小于等于给定值的元素"><a href="#变体四：查找最后一个小于等于给定值的元素" class="headerlink" title="变体四：查找最后一个小于等于给定值的元素"></a>变体四：查找最后一个小于等于给定值的元素</h4><p>查找最后一个小于等于给定值的元素。比如，数组中存储了这样一组数据：3，5，6，8，9，10。最后一个小于等于 7 的元素就是 6。思路和上面的一样<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch7</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &gt; value) &#123;</span><br><span class="line">      high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ((mid == n - <span class="number">1</span>) || (a[mid + <span class="number">1</span>] &gt; value)) <span class="keyword">return</span> mid;</span><br><span class="line">      <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h3><p>假设我们有 12 万条这样的 IP 区间与归属地的对应关系，如何快速定位出一个 IP 地址的归属地呢？</p>
<p>解答：<br>如果 IP 区间与归属地的对应关系不经常更新，我们可以先预处理这 12 万条数据，让其按照起始 IP 从小到大排序。如何来排序呢？我们知道，IP 地址可以转化为 32 位的整型数。所以，我们可以将起始地址，按照对应的整型值的大小关系，从小到大进行排序。然后，这个问题就可以转化为第四种变形问题“在有序数组中，查找最后一个小于等于某个给定值的元素”了。</p>
<p>当我们要查询某个 IP 归属地时，我们可以先通过二分查找，找到最后一个起始 IP 小于等于这个 IP 的 IP 区间，然后，检查这个 IP 是否在这个 IP 区间内，如果在，我们就取出对应的归属地显示；如果不在，就返回未查找到。</p>
<h3 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h3><p>上一节说过，凡是用二分查找能解决的，绝大部分我们更倾向于用散列表或者二叉查找树。即便是二分查找在内存使用上更节省，但是毕竟内存如此紧缺的情况并不多。实际上，上一节讲的求“值等于给定值”的二分查找确实不怎么会被用到，二分查找更适合用在 <strong>“近似”查找</strong>问题，在这类问题上，二分查找的优势更加明显。比如今天讲的这几种变体问题，用其他数据结构，比如散列表、二叉树，就比较难实现了。</p>
<p>变体的二分查找算法写起来非常烧脑，很容易因为细节处理不好而产生 Bug，这些容易出错的细节有：终止条件、区间上下界更新方法、返回值选择。所以今天的内容最好能自己实现一遍，对锻炼编码能力、逻辑思维、写出 Bug free 代码，会很有帮助。</p>
]]></content>
      <categories>
        <category>DataStructureAndAlgorithm</category>
      </categories>
      <tags>
        <tag>Search</tag>
      </tags>
  </entry>
  <entry>
    <title>18散列表（上）：Word文档中的单词拼写检查功能是如何实现的？</title>
    <url>/articles/843d5034.html/</url>
    <content><![CDATA[<blockquote>
<p>声名：本文大部分内容出自于极客时间网站王争的专栏《数据结构与算法之美》，这里本人主要记录自己的学习过程，添加个人见解，并作为自己的学习笔记。如有侵权，立马删除。</p>
</blockquote>
<a id="more"></a>
<h3 id="问题导向"><a href="#问题导向" class="headerlink" title="问题导向"></a>问题导向</h3><p>不知你有没有发现我们在写word文档的时候,如果输入的时候输入了一个错误的英文单词，那它则会在该单词下用红色的波浪线提示“拼写错误”。<strong>Word 的这个单词拼写检查功能，虽然很小但却非常实用。你有没有想过，这个功能是如何实现的呢？</strong>这里涉及就涉及到了<strong>散列表(Hash Table</strong>这个数据结构。</p>
<h3 id="散列思想"><a href="#散列思想" class="headerlink" title="散列思想"></a>散列思想</h3><p>散列表的英文叫“Hash Table”，我们平时也叫它“哈希表”或者“Hash 表”。<strong>散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。</strong>，用一个例子来解释一下。假如我们有 89 名选手参加学校运动会。为了方便记录成绩，每个选手胸前都会贴上自己的参赛号码。这 89 名选手的编号依次是 1 到 89。现在我们希望编程实现这样一个功能，通过编号快速找到对应的选手信息。我们可以把这 89 名选手的信息放在数组里。编号为 1 的选手，我们放到数组中下标为 1 的位置；编号为 2 的选手，我们放到数组中下标为 2 的位置。以此类推，编号为 k 的选手放到数组中下标为 k 的位置。</p>
<p>因为参赛编号跟数组下标一一对应，当我们需要查询参赛编号为 x 的选手的时候，我们只需要将下标为 x 的数组元素取出来就可以了，时间复杂度就是 O(1)。这样<strong>按照编号查找选手信息</strong>，效率是不是很高？实际上，这个例子已经用到了散列的思想。在这个例子里，参赛编号是自然数，并且与数组的下标形成一一映射，所以利用<strong>数组支持根据下标随机访问</strong>的时候，时间复杂度是 O(1) 这一特性，就可以实现快速查找编号对应的选手信息。这样按照编号查找选手信息，效率就会很高。</p>
<p>将上个例子改造下，参赛编号不能设置得这么简单，要加上年级、班级这些更详细的信息，用 6 位数字来表示。比如 051167，其中，前两位 05 表示年级，中间两位 11 表示班级，最后两位还是原来的编号 1 到 89。这个时候我们该如何存储选手信息，才能够支持通过编号来快速查找选手信息呢？思路还是跟前面类似。尽管我们不能直接把编号作为数组下标，但我们可以截取参赛编号的后两位作为数组下标，来存取选手信息数据。当通过参赛编号查询选手信息的时候，我们用同样的方法，<strong>取参赛编号的后两位，作为数组下标</strong>，来读取数组中的数据。</p>
<p>这就是典型的散列思想。其中，参赛选手的编号我们叫作键（key）或者关键字。我们用它来标识一个选手。我们把参赛编号转化为数组下标的映射方法就叫作散列函数（或“Hash 函数”“哈希函数”），而散列函数计算得到的值就叫作散列值（或“Hash 值”“哈希值”）。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/18散列表（上）：Word文档中的单词拼写检查功能是如何实现的？/哈希值.png" alt></p>
<p>通过这个例子，我们可以总结出这样的规律：<strong>散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是 O(1) 的特性。我们通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据</strong>。</p>
<h3 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h3><p><strong>哈希函数也叫散列函数，它对不同的输出值得到一个固定长度的消息摘要</strong>。理想的哈希函数对于不同的输入应该产生不同的结构，同时散列结果应当具有同一性（输出值尽量均匀）和雪崩效应（微小的输入值变化使得输出值发生巨大的变化）。从上面的例子我们可以看到，散列函数在散列表中起着非常关键的作用。散列函数，顾名思义，它是一个函数。我们可以把它定义成 hash(key)，其中 key 表示元素的键值，hash(key) 的值表示经过散列函数计算得到的散列值。那第一个例子中，由于编号就是数组下标，他们是一一映射的，所以 这里hash(key) 就等于 key，也就是线性的映射，key和hash(key)是相等的。改造后的例子，写成散列函数稍微有点复杂。将它写成函数的伪代码就是下面这样：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int hash(String key) &#123;</span><br><span class="line">  &#x2F;&#x2F; 获取后两位字符</span><br><span class="line">  string lastTwoChars &#x3D; key.substr(length-2, length); &#x2F;&#x2F;substr(start,end)表示获取(end-start)位子字符串</span><br><span class="line">  &#x2F;&#x2F; 将后两位字符转换为整数</span><br><span class="line">  int hashValue &#x3D; convert lastTwoChas to int-type;</span><br><span class="line">  return hashValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>刚刚举的学校运动会的例子，散列函数比较简单，也比较容易想到。但是，如果参赛选手的编号是随机生成的 6 位数字，又或者用的是 a 到 z 之间的字符串，该如何构造散列函数呢？这里有三条散列函数设计的基本要求：<br>**1. 散列函数计算得到的散列值是一个非负整数；</p>
<ol>
<li>如果 key1 = key2，那 hash(key1) == hash(key2)；</li>
<li>如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)。**</li>
</ol>
<p>其中，第一点理解起来应该没有任何问题。因为数组下标是从 0 开始的，所以散列函数生成的散列值也要是非负整数。第二点也很好理解。相同的 key，经过散列函数得到的散列值也应该是相同的。第三点呢，这个要求看起来合情合理，但是在真实的情况下，要想找到一个不同的 key 对应的散列值都不一样的散列函数，几乎是不可能的。即便像业界著名的<a href="https://zh.wikipedia.org/wiki/MD5" target="_blank" rel="noopener">MD5</a>、<a href="https://zh.wikipedia.org/wiki/SHA%E5%AE%B6%E6%97%8F" target="_blank" rel="noopener">SHA</a>、<a href="https://zh.wikipedia.org/wiki/%E5%BE%AA%E7%92%B0%E5%86%97%E9%A4%98%E6%A0%A1%E9%A9%97" target="_blank" rel="noopener">CRC</a>等哈希算法，也无法完全避免这种散列冲突。而且，因为数组的存储空间有限，也会加大散列冲突的概率。</p>
<p><strong>散列冲突</strong>:现实中的哈希函数不是完美的，当两个不同的输入值对应一个输出值时，就会产生“碰撞”，这个时候便需要解决冲突。常见的冲突解决方法有<strong>开放寻址法(open addressing)</strong>，<strong>链表法(chaining)</strong>，<strong>建立公共溢出区</strong>等。实际的哈希表实现中，使用最多的是链地址法</p>
<p>以我们几乎无法找到一个完美的无冲突的散列函数，即便能找到，付出的时间成本、计算成本也是很大的，所以针对散列冲突问题，我们需要通过其他途径来解决。</p>
<h4 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h4><p>开放寻址法的核心思想是，如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。先说一个比较简单的探测方法，<strong>线性探测（Linear Probing）</strong>。当我们往散列表中插入数，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。这里以图表的形式举例，这里面黄色的色块表示空闲位置，橙色的色块表示已经存储了数据。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/18散列表（上）：Word文档中的单词拼写检查功能是如何实现的？/线性探测.png" alt><br>从图中可以看出，散列表的大小为 10，在元素 x 插入散列表之前，已经 6 个元素插入到散列表中。x 经过 Hash 算法之后，被散列到位置下标为 7 的位置，但是这个位置已经有数据了，所以就产生了冲突。于是我们就顺序地往后一个一个找，看有没有空闲的位置，遍历到尾部都没有找到空闲的位置，于是我们再从表头开始找，直到找到空闲位置 2，于是将其插入到这个位置。</p>
<blockquote>
<p>动画演示<img src="http://cdn.wangng.com/DataStructureAndAlgorithm/18散列表（上）：Word文档中的单词拼写检查功能是如何实现的？/线性探测.gif" alt></p>
</blockquote>
<p>在散列表中查找元素的过程有点儿类似<strong>插入过程</strong>。我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是我们要找的元素；否则就顺序往后依次查找。如果遍历到数组中的空闲位置，还没有找到，就说明要查找的元素并没有在散列表中。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/18散列表（上）：Word文档中的单词拼写检查功能是如何实现的？/查找.png" alt></p>
<p>散列表跟数组一样，不仅支持插入、查找操作，还支持<strong>删除操作</strong>。对于使用线性探测法解决冲突的散列表，删除操作稍微有些特别。我们不能单纯地把要删除的元素设置为空。这是因为在查找的时候，一旦我们通过线性探测方法，找到一个空闲位置，我们就可以认定散列表中不存在这个数据。但是，如果这个空闲位置是我们后来删除的，就会导致原来的查找算法失效。本来存在的数据，会被认定为不存在。对于这个问题的解决方法是我们可以将删除的元素，特殊标记为 deleted。当线性探测查找的时候，遇到标记为 deleted 的空间，并不是停下来，而是继续往下探测。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/18散列表（上）：Word文档中的单词拼写检查功能是如何实现的？/删除.png" alt><br>你可能已经发现了，线性探测法其实存在很大问题。当散列表中插入的数据越来越多时，散列冲突发生的可能性就会越来越大，空闲位置会越来越少，线性探测的时间就会越来越久。极端情况下，我们可能需要探测整个散列表，所以最坏情况下的时间复杂度为 O(n)。同理，在删除和查找时，也有可能会线性探测整张散列表，才能找到要查找或者删除的数据。对于开放寻址冲突解决方法，除了线性探测方法之外，还有另外两种比较经典的探测方法，<strong>二次探测（Quadratic probing）</strong>和<strong>双重散列（Double hashing）</strong>。</p>
<p>所谓二次探测，跟线性探测很像，线性探测每次探测的步长是 1，那它探测的下标序列就是 hash(key)+0，hash(key)+1，hash(key)+2……而二次探测探测的步长就变成了原来的“二次方”，也就是说，它探测的下标序列就是hash(key)+0,hash(key)+$1^2$,hash(key)+$2^2$,……<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/18散列表（上）：Word文档中的单词拼写检查功能是如何实现的？/二次探测法.gif" alt></p>
<p>所谓双重散列，意思就是不仅要使用一个散列函数。我们使用一组散列函数 hash1(key)，hash2(key)，hash3(key)……我们先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/18散列表（上）：Word文档中的单词拼写检查功能是如何实现的？/双重散列法.gif" alt></p>
<p>不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，我们会尽可能保证散列表中有一定比例的空闲槽位。我们用<strong>装载因子（load factor）</strong>来表示空位的多少。装载因子的计算公式是：</p>
<blockquote>
<p>散列表的装载因子=填入表中的元素个数/散列表的长度</p>
</blockquote>
<p>装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。</p>
<h4 id="链表法"><a href="#链表法" class="headerlink" title="链表法"></a>链表法</h4><p>链表法是一种更加常用的散列冲突解决办法，相比开放寻址法，它要简单很多。我们来看这个图，在散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。通俗讲就是<font color="red" size="3">根据元素的一些特征把元素分配到不同的链表中去，也是根据这些特征，找到正确的链表，再从链表中找出这个元素。</font><br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/18散列表（上）：Word文档中的单词拼写检查功能是如何实现的？/链表法.png" alt></p>
<blockquote>
<p>动画演示<img src="http://cdn.wangng.com/DataStructureAndAlgorithm/18散列表（上）：Word文档中的单词拼写检查功能是如何实现的？/链表法.gif" alt></p>
</blockquote>
<p>当插入的时候，我们只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，所以插入的时间复杂度是 O(1)。当查找、删除一个元素时，我们同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除。那查找或删除操作的时间复杂度是多少呢？实际上，这两个操作的时间复杂度跟链表的长度 k 成正比，也就是 O(k)。对于散列比较均匀的散列函数来说，理论上讲，k=n/m，其中 n 表示散列中数据的个数，m 表示散列表中“槽”的个数。</p>
<h3 id="常用的散列函数"><a href="#常用的散列函数" class="headerlink" title="常用的散列函数"></a>常用的散列函数</h3><h3 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h3><p>Word 文档中单词拼写检查功能是如何实现的？<br>解答：<br>常用的英文单词有20万个左右，假设单词的平均长度是10个字母，平均一个单词占用 10 个字节的内存空间，那 20 万英文单词大约占 2MB 的存储空间，就算放大 10 倍也就是 20MB。对于现在的计算机来说，这个大小完全可以放在内存里面。所以我们可以用散列表来存储整个英文单词词典。当用户输入某个英文单词时，我们拿用户输入的单词去散列表中查找。如果查到，则说明拼写正确；如果没有查到，则说明拼写可能有误，给予提示。借助散列表这种数据结构，我们就可以轻松实现快速判断是否存在拼写错误。</p>
<h3 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h3><p>散列表（Hash Table，也叫哈希表），是根据关键码值（key value）而进行直接访问的数据结构。它通过关键码值映射到表中的一个位置来访问记录，以加快访问的速度。这个映射函数叫做散列函数，存放的数组叫做散列表。散列表来源于数组，它借助散列函数对数组这种数据结构进行扩展，利用的是数组支持按照下标随机访问元素的特性。散列表两个核心问题是<strong>散列函数设计</strong>和<strong>散列冲突解决</strong>。散列冲突有两种常用的解决方法，开放寻址法和链表法。散列函数设计的好坏决定了散列冲突的概率，也就决定散列表的性能。</p>
<h3 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h3><p>1.假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？<br>2.有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？</p>
<p>解答：</p>
<blockquote>
<p>1.遍历 10 万条数据，以 URL 为 key，访问次数为 value，存入散列表，同时记录下访问次数的最大值 K，时间复杂度 O(N)。如果 K 不是很大，可以使用桶排序，时间复杂度 O(N)。如果 K 非常大（比如大于 10 万），就使用快速排序，复杂度 O(NlogN)。</p>
<p>2.以第一个字符串数组构建散列表，key 为字符串，value 为出现次数。再遍历第二个字符串数组，以字符串为 key 在散列表中查找，如果 value 大于零，说明存在相同字符串。时间复杂度 O(N)。</p>
</blockquote>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://hit-alibaba.github.io/interview/basic/algo/Hash-Table.html" target="_blank" rel="noopener">哈希表· 笔试面试知识整理</a><br><a href="https://juejin.im/post/5c32a4c2f265da611b58823a" target="_blank" rel="noopener">动画：什么是散列表？</a><br><a href="https://blog.csdn.net/bin_ge_love/article/details/51620459" target="_blank" rel="noopener">哈希表的插入、查找、删除</a></p>
]]></content>
      <categories>
        <category>DataStructureAndAlgorithm</category>
      </categories>
      <tags>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title>19散列表（中）：如何打造一个工业级水平的散列表？</title>
    <url>/articles/5972b21f.html/</url>
    <content><![CDATA[<blockquote>
<p>声名：本文大部分内容出自于极客时间网站王争的专栏《数据结构与算法之美》，这里本人主要记录自己的学习过程，添加个人见解，并作为自己的学习笔记。如有侵权，立马删除。</p>
</blockquote>
<a id="more"></a>
<h3 id="问题导向"><a href="#问题导向" class="headerlink" title="问题导向"></a>问题导向</h3><p>事实上,<strong>散列表的查询效率并不能笼统地说成是 O(1)。它跟散列函数、装载因子、散列冲突等都有关系</strong>。如果散列函数设计得不好，或者装载因子过高，都可能导致散列冲突发生的概率升高，查询效率下降。在极端情况下，有些恶意的攻击者，还有可能通过精心构造的数据，使得所有的数据经过散列函数之后，都散列到同一个槽里。如果我们使用的是基于链表的冲突解决方法，那这个时候，散列表就会退化为链表，查询的时间复杂度就从 O(1) 急剧退化为 O(n)。</p>
<p>如果散列表中有 10 万个数据，退化后的散列表查询的效率就下降了 10 万倍。更直接点说，如果之前运行 100 次查询只需要 0.1 秒，那现在就需要 1 万秒。这样就有可能因为查询操作消耗大量 CPU 或者线程资源，导致系统无法响应其他请求，从而达到拒绝服务攻击（DoS）的目的。这也就是散列表碰撞攻击的基本原理。那么该如何设计一个可以应对各种异常情况的工业级散列表，来避免在散列冲突的情况下，散列表性能的急剧下降，并且能抵抗散列碰撞攻击？</p>
<h3 id="散列函数的设计？"><a href="#散列函数的设计？" class="headerlink" title="散列函数的设计？"></a>散列函数的设计？</h3><p><strong>散列函数设计的好坏，决定了散列表冲突的概率大小，也直接决定了散列表的性能</strong>。散列函数的设计需要遵循以下几点：<br>1.<strong>散列函数的设计不能太复杂。过于复杂的散列函数</strong>，势必会消耗很多计算时间，也就间接的影响到散列表的性能。<br>2.<strong>散列函数生成的值要尽可能随机并且均匀分布</strong>，这样才能避免或者最小化散列冲突，而且即便出现冲突，散列到每个槽里的数据也会比较平均，不会出现某个槽内数据特别多的情况。</p>
<p>实际工作中，我们还需要综合考虑各种因素。这些因素有关键字的长度、特点、分布、还有散列表的大小等。散列函数各式各样，下面是几个常用的、简单的散列函数的设计方法。<br>第一个例子就是我们18节中的学生运动会的例子，我们通过分析参赛编号的特征，把编号中的后两位作为散列值。我们还可以用类似的散列函数处理手机号码，因为手机号码前几位重复的可能性很大，但是后面几位就比较随机，我们可以取手机号的后四位作为散列值。这种散列函数的设计方法，我们一般叫作“<strong>数据分析法</strong>”。</p>
<p>第二个例子就是18节中的的开篇思考题，如何实现 Word 拼写检查功能。这里面的散列函数，我们就可以这样设计：将单词中每个字母的<a href="http://www.96yx.com/tool/ASC2.htm" target="_blank" rel="noopener">ASCll 码值</a>“进位”相加，然后再跟散列表的大小求余、取模，作为散列值。比如，英文单词 nice，我们转化出来的散列值就是下面这样：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hash(&quot;nice&quot;)&#x3D;((&quot;n&quot; - &quot;a&quot;) * 26*26*26 + (&quot;i&quot; - &quot;a&quot;)*26*26 + (&quot;c&quot; - &quot;a&quot;)*26+ (&quot;e&quot;-&quot;a&quot;)) &#x2F; 78978</span><br></pre></td></tr></table></figure><br>实际上，散列函数的设计方法还有很多，比如直接寻址法、平方取中法、折叠法、随机数法等。</p>
<h3 id="装载因子过大了怎么办？"><a href="#装载因子过大了怎么办？" class="headerlink" title="装载因子过大了怎么办？"></a>装载因子过大了怎么办？</h3><p><strong>装载因子越大，说明散列表中的元素越多，空闲位置越少，散列冲突的概率就越大</strong>。不仅插入数据的过程要多次寻址或者拉很长的链，查找的过程也会因此变得很慢。对于没有频繁插入和删除的静态数据集合来说，我们很容易根据数据的特点、分布等，设计出完美的、极少冲突的散列函数，因为毕竟之前数据都是已知的。对于动态散列表来说，数据集合是频繁变动的，我们事先无法预估将要加入的数据个数，所以我们也无法事先申请一个足够大的散列表。随着数据慢慢加入，装载因子就会慢慢变大。当装载因子大到一定程度之后，散列冲突就会变得不可接受。这个时候，我们该如何处理呢？</p>
<p>针对散列表，<strong>当装载因子过大时，我们也可以进行动态扩容</strong>，重新申请一个更大的散列表，将数据搬移到这个新散列表中。假设每次扩容我们都申请一个原来散列表大小两倍的空间。如果原来散列表的装载因子是 0.8，那经过扩容之后，新散列表的装载因子就下降为原来的一半，变成了 0.4。针对数组的扩容，数据搬移操作比较简单。但是，针对散列表的扩容，数据搬移操作要复杂很多。因为散列表的大小变了，数据的存储位置也变了，所以我们需要通过散列函数重新计算每个数据的存储位置。如图所示，在原来的散列表中，21 这个元素原来存储在下标为 0 的位置，搬移到新的散列表中，存储在下标为 7 的位置。</p>
<p><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/19散列表（中）：如何打造一个工业级水平的散列表？/数据搬移.png" alt></p>
<p>插入一个数据，最好情况下，不需要动态扩容，最好的时间复杂度是O(1)；最坏情况下，散列表装载因子过高，启动扩容，需要重新申请内存空间，重新计算哈希位置，并且搬移数据，所以时间复杂度是O(n)。使用摊还分析法，均摊情况下，时间复杂度接近最好情况，就是O(1)。</p>
<p>插入一个数据，最好情况下，不需要动态扩容，<strong>最好的时间复杂度是O(1)</strong>；最坏情况下，散列表装载因子过高，启动扩容，需要重新申请内存空间，重新计算哈希位置，并且搬移数据，所以<strong>最坏时间复杂度是O(n)</strong>。使用摊还分析法，<strong>均摊情况下，时间复杂度接近最好情况，就是O(1)</strong>。实际上，对于动态散列表，随着数据的删除，散列表中的数据会越来越少，空闲空间会越来越多。如果我们对空间消耗非常敏感，我们可以在装载因子小于某个值之后，启动动态缩容。当然，如果我们更加在意执行效率，能够容忍多消耗一点内存空间，那就可以不用费劲来缩容了。</p>
<p>我们前面讲到，当散列表的装载因子超过某个阈值时，就需要进行扩容。装载因子阈值需要选择得当。如果太大，会导致冲突过多；如果太小，会导致内存浪费严重。<strong>装载因子阈值的设置要权衡时间、空间复杂度</strong>。如果内存空间不紧张，对执行效率要求很高，可以降低负载因子的阈值；相反，如果内存空间紧张，对执行效率要求又不高，可以增加负载因子的值，甚至可以大于 1。</p>
<h3 id="如何避免低效地扩容？"><a href="#如何避免低效地扩容？" class="headerlink" title="如何避免低效地扩容？"></a>如何避免低效地扩容？</h3><p>大部分情况下，动态扩容的散列表插入一个数据都很快，但是在特殊情况下，当装载因子已经到达阈值，需要先进行扩容，再插入数据。这个时候，插入数据就会变得很慢，甚至会无法接受。极端时散列表当前大小为 1GB，要想扩容为原来的两倍大小，那就需要对 1GB 的数据重新计算哈希值，并且从原来的散列表搬移到新的散列表，这就非常耗时了。</p>
<p>为了解决一次性扩容耗时过多的情况，我们可以将<strong>扩容操作穿插在插入操作</strong>的过程中，分批完成。当装载因子触达阈值之后，我们只申请新空间，但并不将老的数据搬移到新散列表中。当有新数据要插入时，我们将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。每次插入一个数据到散列表，我们都重复上面的过程。经过多次插入操作之后，老的散列表中的数据就一点一点全部搬移到新散列表中了。这样没有了集中的一次性数据搬移，插入操作就都变得很快了。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/19散列表（中）：如何打造一个工业级水平的散列表？/扩容.png" alt><br><strong>对于查询操作，先从新散列表中查找，如果没有找到，再去老的散列表查找</strong>。通过这样均摊的方法，将一次性扩容的代价，均摊到多次插入操作中，就避免了一次性扩容耗时过多的情况。这种实现方式，<strong>任何情况下，插入一个数据的时间复杂度都是 O(1)</strong>。</p>
<h3 id="如何选择冲突解决方法？"><a href="#如何选择冲突解决方法？" class="headerlink" title="如何选择冲突解决方法？"></a>如何选择冲突解决方法？</h3><p>我们学习了两种主要的解决散列冲突的办法，开放寻址法和链表法。这两种冲突解决办法在实际的软件开发中都非常常用。比如，Java 中 LinkedHashMap 就采用了链表法解决冲突，ThreadLocalMap 是通过线性探测的开放寻址法来解决冲突。我们来对比下这两种冲突解决方法各有什么优势和劣势，又各自适用哪些场景吗。</p>
<h4 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h4><p><strong>优点</strong>：开放寻址法不像链表法，需要拉很多链表。散列表中的数据都存储在数组中，可以有效地利用 CPU 缓存加快查询速度。而且，这种方法实现的散列表，序列化起来比较简单。链表法包含指针，序列化起来就没那么容易。你可不要小看序列化，很多场合都会用到的。我们后面会学习到什么是数据结构序列化、如何序列化，以及为什么要序列化。</p>
<p><strong>缺点</strong>：用开放寻址法解决冲突的散列表，删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据。而且，在开放寻址法中，所有的数据都存储在一个数组中，比起链表法来说，冲突的代价更高。所以，使用开放寻址法解决冲突的散列表，装载因子的上限不能太大。这也导致这种方法比链表法更浪费内存空间。</p>
<p><strong>总结一下，当数据量比较小、装载因子小的时候，适合采用开放寻址法。这也是 Java 中的ThreadLocalMap使用开放寻址法解决散列冲突的原因。</strong></p>
<h4 id="链表法"><a href="#链表法" class="headerlink" title="链表法"></a>链表法</h4><p><strong>优点</strong>：<br>1.<strong>链表法对内存的利用率比开放寻址法要高</strong>。因为链表结点可以在需要的时候再创建，并不需要像开放寻址法那样事先申请好(数组大小需预先设定)。实际上，这一点也是我们前面讲过的链表优于数组的地方。<br>2.<strong>链表法比起开放寻址法，对大装载因子的容忍度更高</strong>。开放寻址法只能适用装载因子小于 1 的情况。接近 1 时，就可能会有大量的散列冲突，导致大量的探测、再散列等，性能会下降很多。但是对于链表法来说，只要散列函数的值随机均匀，即便装载因子变成 10，也就是链表的长度变长了而已，虽然查找效率有所下降，但是比起顺序查找还是快很多。<br><strong>缺点</strong>：<br>链表因为要存储指针，所以对于比较小的对象的存储，是比较消耗内存的，还有可能会让内存的消耗翻倍。而且，因为链表中的结点是零散分布在内存中的，不是连续的，所以对 CPU 缓存是不友好的，这方面对于执行效率也有一定的影响。</p>
<p>当然，如果我们存储的是大对象，也就是说要存储的对象的大小远远大于一个指针的大小（4 个字节或者 8 个字节），那链表中指针的内存消耗在大对象面前就可以忽略了。实际上，我们对链表法稍加改造，可以实现一个更加高效的散列表。那就是，我们将链表法中的链表改造为其他高效的动态数据结构，比如跳表、红黑树。这样，即便出现散列冲突，极端情况下，所有的数据都散列到同一个桶内，那最终退化成的散列表的查找时间也只不过是 O(logn)。这样也就有效避免了前面讲到的散列碰撞攻击。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/19散列表（中）：如何打造一个工业级水平的散列表？/链表法.png" alt></p>
<p><strong>总结一下，基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。</strong></p>
<h3 id="工业级散列表举例分析"><a href="#工业级散列表举例分析" class="headerlink" title="工业级散列表举例分析"></a>工业级散列表举例分析</h3><p>我们拿Java中的HashMap这样一个工业级的散列表，来具体看下，这些技术是怎么应用的。</p>
<h4 id="初始大小"><a href="#初始大小" class="headerlink" title="初始大小"></a>初始大小</h4><p>HashMap 默认的初始大小是 16，当然这个默认值是可以设置的，如果事先知道大概的数据量有多大，可以通过修改默认初始大小，减少动态扩容的次数，这样会大大提高 HashMap 的性能。</p>
<h4 id="装载因子和动态扩容"><a href="#装载因子和动态扩容" class="headerlink" title="装载因子和动态扩容"></a>装载因子和动态扩容</h4><p>最大装载因子默认是 0.75，当 HashMap 中元素个数超过 0.75*capacity（capacity 表示散列表的容量）的时候，就会启动扩容，每次扩容都会扩容为原来的两倍大小。</p>
<h4 id="散列冲突解决方法"><a href="#散列冲突解决方法" class="headerlink" title="散列冲突解决方法"></a>散列冲突解决方法</h4><p>HashMap 底层采用链表法来解决冲突。即使负载因子和散列函数设计得再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响 HashMap 的性能。于是，在 JDK1.8 版本中，为了对 HashMap 做进一步优化，我们引入了红黑树。而当链表长度太长（默认超过 8）时，链表就转换为红黑树。我们可以利用红黑树快速增删改查的特点，提高 HashMap 的性能。当红黑树结点个数少于 8 个的时候，又会将红黑树转化为链表。因为在数据量较小的情况下，红黑树要维护平衡，比起链表来，性能上的优势并不明显。</p>
<h4 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h4><p>散列函数的设计并不复杂，追求的是简单高效、分布均匀。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = key.hashCode()；</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; (capicity -<span class="number">1</span>); <span class="comment">//capicity表示散列表的大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其中，hashCode() 返回的是 Java 对象的 hash code。比如 String 类型的对象的 hashCode() 就是下面这样：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> var1 = <span class="keyword">this</span>.hash;</span><br><span class="line">  <span class="keyword">if</span>(var1 == <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">char</span>[] var2 = <span class="keyword">this</span>.value;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> var3 = <span class="number">0</span>; var3 &lt; <span class="keyword">this</span>.value.length; ++var3) &#123;</span><br><span class="line">      var1 = <span class="number">31</span> * var1 + var2[var3];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.hash = var1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> var1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="散列函数的构造方法"><a href="#散列函数的构造方法" class="headerlink" title="散列函数的构造方法"></a>散列函数的构造方法</h3><h4 id="1-直接定址法"><a href="#1-直接定址法" class="headerlink" title="1.直接定址法"></a>1.直接定址法</h4><p>所谓直接定址法就是说，取关键字的某个线性函数值为散列地址，即<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f（key）&#x3D; a x key+b (a、b为常数)</span><br></pre></td></tr></table></figure><br>优点：简单、均匀，也不会产生冲突。<br>缺点：需要事先知道关键字的分布情况，适合查找表较小且连续的情况。<br>由于这样的限制，在现实应用中，此方法虽然简单，但却并不常用。</p>
<h4 id="2-数字分析法"><a href="#2-数字分析法" class="headerlink" title="2.数字分析法"></a>2.数字分析法</h4><p>如果关键字时位数较多的数字，比如11位的手机号”130<em>**</em>1234”，其中前三位是接入号；中间四位是HLR识别号，表示用户号的归属地；后四为才是真正的用户号。如下图所示。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/19散列表（中）：如何打造一个工业级水平的散列表？/数字分析法.png" alt><br>如果现在要存储某家公司的登记表，若用手机号作为关键字，极有可能前7位都是相同的，选择后四位成为散列地址就是不错的选择。若容易出现冲突，对抽取出来 的数字再进行反转、右环位移等。总的目的就是为了提供一个散列函数，能够合理地将关键字分配到散列表的各个位置。 数字分析法通过适合处理关键字位数比较大的情况，如果事先知道关键字的分布且关键字的若干位分布比较均匀，就可以考虑用这个方法。</p>
<h4 id="3-平方取中法"><a href="#3-平方取中法" class="headerlink" title="3.平方取中法"></a>3.平方取中法</h4><p>这个方法计算很简单，假设关键字是1234，那么它的平方就是1522756，再抽取中间的3位就是227，用做散列地址。平方取中法比较适合不知道关键字的分布，而位数又不是很大的情况。</p>
<h4 id="4-折叠法"><a href="#4-折叠法" class="headerlink" title="4.折叠法"></a>4.折叠法</h4><p>折叠法是将关键字从左到右分割成位数相等的几部分（注意最后一部分位数不够时可以短些），然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址。比如关键字是9876543210，散列表表长为三位，将它分为四组，987|654|321|0，然后将它们叠加求和987 + 654 + 321 + 0 = 1962，再求后3位得到散列地址962。折叠法事先不需要知道关键字的分布，适合关键字位数较多的情况。</p>
<h4 id="5-除留余数法"><a href="#5-除留余数法" class="headerlink" title="5.除留余数法"></a>5.除留余数法</h4><p><strong> 此方法为最常用的构造散列函数方法。对于散列表长为m的散列函数公式为：</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(key) &#x3D; key mode p (p&lt;&#x3D;m)</span><br></pre></td></tr></table></figure><br>mod是取模（求余数）的意思。事实上，这方法不仅可以对关键字直接取模，也可以再折叠、平方取中后再取模。很显然，本方法的关键在于选择合适的p，p如果选不好，就可能会容易产生冲突。根据前辈们的经验，若散列表的表长为m，通常p为小于或等于表长（最好接近m）的最小质数或不包含小于20质因子的合数。</p>
<h4 id="6-随机数法"><a href="#6-随机数法" class="headerlink" title="6.随机数法"></a>6.随机数法</h4><p>选择一个随机数，取关键字的随机函数值为它的散列地址。也就是f(key) = random(key)。这里random是随机函数。当关键字的长度不等时，采用这个方法构造散列函数是比较合适的。</p>
<p>总之，现实中，应该视不同的情况采用不同的散列函数，这里只能给出一些考虑的因素来提供参考：<br>（1）计算散列地址所需的时间<br>（2）关键字的长度；<br>（3）散列表的长度；<br>（4）关键字的分布情况；<br>（5）记录查找的频率。<br>综合以上等因素，才能决策选择哪种散列函数更合适。</p>
<h3 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h3><p>何为一个工业级的散列表？工业级的散列表应该具有哪些特性？<br>解答：工业级的散列表应该有这样几点要求：</p>
<ol>
<li>支持快速的查询、插入、删除操作；</li>
<li>内存占用合理，不能浪费过多的内存空间；</li>
<li>性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况。</li>
</ol>
<p>如何实现这样一个散列表呢？根据前面讲到的知识，需这三个方面来考虑设计思路：</p>
<ol>
<li><strong>设计一个合适的散列函数</strong>；</li>
<li><strong>定义装载因子阈值，并且设计动态扩容策略</strong></li>
<li><strong>选择合适的散列冲突解决方法</strong>。</li>
</ol>
<h3 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h3><p>学习了如何设计一个工业级的散列表，以及如何应对各种异常情况，防止在极端情况下，散列表的性能退化过于严重。主要时从这三个方面考虑,<strong>如何设计散列函数，如何根据装载因子动态扩容，以及如何选择散列冲突解决方法</strong>。</p>
<p>关于散列函数的设计，我们要<strong>尽可能让散列后的值随机且均匀分布</strong>，这样会尽可能地减少散列冲突，即便冲突之后，分配到每个槽内的数据也比较均匀。除此之外，<strong>散列函数的设计也不能太复杂</strong>，太复杂就会太耗时间，也会影响散列表的性能。</p>
<p>关于散列冲突解决方法的选择，对比了开放寻址法和链表法两种方法的优劣和适应的场景。<strong>大部分情况下，链表法更加普适</strong>。而且，我们还可以通过将链表法中的链表改造成其他动态查找数据结构，比如红黑树，来避免散列表时间复杂度退化成 O(n)，抵御散列碰撞攻击。但是，<strong>对于小规模数据、装载因子不高的散列表，比较适合用开放寻址法</strong>。</p>
<p>对于动态散列表来说，不管我们如何设计散列函数，选择什么样的散列冲突解决方法。随着数据的不断增加，散列表总会出现装载因子过高的情况。这个时候，我们就需要启动动态扩容。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://blog.chinaunix.net/uid-26548237-id-3480645.html" target="_blank" rel="noopener">数据结构之哈希表</a></p>
]]></content>
      <categories>
        <category>DataStructureAndAlgorithm</category>
      </categories>
      <tags>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title>20散列表（下）：为什么散列表和链表经常会一起使用？</title>
    <url>/articles/9c7f8db3.html/</url>
    <content><![CDATA[<blockquote>
<p>声名：本文大部分内容出自于极客时间网站王争的专栏《数据结构与算法之美》，这里本人主要记录自己的学习过程，添加个人见解，并作为自己的学习笔记。如有侵权，立马删除。</p>
</blockquote>
<a id="more"></a>
<h3 id="问题导向"><a href="#问题导向" class="headerlink" title="问题导向"></a>问题导向</h3><p>在前面的学习中，有两种数据结构，散列表和链表，这两种数据结构经常会被放在一起使用。在学习链表时，学习了如何用链表来实现 LRU 缓存淘汰算法，但是链表实现的 LRU 缓存淘汰算法的时间复杂度是 O(n)，后来我们知道<strong>通过散列表可以将这个时间复杂度降低到 O(1)</strong>。在学习跳表时，我们得出的结论时 <strong>Redis 的有序集合是使用跳表</strong>来实现的，跳表可以看作一种改进版的链表。当时我们也提到，Redis 有序集合不仅使用了跳表，还用到了散列表。除此之外，如果你熟悉 Java 编程语言，你会发现 LinkedHashMap 这样一个常用的容器，也用到了散列表和链表两种数据结构。</p>
<p>所以在这几个问题中，我们想知道散列表和链表都是如何组合起来使用的，以及为什么散列表和链表会经常放到一块使用。</p>
<h3 id="LRU-缓存淘汰算法"><a href="#LRU-缓存淘汰算法" class="headerlink" title="LRU 缓存淘汰算法"></a>LRU 缓存淘汰算法</h3><p>在学习链表时我们提到，借助散列表，我们可以把 LRU 缓存淘汰算法的时间复杂度降低为 O(1)。现在，我们就来看看它是如何做到的。首先，我们来回顾一下当时我们是如何通过链表实现 LRU 缓存淘汰算法的。</p>
<p>我们需要维护一个按照访问时间从大到小有序排列的链表结构。因为缓存大小有限，当缓存空间不够，需要淘汰一个数据的时候，我们就直接将链表头部的结点删除。当要缓存某个数据的时候，先在链表中查找这个数据。如果没有找到，则直接将数据放到链表的尾部；如果找到了，我们就把它移动到链表的尾部。因为查找数据需要遍历链表，所以单纯用链表实现的 LRU 缓存淘汰算法的时间复杂很高，是 O(n)。实际上，一个缓存（cache）系统主要包含下面这几个操作：</p>
<ul>
<li>往缓存中添加一个数据；</li>
<li>从缓存中删除一个数据；</li>
<li>在缓存中查找一个数据。</li>
</ul>
<p>这三个操作都要涉及“查找”操作，如果单纯地采用链表的话，时间复杂度只能是 O(n)。如果我们将散列表和链表两种数据结构组合使用，可以将这三个操作的时间复杂度都降低到 O(1)。具体的结构就是下面这个样子：<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/20散列表（下）：为什么散列表和链表经常会一起使用？/散列表和链表.png" alt></p>
<p>我们使用双向链表存储数据，链表中的每个结点处理存储数据（data）、前驱指针（prev）、后继指针（next）之外，还新增了一个特殊的字段 hnext。我们的散列表是通过链表法解决散列冲突的，所以每个结点会在两条链中。一个链是刚刚我们提到的双向链表，另一个链是散列表中的拉链。<strong>前驱和后继指针是为了将结点串在双向链表中，hnext 指针是为了将结点串在散列表的拉链中</strong>。</p>
<p>解了这个散列表和双向链表的组合存储结构之后，我们再来看，前面讲到的缓存的三个操作，是如何做到时间复杂度是 O(1) 的？</p>
<p><strong>如何查找一个数据</strong> ，我们前面讲过，散列表中查找数据的时间复杂度<strong>接近 O(1)</strong>，所以通过散列表，我们可以很快地在缓存中找到一个数据。当找到数据之后，我们还需要将它移动到双向链表的尾部。(ps这里查找的时间复杂度接近O(1),由于数据被均匀分到不同的“桶中”,每个桶的数据查找复杂度是接近O(1)的。同理下面的O(1)复杂度均以桶标准来度量。)<br><strong>如何删除一个数据</strong>，我们需要找到数据所在的结点，然后将结点删除。借助散列表，我们可以在 O(1) 时间复杂度里找到要删除的结点。因为我们的链表是双向链表，双向链表可以通过前驱指针 O(1) 时间复杂度获取前驱结点，所以在双向链表中，删除结点只需要 O(1) 的时间复杂度。<br><strong>如何添加一个数据</strong>，添加数据到缓存稍微有点麻烦，我们需要先看这个数据是否已经在缓存中。如果已经在其中，需要将其移动到双向链表的尾部；如果不在其中，还要看缓存有没有满。如果满了，则将双向链表头部的结点删除，然后再将数据放到链表的尾部；如果没有满，就直接将数据放到链表的尾部。</p>
<p>这整个过程涉及的<strong>查找操作都可以通过散列表</strong>来完成。其他的操作，比如<strong>删除头结点、链表尾部插入数据等，都可以在 O(1) 的时间复杂度</strong>内完成。所以，这三个操作的时间复杂度都是 O(1)。至此，我们就通过散列表和双向链表的组合使用，实现了一个高效的、支持 LRU 缓存淘汰算法的缓存系统原型。</p>
<h3 id="Redis-有序集合"><a href="#Redis-有序集合" class="headerlink" title="Redis 有序集合"></a>Redis 有序集合</h3><p>在学习跳表时讲到有序集合的操作时，做了些简化。实际上，在有序集合中，每个成员对象有两个重要的属性，key（键值）和 score（分值）。我们不仅会通过 score 来查找数据，还会通过 key 来查找数据。举个例子，比如用户积分排行榜有这样一个功能：我们可以通过用户的 ID 来查找积分信息，也可以通过积分区间来查找用户 ID 或者姓名信息。这里包含 ID、姓名和积分的用户信息，就是成员对象，用户 ID 就是 key，积分就是 score。所以，如果我们细化一下 Redis 有序集合的操作，那就是下面这样：</p>
<ul>
<li>添加一个成员对象；</li>
<li>按照键值来删除一个成员对象；</li>
<li>按照键值来查找一个成员对象；</li>
<li>按照分值区间查找数据，比如查找积分在[100, 356]之间的成员对象；</li>
<li>按照分值从小到大排序成员变量；</li>
</ul>
<p>如果我们仅仅按照分值将成员对象组织成跳表的结构，那按照键值来删除、查询成员对象就会很慢，解决方法与 LRU 缓存淘汰算法的解决方法类似。我们可以再<strong>按照键值构建一个散列表，这样按照 key 来删除、查找一个成员对象的时间复杂度就变成了 O(1)</strong>。同时，借助跳表结构，其他操作也非常高效。实际上，Redis 有序集合的操作还有另外一类，也就是查找成员对象的排名（Rank）或者根据排名区间查找成员对象。这个功能单纯用刚刚讲的这种组合结构就无法高效实现了，这部分内容后面会学习到。</p>
<h3 id="Java-LinkedHashMap"><a href="#Java-LinkedHashMap" class="headerlink" title="Java LinkedHashMap"></a>Java LinkedHashMap</h3><p>如果你熟悉 Java，那你几乎天天会用到这个容器。我们之前讲过，<strong>HashMap 底层是通过散列表这种数据结构实现的</strong>。而 LinkedHashMap 前面比 HashMap 多了一个“Linked”，这里的“Linked”是不是说，LinkedHashMap 是一个通过链表法解决散列冲突的散列表呢？实际上，LinkedHashMap 并没有这么简单，其中的“Linked”也并不仅仅代表它是通过链表法解决散列冲突的。我们先来看一段代码。你觉得这段代码会以什么样的顺序打印 3，1，5，2 这几个 key 呢？原因又是什么呢？<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;Integer, Integer&gt; m = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">m.put(<span class="number">3</span>, <span class="number">11</span>);</span><br><span class="line">m.put(<span class="number">1</span>, <span class="number">12</span>);</span><br><span class="line">m.put(<span class="number">5</span>, <span class="number">23</span>);</span><br><span class="line">m.put(<span class="number">2</span>, <span class="number">22</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Map.Entry e : m.entrySet()) &#123;</span><br><span class="line">  System.out.println(e.getKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上面的代码会按照数据插入的顺序依次来打印，也就是说，打印的顺序就是 3，1，5，2。你有没有觉得奇怪？散列表中数据是经过散列函数打乱之后无规律存储的，这里是如何实现按照数据的插入顺序来遍历打印的呢？你可能已经猜到了，LinkedHashMap 也是通过散列表和链表组合在一起实现的。实际上，它不仅支持按照插入顺序遍历数据，还支持按照访问顺序来遍历数据。你可以看下面这段代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 10是初始大小，0.75是装载因子，true是表示按照访问时间排序</span></span><br><span class="line">HashMap&lt;Integer, Integer&gt; m = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(<span class="number">10</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">m.put(<span class="number">3</span>, <span class="number">11</span>);</span><br><span class="line">m.put(<span class="number">1</span>, <span class="number">12</span>);</span><br><span class="line">m.put(<span class="number">5</span>, <span class="number">23</span>);</span><br><span class="line">m.put(<span class="number">2</span>, <span class="number">22</span>);</span><br><span class="line"></span><br><span class="line">m.put(<span class="number">3</span>, <span class="number">26</span>);</span><br><span class="line">m.get(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Map.Entry e : m.entrySet()) &#123;</span><br><span class="line">  System.out.println(e.getKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这段代码打印的结果是 1，2，3，5。分析一波，每次调用 put() 函数，往 LinkedHashMap 中添加数据的时候，都会将数据添加到链表的尾部，所以，在前四个操作完成之后，链表中的数据是下面这样：<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/20散列表（下）：为什么散列表和链表经常会一起使用？/数据插入.png" alt><br>在第 8 行代码中，再次将键值为 3 的数据放入到 LinkedHashMap 的时候，会先查找这个键值是否已经有了，然后，再将已经存在的 (3,11) 删除，并且将新的 (3,26) 放到链表的尾部。所以，这个时候链表中的数据就是下面这样：<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/20散列表（下）：为什么散列表和链表经常会一起使用？/数据插入2.png" alt><br>当第 9 行代码访问到 key 为 5 的数据的时候，我们将被访问到的数据移动到链表的尾部。所以，第 9 行代码之后，链表中的数据是下面这样：<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/20散列表（下）：为什么散列表和链表经常会一起使用？/数据插入3.png" alt><br>所以，最后打印出来的数据是 1，2，3，5。从上面的分析，你有没有发现，按照访问时间排序的 LinkedHashMap 本身就是一个支持 LRU 缓存淘汰策略的缓存系统？实际上，它们两个的实现原理也是一模一样的。</p>
<p>所以<strong>LinkedHashMap 是通过双向链表和散列表这两种数据结构组合实现的。LinkedHashMap 中的“Linked”实际上是指的是双向链表，并非指用链表法解决散列冲突。</strong></p>
<h3 id="解答开篇-amp-内容小结"><a href="#解答开篇-amp-内容小结" class="headerlink" title="解答开篇 &amp; 内容小结"></a>解答开篇 &amp; 内容小结</h3><p>为什么散列表和链表经常一块使用？<br>解答：<br><strong>散列表这种数据结构虽然支持非常高效的数据插入、删除、查找操作，但是散列表中的数据都是通过散列函数打乱之后无规律存储的</strong>。也就说，它无法支持按照某种顺序快速地遍历数据。如果希望按照顺序遍历散列表中的数据，那我们需要将散列表中的数据拷贝到数组中，然后排序，再遍历。因为散列表是动态数据结构，不停地有数据的插入、删除，所以每当我们希望按顺序遍历散列表中的数据的时候，都需要先排序，那效率势必会很低。为了解决这个问题，我们将散列表和链表（或者跳表）结合在一起使用。</p>
<h3 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h3><p>1.今天讲的几个散列表和链表结合使用的例子里，我们用的都是双向链表。如果把双向链表改成单链表，还能否正常工作呢？为什么呢？<br>2.假设猎聘网有 10 万名猎头，每个猎头都可以通过做任务（比如发布职位）来积累积分，然后通过积分来下载简历。假设你是猎聘网的一名工程师，如何在内存中存储这 10 万个猎头 ID 和积分信息，让它能够支持这样几个操作：<br>(1).根据猎头的 ID 快速查找、删除、更新这个猎头的积分信息；<br>(2).查找积分在某个区间的猎头 ID 列表；<br>(3).查找按照积分从小到大排名在第 x 位到第 y 位之间的猎头 ID 列表。</p>
<blockquote>
<p>解答：<br>1.在删除一个元素时，虽然能 O(1) 的找到目标结点，但是要删除该结点需要拿到前一个结点的指针，遍历到前一个结点复杂度会变为 O(N），所以用双链表实现比较合适。<br>2.(1)根据id查找猎头积分，可以用散列表来实现，将查找的效率O(1)，只不过散列表的数组实现中存的是猎头信息集合。<br>  (2)积分以跳表存储，跳表支持区间查询；<br>  (3)查找积分第x到第y位的，直接在第二问的基础上顺序遍历.</p>
</blockquote>
<h3 id="笔记小结"><a href="#笔记小结" class="headerlink" title="笔记小结"></a>笔记小结</h3><p>1.为什么散列表和链表经常放在一起使用？<br>2.散列表和链表如何组合起来使用？<br>一、为什么散列表和链表经常放在一起使用？<br>1.散列表的优点：支持高效的数据插入、删除和查找操作<br>2.散列表的缺点：不支持快速顺序遍历散列表中的数据<br>3.如何按照顺序快速遍历散列表的数据？只能将数据转移到数组，然后排序，最后再遍历数据。<br>4.我们知道散列表是动态的数据结构，需要频繁的插入和删除数据，那么每次顺序遍历之前都需要先排序，这势必会造成效率非常低下。<br>5.如何解决上面的问题呢？就是将散列表和链表（或跳表）结合起来使用。<br>二、散列表和链表如何组合起来使用？<br>1.LRU（Least Recently Used）缓存淘汰算法<br>1.1.LRU缓存淘汰算法主要操作有哪些？主要包含3个操作：<br>①往缓存中添加一个数据；<br>②从缓存中删除一个数据；<br>③在缓存中查找一个数据；<br>④总结：上面3个都涉及到查找。<br>1.2.如何用链表实现LRU缓存淘汰算法？<br>①需要维护一个按照访问时间从大到小的有序排列的链表结构。<br>②缓冲空间有限，当空间不足需要淘汰一个数据时直接删除链表头部的节点。<br>③当要缓存某个数据时，先在链表中查找这个数据。若未找到，则直接将数据放到链表的尾部。若找到，就把它移动到链表尾部。<br>④前面说了，LRU缓存的3个主要操作都涉及到查找，若单纯由链表实现，查找的时间复杂度很高为O(n)。若将链表和散列表结合使用，查找的时间复杂度会降低到O(1)。<br>1.3.如何使用散列表和链表实现LRU缓存淘汰算法？<br>①使用双向链表存储数据，链表中每个节点存储数据（data）、前驱指针（prev）、后继指针（next）和hnext指针（解决散列冲突的链表指针）。<br>②散列表通过链表法解决散列冲突，所以每个节点都会在两条链中。一条链是双向链表，另一条链是散列表中的拉链。前驱和后继指针是为了将节点串在双向链表中，hnext指针是为了将节点串在散列表的拉链中。<br>③LRU缓存淘汰算法的3个主要操作如何做到时间复杂度为O(1)呢？<br>首先，我们明确一点就是链表本身插入和删除一个节点的时间复杂度为O(1)，因为只需更改几个指针指向即可。接着，来分析查找操作的时间复杂度。当要查找一个数据时，通过散列表可实现在O(1)时间复杂度找到该数据，再加上前面说的插入或删除的时间复杂度是O(1)，所以我们总操作的时间复杂度就是O(1)。<br>2.Redis有序集合<br>2.1.什么是有序集合？<br>①在有序集合中，每个成员对象有2个重要的属性，即key（键值）和score（分值）。<br>②不仅会通过score来查找数据，还会通过key来查找数据。<br>2.2.有序集合的操作有哪些？<br>举个例子，比如用户积分排行榜有这样一个功能：可以通过用户ID来查找积分信息，也可以通过积分区间来查找用户ID。这里用户ID就是key，积分就是score。所以，有序集合的操作如下：<br>①添加一个对象；<br>②根据键值删除一个对象；<br>③根据键值查找一个成员对象；<br>④根据分值区间查找数据，比如查找积分在[100.356]之间的成员对象；<br>⑤按照分值从小到大排序成员变量。<br>这时可以按照分值将成员对象组织成跳表结构，按照键值构建一个散列表。那么上面的所有操作都非常高效。<br>3.Java LinkedHashMap<br>和LRU缓存淘汰策略实现一模一样。支持按照插入顺序遍历数据，也支持按照访问顺序遍历数据。</p>
]]></content>
      <categories>
        <category>DataStructureAndAlgorithm</category>
      </categories>
      <tags>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title>21哈希算法（上）：如何防止数据库中的用户信息被脱库？</title>
    <url>/articles/26f5a37e.html/</url>
    <content><![CDATA[<blockquote>
<p>声名：本文大部分内容出自于极客时间网站王争的专栏《数据结构与算法之美》，这里本人主要记录自己的学习过程，添加个人见解，并作为自己的学习笔记。如有侵权，立马删除。</p>
</blockquote>
<a id="more"></a>
<h3 id="问题导向"><a href="#问题导向" class="headerlink" title="问题导向"></a>问题导向</h3><p>2011 CSDN 网站被黑客攻击，超过 600 万用户的注册邮箱和密码明文被泄露，很多网友对 CSDN 明文保存用户密码行为产生了不满。<strong>如果你是 CSDN 的一名工程师，你会如何存储用户密码这么重要的数据吗？仅仅 MD5 加密一下存储就够了吗</strong>？ </p>
<p>哈希算法历史悠久，业界著名的哈希算法也有很多，比如 MD5、SHA 等。在我们平时的开发中，基本上都是拿现成的直接用,也没去探究如何去设计一个哈希算法，这也不是我们的重点，我们今天的重点时是我们该<strong>如何用哈希算法解决问题</strong>。</p>
<h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><p>首先明确下，哈希和散列是同一个意思，只是中文翻译的不同，所以哈希表其实也是散列表。哈希算法的定义和原理非常简单，基本上一句话就可以概括了。<strong>将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法</strong>，而通过原始数据映射之后得到的二进制值串就是<strong>哈希值</strong>。要想设计一个优秀的哈希算法并不容易，需要满足以下几点要求：</p>
<ul>
<li>从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）；</li>
<li>对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同；</li>
<li>散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小；</li>
<li>哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值。</li>
</ul>
<p>我们以MD5这种哈希算法来具体说明一下。我们分别对“今天我来讲哈希算法”和“jiajia”这两个文本，计算 MD5 哈希值，得到两串看起来毫无规律的字符串（MD5 的哈希值是 128 位的 Bit 长度，为了方便表示，将它们转化成了16进制编码）。可以看出来，无论要哈希的文本有多长、多短，通过MD5哈希之后，得到的哈希值的长度都是相同的，而且得到的哈希值看起来像一堆随机数，完全没有规律。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MD5(&quot;今天我来讲哈希算法&quot;) &#x3D; bb4767201ad42c74e650c1b6c03d78fa</span><br><span class="line">MD5(&quot;jiajia&quot;) &#x3D; cd611a31ea969b908932d44d126d195b</span><br></pre></td></tr></table></figure><br>我们再来看两个非常相似的文本，“我今天讲哈希算法！”和“我今天讲哈希算法”。这两个文本只有一个感叹号的区别。如果用 MD5 哈希算法分别计算它们的哈希值，你会发现，尽管只有一字之差，得到的哈希值也是完全不同的。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MD5(&quot;我今天讲哈希算法！&quot;) &#x3D; 425f0d5a917188d2c3c3dc85b5e4f2cb</span><br><span class="line">MD5(&quot;我今天讲哈希算法&quot;) &#x3D; a1fb91ac128e6aa37fe42c663971ac3d</span><br></pre></td></tr></table></figure><br>通过哈希算法得到的哈希值，很难反向推导出原始数据。比如上面的例子中，我们就很难通过哈希值“a1fb91ac128e6aa37fe42c663971ac3d”反推出对应的文本“我今天讲哈希算法”。哈希算法要处理的文本可能是各种各样的。比如，对于非常长的文本，如果哈希算法的计算时间很长，那就只能停留在理论研究的层面，很难应用到实际的软件开发中。比如，我们把今天这篇包含 4000 多个汉字的文章，用 MD5 计算哈希值，用不了 1ms 的时间。</p>
<p>哈希算法的应用非常非常多，这里有最常见的七个，分别是安全加密、唯一标识、数据校验、散列函数、负载均衡、数据分片、分布式存储。这里先学习前四项。</p>
<h4 id="应用一：安全加密"><a href="#应用一：安全加密" class="headerlink" title="应用一：安全加密"></a>应用一：安全加密</h4><p>说到哈希算法的应用，最先想到的应该就是安全加密。最常用于加密的哈希算法是 MD5（MD5 Message-Digest Algorithm，MD5 消息摘要算法）和 SHA（Secure Hash Algorithm，安全散列算法）。除了这两个之外，当然还有很多其他加密算法，比如 DES（Data Encryption Standard，数据加密标准）、AES（Advanced Encryption Standard，高级加密标准）。</p>
<p>我们上面说到哈希算法有四点要求，对用于加密的哈希算法来说，有两点格外重要。第一点是很难根据哈希值反向推导出原始数据，第二点是散列冲突的概率要很小。第一点很好理解，加密的目的就是防止原始数据泄露，所以很难通过哈希值反向推导原始数据，这是一个最基本的要求。第二点呢，实际上，不管是什么哈希算法，我们只能尽量减少碰撞冲突的概率，理论上是没办法做到完全不冲突的。</p>
<p>这里就基于组合数学中一个非常基础的理论，鸽巢原理（也叫抽屉原理）。这个原理本身很简单，它是说，如果有 10 个鸽巢，有 11 只鸽子，那肯定有 1 个鸽巢中的鸽子数量多于 1 个，换句话说就是，肯定有 2 只鸽子在 1 个鸽巢内。最后基于这个鸽巢原理，我们来解释下为什么哈希算法无法做到零冲突。</p>
<p>我们知道，哈希算法产生的哈希值的长度是固定且有限的。比如前面举的 MD5 的例子，哈希值是固定的 128 位二进制串，能表示的数据是有限的，最多能表示 2^128 个数据，而我们要哈希的数据是无穷的。基于鸽巢原理，如果我们对 2^128+1 个数据求哈希值，就必然会存在哈希值相同的情况。一般情况下，哈希值越长的哈希算法，散列冲突的概率越低。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2^128&#x3D;340282366920938463463374607431768211456</span><br></pre></td></tr></table></figure><br>即便哈希算法存在散列冲突的情况，但是因为哈希值的范围很大，冲突的概率极低，所以相对来说还是很难破解的。像 MD5，有 2^128 个不同的哈希值，这个数据已经是一个天文数字了，所以散列冲突的概率要小于 1/2^128。如果我们拿到一个 MD5 哈希值，希望通过毫无规律的穷举的方法，找到跟这个 MD5 值相同的另一个数据，那耗费的时间应该是个天文数字。所以，即便哈希算法存在冲突，但是在有限的时间和资源下，哈希算法还是被很难破解的。</p>
<p>除此之外，没有绝对安全的加密。<strong>越复杂、越难破解的加密算法，需要的计算时间也越长</strong>。比如 SHA-256 比 SHA-1 要更复杂、更安全，相应的计算时间就会比较长。密码学界也一直致力于找到一种快速并且很难被破解的哈希算法。我们在实际的开发过程中，也需要权衡破解难度和计算时间，来决定究竟使用哪种加密算法。</p>
<h4 id="应用二：唯一标识"><a href="#应用二：唯一标识" class="headerlink" title="应用二：唯一标识"></a>应用二：唯一标识</h4><p>现在假设我们要在海量的图库中，搜索一张图是否存在，我们不能单纯地用图片的元信息（比如图片名称）来比对，因为有可能存在名称相同但图片内容不同，或者名称不同图片内容相同的情况。那我们该如何搜索呢？</p>
<p>我们知道，任何文件在计算中都可以表示成二进制码串，所以，比较笨的办法就是，拿要查找的图片的二进制码串与图库中所有图片的二进制码串一一比对。如果相同，则说明图片在图库中存在。但是，每个图片小则几十 KB、大则几 MB，转化成二进制是一个非常长的串，比对起来非常耗时。其实我们可以给每一个图片取一个唯一标识，或者说信息摘要。比如，我们可以从图片的二进制码串开头取 100 个字节，从中间取 100 个字节，从最后再取 100 个字节，然后将这 300 个字节放到一块，通过哈希算法（比如 MD5），得到一个哈希字符串，用它作为图片的唯一标识。通过这个唯一标识来判定图片是否在图库中，这样就可以减少很多工作量。</p>
<p>如果还想继续提高效率，我们可以把每个图片的唯一标识，和相应的图片文件在图库中的路径信息，都存储在散列表中。当要查看某个图片是不是在图库中的时候，我们先通过哈希算法对这个图片取唯一标识，然后在散列表中查找是否存在这个唯一标识。如果不存在，那就说明这个图片不在图库中；如果存在，我们再通过散列表中存储的文件路径，获取到这个已经存在的图片，跟现在要插入的图片做全量的比对，看是否完全一样。如果一样，就说明已经存在；如果不一样，说明两张图片尽管唯一标识相同，但是并不是相同的图片。</p>
<h4 id="应用三：数据校验"><a href="#应用三：数据校验" class="headerlink" title="应用三：数据校验"></a>应用三：数据校验</h4><p>电驴这样的 BT 下载软件你肯定用过吧？我们知道，BT下载的原理是基于P2P协议的。我们从多个机器上并行下载一个 2GB 的电影，这个电影文件可能会被分割成很多文件块（比如可以分成 100 块，每块大约 20MB）。等所有的文件块都下载完成之后，再组装成一个完整的电影文件就行了。我们知道，网络传输是不安全的，下载的文件块有可能是被宿主机器恶意修改过的，又或者下载过程中出现了错误，所以下载的文件块可能不是完整的。如果我们没有能力检测这种恶意修改或者文件下载出错，就会导致最终合并后的电影无法观看，甚至导致电脑中毒。现在的问题是，如何来校验文件块的安全、正确、完整呢？</p>
<p>具体的 BT 协议很复杂，校验方法也有很多，这里有一种思路：<br>我们通过哈希算法，对 100 个文件块分别取哈希值，并且保存在种子文件中。我们前面说到哈希算法有一个特点，对数据很敏感。只要文件块的内容有一丁点儿的改变，最后计算出的哈希值就会完全不同。所以，当文件块下载完成之后，我们可以通过相同的哈希算法，对下载好的文件块逐一求哈希值，然后跟种子文件中保存的哈希值比对。如果不同，说明这个文件块不完整或者被篡改了，需要再重新从其他宿主机器上下载这个文件块。</p>
<h4 id="应用四：散列函数"><a href="#应用四：散列函数" class="headerlink" title="应用四：散列函数"></a>应用四：散列函数</h4><p>实际上，散列函数也是哈希算法的一种应用。散列函数是设计一个散列表的关键。它直接决定了散列冲突的概率和散列表的性能。不过，相对哈希算法的其他应用，散列函数对于散列算法冲突的要求要低很多。即便出现个别散列冲突，只要不是过于严重，我们都可以通过开放寻址法或者链表法解决。</p>
<p>不仅如此，散列函数对于散列算法计算得到的值，是否能反向解密也并不关心。散列函数中用到的散列算法，更加关注散列后的值是否能<strong>平均分布</strong>，也就是，<strong>一组数据是否能均匀地散列在各个槽中</strong>。除此之外，散列函数执行的快慢，也会影响散列表的性能，所以，散列函数用的散列算法一般都比较简单，比较追求效率。</p>
<h3 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h3><p><strong>如果你是 CSDN 的一名工程师，你会如何存储用户密码这么重要的数据吗？仅仅 MD5 加密一下存储就够了吗</strong>？<br>解答：我们可以通过哈希算法，对用户密码进行加密之后再存储，不过最好选择相对安全的加密算法，比如 SHA 等（因为 MD5 已经号称被破解了）。不过仅仅这样加密之后存储并不能确保大事万吉，因为还有字典攻击。如果用户信息被“脱库”，黑客虽然拿到是加密之后的密文，但可以通过“猜”的方式来破解密码，这是因为，有些用户的密码太简单。比如很多人习惯用 00000、123456 这样的简单数字组合做密码，很容易就被猜中。</p>
<p>那我们就需要维护一个常用密码的字典表，把字典中的每个密码用哈希算法计算哈希值，然后拿哈希值跟脱库后的密文比对。如果相同，基本上就可以认为，这个加密之后的密码对应的明文就是字典中的这个密码。（注意，这里说是的是“基本上可以认为”，因为根据我们前面的学习，哈希算法存在散列冲突，也有可能出现，尽管密文一样，但是明文并不一样的情况。）针对字典攻击，我们可以引入一个盐(salt)(加salt，也可理解为为密码加点佐料后再进行hash运算。比如原密码是123456，不加盐的情况加密后假设是是xyz。 黑客拿到脱机的数据后，通过彩虹表匹配可以轻松破解常用密码。如果加盐，密码123456加盐后可能是12ng34qq56zz，再对加盐后的密码进行hash后值就与原密码hash后的值完全不同了。而且加盐的方式有很多种，可以是在头部加，可以在尾部加，还可在内容中间加，甚至加的盐还可以是随机的。这样即使用户使用的是最常用的密码，黑客拿到密文后破解的难度也很高。)，跟用户的密码组合在一起，增加密码的复杂度。我们拿组合之后的字符串来做哈希算法加密，将它存储到数据库中，进一步增加破解的难度。</p>
<h3 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h3><p>这节主要学习了哈希算法的四个应用场景：</p>
<ul>
<li>第一个应用是唯一标识，哈希算法可以对大数据做信息摘要，通过一个较短的二进制编码来表示很大的数据。</li>
<li>第二个应用是用于校验数据的完整性和正确性。</li>
<li>第三个应用是安全加密，我们讲到任何哈希算法都会出现散列冲突，但是这个冲突概率非常小。越是复杂哈希算法越难破解，但同样计算时间也就越长。所以，选择哈希算法的时候，要权衡安全性和计算时间来决定用哪种哈希算法。</li>
<li>第四个应用是散列函数，这个我们前面讲散列表的时候已经详细地讲过，它对哈希算法的要求非常特别，更加看重的是散列的平均性和哈希算法的执行效率。</li>
</ul>
<h3 id="笔记小结"><a href="#笔记小结" class="headerlink" title="笔记小结"></a>笔记小结</h3><p>1.如何防止数据库中的用户信息被脱库？<br>2.你会如何存储用户密码这么重要的数据吗？仅仅 MD5 加密一下存储就够了吗？<br>3.在实际开发中，我们应该如何用哈希算法解决问题？<br>一、什么是哈希算法？<br>1.定义<br>将任意长度的二进制值串映射成固定长度的二进制值串，这个映射的规则就是哈希算法，而通过原始数据映射之后得到的二进制值串就是哈希值。<br>2.如何设计一个优秀的哈希算法？<br>①单向哈希：<br>从哈希值不能反向推导出哈希值（所以哈希算法也叫单向哈希算法）。<br>②篡改无效：<br>对输入敏感，哪怕原始数据只修改一个Bit，最后得到的哈希值也大不相同。<br>③散列冲突：<br>散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小。<br>④执行效率：<br>哈希算法的执行效率要尽量高效，针对较长的文本，也能快速计算哈希值。<br>二、哈希算法的常见应用有哪些？<br>7个常见应用：安全加密、唯一标识、数据校验、散列函数、负载均衡、数据分片、分布式存储。<br>1.安全加密<br>①常用于加密的哈希算法：<br>MD5：MD5 Message-Digest Algorithm，MD5消息摘要算法<br>SHA：Secure Hash Algorithm，安全散列算法<br>DES：Data Encryption Standard，数据加密标准<br>AES：Advanced Encryption Standard，高级加密标准<br>②对用于加密的哈希算法，有两点格外重要，第一点是很难根据哈希值反向推导出原始数据，第二点是散列冲突的概率要小。<br>③在实际开发中要权衡破解难度和计算时间来决定究竟使用哪种加密算法。<br>2.唯一标识<br>通过哈希算法计算出数据的唯一标识，从而用于高效检索数据。<br>3.数据校验<br>利用哈希算法对输入数据敏感的特点，可以对数据取哈希值，从而高效校验数据是否被篡改过。<br>4.散列函数<br>散列函数中用到的哈希算法更加关注散列后的值能不能平均分布，以及散列函数的执行快慢。<br>三、思考<br>1.如何防止数据库中的用户信息被脱库？你会如何存储用户密码这么重要的数据吗？<br>①使用MD5进行加密<br>②字典攻击：如果用户信息被“脱库”，黑客虽然拿到的是加密之后的密文，但可以通过“猜”的方式来破解密码，这是因为，有些用户的密码太简单。<br>③针对字典攻击，我们可以引入一个盐（salt），跟用户密码组合在一起，增加密码的复杂度。</p>
]]></content>
      <categories>
        <category>DataStructureAndAlgorithm</category>
      </categories>
      <tags>
        <tag>Hash Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>23二叉树基础（上）：什么样的二叉树适合用数组来存储？</title>
    <url>/articles/afde8b49.html/</url>
    <content><![CDATA[<blockquote>
<p>声名：本文大部分内容出自于极客时间网站王争的专栏《数据结构与算法之美》，这里本人主要记录自己的学习过程，添加个人见解，并作为自己的学习笔记。如有侵权，立马删除。</p>
</blockquote>
<a id="more"></a>
<h3 id="问题导向"><a href="#问题导向" class="headerlink" title="问题导向"></a>问题导向</h3><p>前面我们学习了线性表的结构，栈、队列等，现在来学习非线性表的数据结构，树(tree),树这种数据结构比线性表的数据结构要复杂得多，内容也比较多。我们会依次学习到树、二叉树，二叉查找树，平衡二叉查找树、红黑树以及递归树。依照惯例，首先抛出的问题是：<font color="blue" size="3">二叉树有哪几种存储方式？什么样的二叉树适合用数组来存储？</font></p>
<h3 id="树（Tree）"><a href="#树（Tree）" class="headerlink" title="树（Tree）"></a>树（Tree）</h3><p>我们先以图表的形式来看下树长什么样子。</p>
<p><div align="center">
<img src="/articles/afde8b49.html/树.png">
</div><br>树是由一个个节点和节点之间的连线组成。他们之间的彼此连接关系组成了“父子关系”。</p>
<p>如下面这幅图，A 节点就是 B 节点的<strong>父节点</strong>，B 节点是 A 节点的<strong>子节点</strong>。B、C、D 这三个节点的父节点是同一个节点，所以它们之间互称为<strong>兄弟节点</strong>。我们把没有父节点的节点叫作<strong>根节点</strong>，也就是图中的节点 E。我们把没有子节点的节点叫作<strong>叶子节点</strong>或者<strong>叶节点</strong>，比如图中的 G、H、I、J、K、L 都是叶子节点。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/23二叉树基础（上）：什么样的二叉树适合用数组来存储？/树2.png" alt></p>
<p>除此之外，关于“树”，还有三个比较相似的概念：<strong>高度（Height）、深度（Depth）、层（Level）</strong>。它们的定义是这样的：<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/23二叉树基础（上）：什么样的二叉树适合用数组来存储？/树3.png" alt></p>
<p>图示如下：<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/23二叉树基础（上）：什么样的二叉树适合用数组来存储？/树4.png" alt></p>
<h3 id="二叉树（Binary-Tree）"><a href="#二叉树（Binary-Tree）" class="headerlink" title="二叉树（Binary Tree）"></a>二叉树（Binary Tree）</h3><p>树结构多种多样，不过我们最常用还是二叉树。二叉树，顾名思义，每个节点最多有两个“叉”，也就是两个子节点，分别是左子节点和右子节点。不过，二叉树并不要求每个节点都有两个子节点，有的节点只有左子节点，有的节点只有右子节点。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/23二叉树基础（上）：什么样的二叉树适合用数组来存储？/二叉树.png" alt></p>
<p>这个图里面，有两个比较特殊的二叉树，分别是编号 2 和编号 3 这两个。其中，编号 2 的二叉树中，叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫作<strong>满二叉树</strong>。编号 3 的二叉树中，<strong>叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大</strong>，这种二叉树叫作<strong>完全二叉树</strong>。</p>
<p>完全二叉树和非完全二叉树的对比<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/23二叉树基础（上）：什么样的二叉树适合用数组来存储？/完全和不完全二叉树.png" alt></p>
<p>要理解完全二叉树定义的由来，我们需要先了解，如何表示（或者存储）一棵二叉树？想要存储一棵二叉树，我们有两种方法，一种是基于指针或者引用的<strong>二叉链式存储法</strong>，一种是基于数组的<strong>顺序存储法</strong>。</p>
<p>我们先来看比较简单、直观的<strong>链式存储法</strong>。从图中你应该可以很清楚地看到，每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针。我们只要拎住根节点，就可以通过左右子节点的指针，把整棵树都串起来。这种存储方式我们比较常用。大部分二叉树代码都是通过这种结构来实现的。</p>
<p><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/23二叉树基础（上）：什么样的二叉树适合用数组来存储？/链二叉树.png" alt></p>
<p>我们再来看，基于数组的<strong>顺序存储法</strong>。我们把根节点存储在下标 i = 1 的位置，那左子节点存储在下标 2 <em> i = 2 的位置，右子节点存储在 2 </em> i + 1 = 3 的位置。以此类推，B 节点的左子节点存储在 2 <em> i = 2 </em> 2 = 4 的位置，右子节点存储在 2 <em> i + 1 = 2 </em> 2 + 1 = 5 的位置。</p>
<p><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/23二叉树基础（上）：什么样的二叉树适合用数组来存储？/顺序存储.png" alt></p>
<p>总结一下就是，如果节点 X 存储在数组中下标为 i 的位置，下标为 2 <em> i 的位置存储的就是左子节点，下标为 2 </em> i + 1 的位置存储的就是右子节点。反过来，下标为 i/2 的位置存储就是它的父节点。通过这种方式，我们只要知道根节点存储的位置（一般情况下，为了方便计算子节点，根节点会存储在下标为 1 的位置），这样就可以通过下标计算，把整棵树都串起来。</p>
<p>上面的是一棵完全二叉树，所以仅仅“浪费”了一个下标为 0 的存储位置。如果是非完全二叉树，其实会浪费比较多的数组存储空间</p>
<p><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/23二叉树基础（上）：什么样的二叉树适合用数组来存储？/顺序非完全二叉树.png" alt></p>
<p>所以，如果某棵二叉树是一棵完全二叉树，那用数组存储无疑是最节省内存的一种方式。因为数组的存储方式并不需要像链式存储法那样，要存储额外的左右子节点的指针。这也是为什么完全二叉树会单独拎出来的原因，也是为什么完全二叉树要求最后一层的子节点都靠左的原因。后面学习的堆，其实就是一种完全二叉树，最常用的存储方式就是数组。</p>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>我们来看二叉树中非常重要的操作，二叉树的遍历。这也是非常常见的面试题。如何将所有节点都遍历打印出来呢？经典的方法有三种，<strong>前序遍历</strong>、<strong>中序遍历</strong>和<strong>后序遍历</strong>。其中，前、中、后序，表示的是节点与它的左右子树节点遍历打印的先后顺序。</p>
<ul>
<li>前序遍历是指，对于树中的任意节点来说，<strong>先打印这个节点，然后再打印它的左子树，最后打印它的右子树</strong>。</li>
<li>中序遍历是指，对于树中的任意节点来说，<strong>先打印它的左子树，然后再打印它本身，最后打印它的右子树</strong>。</li>
<li>后序遍历是指，对于树中的任意节点来说，<strong>先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身</strong>。</li>
</ul>
<p><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/23二叉树基础（上）：什么样的二叉树适合用数组来存储？/二叉树的遍历.png" alt></p>
<p><strong>实际上，二叉树的前、中、后序遍历就是一个递归的过程</strong>。比如，前序遍历，其实就是先打印根节点，然后再递归地打印左子树，最后递归地打印右子树。写递归代码的关键，就是看能不能写出递推公式，而写递推公式的关键就是，如果要解决问题 A，就假设子问题 B、C 已经解决，然后再来看如何利用 B、C 来解决 A。所以，我们可以把前、中、后序遍历的递推公式都写出来。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前序遍历的递推公式：</span><br><span class="line">preOrder(r) &#x3D; print r-&gt;preOrder(r-&gt;left)-&gt;preOrder(r-&gt;right)</span><br><span class="line"></span><br><span class="line">中序遍历的递推公式：</span><br><span class="line">inOrder(r) &#x3D; inOrder(r-&gt;left)-&gt;print r-&gt;inOrder(r-&gt;right)</span><br><span class="line"></span><br><span class="line">后序遍历的递推公式：</span><br><span class="line">postOrder(r) &#x3D; postOrder(r-&gt;left)-&gt;postOrder(r-&gt;right)-&gt;print r</span><br></pre></td></tr></table></figure><br>有了递推公式，代码写起来就简单多了。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  print root <span class="comment">// 此处为伪代码，表示打印root节点</span></span><br><span class="line">  preOrder(root-&gt;left);</span><br><span class="line">  preOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  inOrder(root-&gt;left);</span><br><span class="line">  print root <span class="comment">// 此处为伪代码，表示打印root节点</span></span><br><span class="line">  inOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  postOrder(root-&gt;left);</span><br><span class="line">  postOrder(root-&gt;right);</span><br><span class="line">  print root <span class="comment">// 此处为伪代码，表示打印root节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="二叉树遍历的时间复杂度"><a href="#二叉树遍历的时间复杂度" class="headerlink" title="二叉树遍历的时间复杂度"></a>二叉树遍历的时间复杂度</h4><p>从前、中、后序遍历的顺序图，可以看出来，每个节点最多会被访问两次，所以遍历操作的时间复杂度，跟节点的个数 n 成正比，也就是说二叉树遍历的时间复杂度是 O(n)。</p>
<h3 id="解答开篇-amp-内容小结"><a href="#解答开篇-amp-内容小结" class="headerlink" title="解答开篇 &amp; 内容小结"></a>解答开篇 &amp; 内容小结</h3><p>树，是一种非线性表数据结构，关于树，有几个比较常用的概念那就是：根节点、叶子节点、父节点、子节点、兄弟节点，还有节点的高度、深度、层数，以及树的高度。</p>
<p>我们平时最常用的树就是二叉树。二叉树的每个节点最多有两个子节点，分别是左子节点和右子节点。二叉树中，有两种比较特殊的树，分别是满二叉树和完全二叉树。满二叉树又是完全二叉树的一种特殊情况。</p>
<p>　　二叉树既可以用链式存储，也可以用数组顺序存储。数组顺序存储的方式比较适合完全二叉树，其他类型的二叉树用数组存储会比较浪费存储空间。除此之外，二叉树里非常重要的操作就是前、中、后序遍历操作，遍历的时间复杂度是 O(n)，你需要理解并能用递归代码来实现。</p>
<h3 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h3><p>1.给定一组数据，比如 1，3，5，6，9，10。你来算算，可以构建出多少种不同的二叉树？<br>2.我们讲了三种二叉树的遍历方式，前、中、后序。实际上，还有另外一种遍历方式，也就是按层遍历，你知道如何实现吗？</p>
]]></content>
      <categories>
        <category>DataStructureAndAlgorithm</category>
      </categories>
      <tags>
        <tag>Binary tree</tag>
      </tags>
  </entry>
  <entry>
    <title>22哈希算法（下）：哈希算法在分布式系统中有哪些应用？</title>
    <url>/articles/3377b7d3.html/</url>
    <content><![CDATA[<blockquote>
<p>声名：本文大部分内容出自于极客时间网站王争的专栏《数据结构与算法之美》，这里本人主要记录自己的学习过程，添加个人见解，并作为自己的学习笔记。如有侵权，立马删除。</p>
</blockquote>
<a id="more"></a>
<h4 id="问题导向"><a href="#问题导向" class="headerlink" title="问题导向"></a>问题导向</h4><p>哈希算法是如何解决分布式问题的。</p>
<h4 id="应用五：负载均衡"><a href="#应用五：负载均衡" class="headerlink" title="应用五：负载均衡"></a>应用五：负载均衡</h4><p>我们知道，负载均衡算法有很多，比如轮询、随机、加权轮询等。那如何才能实现一个会话粘滞（session sticky）的负载均衡算法呢？也就是说，我们需要在同一个客户端上，在一次会话中的所有请求都路由到同一个服务器上。最直接的方法就是，维护一张映射关系表，这张表的内容是客户端 IP 地址或者会话 ID 与服务器编号的映射关系。客户端发出的每次请求，都要先在映射表中查找应该路由到的服务器编号，然后再请求编号对应的服务器。这种方法简单直观，但也有几个弊端：</p>
<ul>
<li>如果客户端很多，映射表可能会很大，比较浪费内存空间；</li>
<li>客户端下线、上线，服务器扩容、缩容都会导致映射失效，这样维护映射表的成本就会很大；</li>
</ul>
<p>如果借助哈希算法，这些问题都可以非常完美地解决。<strong>我们可以通过哈希算法，对客户端 IP 地址或者会话 ID 计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由到的服务器编号。</strong>这样，我们就可以把同一个 IP 过来的所有请求，都路由到同一个后端服务器上。</p>
<h3 id="应用六：数据分片"><a href="#应用六：数据分片" class="headerlink" title="应用六：数据分片"></a>应用六：数据分片</h3><p>我们先来看两个例子</p>
<p><strong>1. 如何统计“搜索关键词”出现的次数？</strong></p>
<p>假如我们有 1T 的日志文件，这里面记录了用户的搜索关键词，我们想要快速统计出每个关键词被搜索的次数，该怎么做呢？</p>
<p>这个问题有两个难点，第一个是搜索日志很大，没办法放到一台机器的内存中。第二个难点是，如果只用一台机器来处理这么巨大的数据，处理时间会很长。</p>
<p>针对这两个难点，<strong>我们可以先对数据进行分片，然后采用多台机器处理的方法，来提高处理速度</strong>。具体的思路是这样的：为了提高处理的速度，我们用 n 台机器并行处理。我们从搜索记录的日志文件中，依次读出每个搜索关键词，并且通过哈希函数计算哈希值，然后再跟 n 取模()，最终得到的值(ps除留余数法)，就是应该被分配到的机器编号。<br>这样，哈希值相同的搜索关键词就被分配到了同一个机器上。也就是说，同一个搜索关键词会被分配到同一个机器上。每个机器会分别计算关键词出现的次数，最后合并起来就是最终的结果。实际上，这里的处理过程也是 MapReduce 的基本设计思想。</p>
<h4 id="2-如何快速判断图片是否在图库中？"><a href="#2-如何快速判断图片是否在图库中？" class="headerlink" title="2. 如何快速判断图片是否在图库中？"></a>2. 如何快速判断图片是否在图库中？</h4><p>这个问题之前我们使用的是给每个图片取唯一标识（或者信息摘要），然后构建散列表。但是如果现在我们的图库中有 1 亿张图片，很显然，在单台机器上构建散列表是行不通的。因为单台机器的内存有限，而 1 亿张图片构建散列表显然远远超过了单台机器的内存上限。</p>
<p>我们同样可以对数据进行分片，然后采用多机处理。我们准备 n 台机器，让每台机器只维护某一部分图片对应的散列表。<strong>我们每次从图库中读取一个图片，计算唯一标识，然后与机器个数 n 求余取模，得到的值就对应要分配的机器编号，然后将这个图片的唯一标识和图片路径发往对应的机器构建散列表。</strong>当我们要判断一个图片是否在图库中的时候，我们通过同样的哈希算法，计算这个图片的唯一标识，然后与机器个数 n 求余取模。假设得到的值是 k，那就去编号 k 的机器构建的散列表中查找。</p>
<p>现在，我们来估算一下，给这 1 亿张图片构建散列表大约需要多少台机器。散列表中每个数据单元包含两个信息，哈希值和图片文件的路径。假设我们通过 MD5 来计算哈希值，那长度就是 128 比特，也就是 16 字节。文件路径长度的上限是 256 字节，我们可以假设平均长度是 128 字节。如果我们用链表法来解决冲突，那还需要存储指针，指针只占用 8 字节。所以，散列表中每个数据单元就占用 152 字节（这里只是估算，并不准确）。</p>
<p>假设一台机器的内存大小为 2GB，散列表的装载因子为 0.75，那一台机器可以给大约 1000 万（2GB*0.75/152）张图片构建散列表。所以，如果要对 1 亿张图片构建索引，需要大约十几台机器。在工程中，这种估算还是很重要的，能让我们事先对需要投入的资源、资金有个大概的了解，能更好地评估解决方案的可行性。实际上，针对这种海量数据的处理问题，我们都可以采用多机分布式处理。借助这种分片的思路，可以突破单机内存、CPU 等资源的限制。</p>
<h3 id="应用七：分布式存储"><a href="#应用七：分布式存储" class="headerlink" title="应用七：分布式存储"></a>应用七：分布式存储</h3><p>现在互联网面对的都是海量的数据、海量的用户。我们为了提高数据的读取、写入能力，一般都采用分布式的方式来存储数据，比如分布式缓存。我们有海量的数据需要缓存，所以一个缓存机器肯定是不够的。于是，我们就需要将数据分布在多台机器上。该如何决定将哪个数据放到哪个机器上呢？我们可以借用前面数据分片的思想，即通过哈希算法对数据取哈希值，然后对机器个数取模，这个最终值就是应该存储的缓存机器编号。</p>
<p>但是，如果数据增多，原来的 10 个机器已经无法承受了，我们就需要扩容了，比如扩到 11 个机器，这时候麻烦就来了。因为，这里并不是简单地加个机器就可以了。原来的数据是通过与 10 来取模的。比如 13 这个数据，存储在编号为 3 这台机器上。但是新加了一台机器中，我们对数据按照 11 取模，原来 13 这个数据就被分配到 2 号这台机器上了。<br><img src="http://cdn.wangng.com/DataStructureAndAlgorithm/22哈希算法（下）：哈希算法在分布式系统中有哪些应用？/分布式存储.png" alt></p>
<p>因此，所有的数据都要重新计算哈希值，然后重新搬移到正确的机器上。这样就相当于，缓存中的数据一下子就都失效了。所有的数据请求都会穿透缓存，直接去请求数据库。这样就可能发生<a href="https://zh.wikipedia.org/wiki/%E9%9B%AA%E5%B4%A9%E6%95%88%E5%BA%94" target="_blank" rel="noopener">雪崩效应</a>，压垮数据库。所以，我们需要一种方法，使得在新加入一个机器后，并不需要做大量的数据搬移。这时候，<strong>一致性哈希算法</strong>就要登场了。</p>
<p>假设我们有 k 个机器，数据的哈希值的范围是[0, MAX]。我们将整个范围划分成 m 个小区间（m 远大于 k），每个机器负责 m/k 个小区间。当有新机器加入的时候，我们就将某几个小区间的数据，从原来的机器中搬移到新的机器中。这样，既不用全部重新哈希、搬移数据，也保持了各个机器上数据数量的均衡。一致性哈希算法的基本思想就是这么简单。除此之外，它还会借助一个虚拟的环和虚拟结点，更加优美地实现出来。这里有一篇比较不错的关于一致性哈希算法的[<a href="http://www.zsythink.net/archives/1182" target="_blank" rel="noopener">博客</a></p>
<p>除了我们上面讲到的分布式缓存，实际上，一致性哈希算法的应用非常广泛，在很多分布式存储系统中，都可以见到一致性哈希算法的影子。</p>
<h3 id="解答开篇-amp-内容小结"><a href="#解答开篇-amp-内容小结" class="headerlink" title="解答开篇 &amp; 内容小结"></a>解答开篇 &amp; 内容小结</h3><p>这节我们主要学习了三种哈希算法在分布式系统中的应用，它们分别是：负载均衡、数据分片、分布式存储。<strong>在负载均衡应用中，利用哈希算法替代映射表，可以实现一个会话粘滞的负载均衡策略。在数据分片应用中，通过哈希算法对处理的海量数据进行分片，多机分布式处理，可以突破单机资源的限制。在分布式存储应用中，利用一致性哈希算法，可以解决缓存等分布式系统的扩容、缩容导致数据大量搬移的难题。</strong></p>
]]></content>
      <categories>
        <category>DataStructureAndAlgorithm</category>
      </categories>
      <tags>
        <tag>Hash Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>24二叉树基础（下）：有了如此高效的散列表，为什么还需要二叉树？</title>
    <url>/articles/57f9e3ff.html/</url>
    <content><![CDATA[<blockquote>
<p>声名：本文大部分内容出自于极客时间网站王争的专栏《数据结构与算法之美》，这里本人主要记录自己的学习过程，添加个人见解，并作为自己的学习笔记。如有侵权，立马删除。</p>
</blockquote>
<a id="more"></a>
<h3 id="问题导向"><a href="#问题导向" class="headerlink" title="问题导向"></a>问题导向</h3><p>　　前面我们学习了树、二叉树以及二叉树的遍历，现在再来学习一种特殊的的二叉树，二叉查找树。二叉查找树最大的特点就是，<strong>支持动态数据集合的快速插入、删除、查找操作</strong>。我们之前说过，散列表也是支持这些操作的，并且散列表的这些操作比二叉查找树更高效，时间复杂度是 O(1)。<font color="blue" size="3">既然有了这么高效的散列表，使用二叉树的地方是不是都可以替换成散列表呢？有没有哪些地方是散列表做不了，必须要用二叉树来做的呢？</font></p>
<h3 id="二叉查找树（Binary-Search-Tree"><a href="#二叉查找树（Binary-Search-Tree" class="headerlink" title="二叉查找树（Binary Search Tree)"></a>二叉查找树（Binary Search Tree)</h3><p>　　二叉查找树是二叉树中最常用的一种类型，也叫二叉搜索树。顾名思义，二叉查找树是为了实现快速查找而生的。不过，它不仅仅支持快速查找一个数据，还支持快速插入、删除一个数据。这些都得益于二叉查找树的特殊结构，<strong>二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。</strong></p>
<div align="center">
<img src="http://cdn.wangng.com/DataStructureAndAlgorithm/24%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%8B%EF%BC%89/24_1.png"></div>

<p>我们前面说过二叉查找树支持<strong>快速查找、插入、删除</strong>操作，现在我们就依次来看下，这三个操作是如何实现的。</p>
<h4 id="二叉查找树的查找操作"><a href="#二叉查找树的查找操作" class="headerlink" title="二叉查找树的查找操作"></a>二叉查找树的查找操作</h4><p>　　我们在二叉树中查找某个节点的过程如下：我们先取根节点，如果它等于我们要查找的数据，那就返回。如果要查找的数据比根节点的值小，那就在左子树中递归查找；如果要查找的数据比根节点的值大，那就在右子树中递归查找。</p>
<div align="center">
<img src="http://cdn.wangng.com/DataStructureAndAlgorithm/24%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%8B%EF%BC%89/24_2.png"></div>

<p>二叉查找树的代码如下<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Node tree;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Node <span class="title">find</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    Node p = tree;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (data &lt; p.data) p = p.left;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (data &gt; p.data) p = p.right;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">private</span> Node left;</span><br><span class="line">    <span class="keyword">private</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="二叉查找树的插入操作"><a href="#二叉查找树的插入操作" class="headerlink" title="二叉查找树的插入操作"></a>二叉查找树的插入操作</h4><p>　　二叉查找树的插入过程有点类似查找操作。新插入的数据一般都是在叶子节点上，所以我们只需要从根节点开始，依次比较要插入的数据和节点的大小关系。如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。</p>
<div align="center">
<img src="http://cdn.wangng.com/DataStructureAndAlgorithm/24%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%8B%EF%BC%89/24_3.png"></div>

<p>插入代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tree == <span class="keyword">null</span>) &#123;</span><br><span class="line">    tree = <span class="keyword">new</span> Node(data);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Node p = tree;</span><br><span class="line">  <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data &gt; p.data) &#123;</span><br><span class="line">      <span class="keyword">if</span> (p.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        p.right = <span class="keyword">new</span> Node(data);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      p = p.right;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// data &lt; p.data</span></span><br><span class="line">      <span class="keyword">if</span> (p.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">        p.left = <span class="keyword">new</span> Node(data);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      p = p.left;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="二叉查找树的删除操作"><a href="#二叉查找树的删除操作" class="headerlink" title="二叉查找树的删除操作"></a>二叉查找树的删除操作</h4><p>　　二叉查找树的查找、插入操作都比较简单易懂，但是它的删除操作就比较复杂了 。针对要删除节点的子节点个数的不同，我们需要分三种情况来处理。</p>
<ul>
<li><p>情况一：如果要删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置为 null。比如图中的删除节点 55</p>
</li>
<li><p>情况二：如果要删除的节点只有一个子节点（只有左子节点或者右子节点），我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了。比如图中的删除节点 13。</p>
</li>
<li><p>情况三：如果要删除的节点有两个子节点，这就比较复杂了。我们需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点（如果有左子结点，那就不是最小节点了），所以，我们可以应用上面两条规则来删除这个最小节点。比如图中的删除节点 18。</p>
</li>
</ul>
<div align="center">
<img src="http://cdn.wangng.com/DataStructureAndAlgorithm/24%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%8B%EF%BC%89/24_4.png"></div>

<p>删除代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">  Node p = tree; <span class="comment">// p指向要删除的节点，初始化指向根节点</span></span><br><span class="line">  Node pp = <span class="keyword">null</span>; <span class="comment">// pp记录的是p的父节点</span></span><br><span class="line">  <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.data != data) &#123;</span><br><span class="line">    pp = p;</span><br><span class="line">    <span class="keyword">if</span> (data &gt; p.data) p = p.right;</span><br><span class="line">    <span class="keyword">else</span> p = p.left;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (p == <span class="keyword">null</span>) <span class="keyword">return</span>; <span class="comment">// 没有找到</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 要删除的节点有两个子节点</span></span><br><span class="line">  <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123; <span class="comment">// 查找右子树中最小节点</span></span><br><span class="line">    Node minP = p.right;</span><br><span class="line">    Node minPP = p; <span class="comment">// minPP表示minP的父节点</span></span><br><span class="line">    <span class="keyword">while</span> (minP.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">      minPP = minP;</span><br><span class="line">      minP = minP.left;</span><br><span class="line">    &#125;</span><br><span class="line">    p.data = minP.data; <span class="comment">// 将minP的数据替换到p中</span></span><br><span class="line">    p = minP; <span class="comment">// 下面就变成了删除minP了</span></span><br><span class="line">    pp = minPP;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除节点是叶子节点或者仅有一个子节点</span></span><br><span class="line">  Node child; <span class="comment">// p的子节点</span></span><br><span class="line">  <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) child = p.left;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) child = p.right;</span><br><span class="line">  <span class="keyword">else</span> child = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pp == <span class="keyword">null</span>) tree = child; <span class="comment">// 删除的是根节点</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p) pp.left = child;</span><br><span class="line">  <span class="keyword">else</span> pp.right = child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>　　实际上，关于二叉查找树的删除操作，还有个非常简单、取巧的方法，就是单纯将要删除的节点标记为“已删除”，但是并不真正从树中将这个节点去掉。这样原本删除的节点还需要存储在内存中，比较浪费内存空间，但是删除操作就变得简单了很多。而且，这种处理方法也并没有增加插入、查找操作代码实现的难度。</p>
<h4 id="叉查找树的其他操作"><a href="#叉查找树的其他操作" class="headerlink" title="叉查找树的其他操作"></a>叉查找树的其他操作</h4><p>　　除了插入、删除、查找操作之外，二叉查找树中还可以支持<strong>快速地查找最大节点和最小节点、前驱节点和后继节点</strong>。这些操作代码放在作者的<a href="https://github.com/wangzheng0822/algo" target="_blank" rel="noopener">github</a>仓库中。二叉查找树除了支持上面几个操作之外，还有一个重要的特性，就是<strong>中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 O(n)</strong>，非常高效。因此，二叉查找树也叫作二叉排序树。</p>
<h3 id="支持重复数据的二叉查找树"><a href="#支持重复数据的二叉查找树" class="headerlink" title="支持重复数据的二叉查找树"></a>支持重复数据的二叉查找树</h3><p>　　前面的二叉查找树的操作，针对的都是不存在键值相同的情况。那如果存储的两个对象键值相同，这种情况该怎么处理呢？</p>
<ul>
<li>方法一：我们通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。</li>
<li>方法二：每个节点仍然只存储一个数据。在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，我们就将这个要插入的数据放到这个节点的右子树，也就是说，把这个新插入的数据当作大于这个节点的值来处理。</li>
</ul>
<div align="center">
<img src="http://cdn.wangng.com/DataStructureAndAlgorithm/24%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%8B%EF%BC%89/24_5.png"></div>

<p>当要查找数据的时候，遇到值相同的节点，我们并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停止。这样就可以把键值等于要查找值的所有节点都找出来。</p>
<div align="center">
<img src="http://cdn.wangng.com/DataStructureAndAlgorithm/24%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%8B%EF%BC%89/24_6.png"></div>

<p>对于删除操作，我们也需要先查找到每个要删除的节点，然后再按前面讲的删除操作的方法，依次删除。</p>
<div align="center">
<img src="http://cdn.wangng.com/DataStructureAndAlgorithm/24%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%8B%EF%BC%89/24_7.png"></div>

<h3 id="二叉查找树的时间复杂度分析"><a href="#二叉查找树的时间复杂度分析" class="headerlink" title="二叉查找树的时间复杂度分析"></a>二叉查找树的时间复杂度分析</h3><p>实际上，二叉查找树的形态各式各样。比如这个图中，对于同一组数据，我们构造了三种二叉查找树。它们的查找、插入、删除操作的执行效率都是不一样的。图中第一种二叉查找树，根节点的左右子树极度不平衡，已经退化成了链表，所以查找的时间复杂度就变成了 O(n)。</p>
<div align="center">
<img src="http://cdn.wangng.com/DataStructureAndAlgorithm/24%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%8B%EF%BC%89/24_8.png"></div>

<p>　　分析了一种最糟糕的情况，我们现在来分析一个最理想的情况，二叉查找树是一棵完全二叉树（或满二叉树）。从前面的例子、图，以及还有代码来看，<strong>不管操作是插入、删除还是查找，时间复杂度其实都跟树的高度成正比，也就是 O(height)</strong>。既然这样，现在问题就转变成另外一个了，也就是，如何求一棵包含 n 个节点的完全二叉树的高度？</p>
<p>　　树的高度就等于最大层数减一，为了方便计算，我们转换成层来表示。从图中可以看出，包含 n 个节点的完全二叉树中，第一层包含 1 个节点，第二层包含 2 个节点，第三层包含 4 个节点，依次类推，下面一层节点个数是上一层的 2 倍，第 K 层包含的节点个数就是$2^{(K-1)}$。不过，对于完全二叉树来说，最后一层的节点个数有点儿不遵守上面的规律了。它包含的节点个数在 1 个到$2^{(L-1)}$ 个之间（我们假设最大层数是 L）。如果我们把每一层的节点个数加起来就是总的节点个数 n。也就是说，如果节点的个数是 n，那么 n 满足这样一个关系：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n &gt;&#x3D; 1+2+4+8+...+2^(L-2)+1</span><br><span class="line">n &lt;&#x3D; 1+2+4+8+...+2^(L-2)+2^(L-1)</span><br></pre></td></tr></table></figure><br>　　借助等比数列的求和公式，我们可以计算出，L 的范围是$[log_2(n+1), log_2(n) +1]$。完全二叉树的层数小于等于 $log_2(n) +1$，也就是说，完全二叉树的高度小于等于 $log_2(n)$。</p>
<p>　　显然，极度不平衡的二叉查找树，它的查找性能肯定不能满足我们的需求。我们需要构建一种不管怎么删除、插入数据，在任何时候，都能保持任意节点左右子树都比较平衡的二叉查找树，这就是我们下一节课要详细讲的，一种特殊的二叉查找树，平衡二叉查找树。平衡二叉查找树的高度接近 logn，所以插入、删除、查找操作的时间复杂度也比较稳定，是 O(logn)。</p>
<h3 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h3><p>　　我们之前学过散列表的插入、删除、查找操作的时间复杂度可以做到常量级的 O(1)，非常高效。而二叉查找树在比较平衡的情况下，插入、删除、查找操作时间复杂度才是 O(logn)，相对散列表，好像并没有什么优势，<font color="blue" size="3">那我们为什么还要用二叉查找树呢？</font><br>解答:有以下几点原因</p>
<ul>
<li>第一，散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，我们只需要中序遍历，就可以在 O(n) 的时间复杂度内，输出有序的数据序列。</li>
<li>第二，散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 O(logn)。</li>
<li>第三，笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。</li>
<li>第四，散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。</li>
<li>最后，为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。</li>
</ul>
<p>综合这几点，平衡二叉查找树在某些方面还是优于散列表的，所以，这两者的存在并不冲突。</p>
<h3 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h3><p>　针对二叉树,学习二叉树的快速查找,插入和删除操作.叉查找树中，每个节点的值都大于左子树节点的值，小于右子树节点的值。不过，这只是针对没有重复数据的情况。对于存在重复数据的二叉查找树，有两种构建方法，一种是让每个节点存储多个值相同的数据；另一种是，每个节点中存储一个数据。针对这种情况，我们只需要稍加改造原来的插入、删除、查找操作即可。</p>
<p>　　在二叉查找树中，查找、插入、删除等很多操作的<strong>时间复杂度都跟树的高度成正比</strong>。两个极端情况的时间复杂度分别是 O(n) 和 O(logn)，分别对应二叉树退化成链表的情况和完全二叉树。</p>
<p>为了避免时间复杂度的退化，针对二叉查找树，我们又设计了一种更加复杂的树，平衡二叉查找树，时间复杂度可以做到稳定的 O(logn)，后面会学到.</p>
<h3 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h3><p>如何通过编程，求出一棵给定二叉树的确切高度呢？</p>
<blockquote>
<p>解答:确定二叉树高度有两种思路：第一种是深度优先思想的递归，分别求左右子树的高度。当前节点的高度就是左右子树中较大的那个+1；第二种可以采用层次遍历的方式，每一层记录都记录下当前队列的长度，这个是队尾，每一层队头从0开始。然后每遍历一个元素，队头下标+1。直到队头下标等于队尾下标。这个时候表示当前层遍历完成。每一层刚开始遍历的时候，树的高度+1。最后队列为空，就能得到树的高度。</p>
</blockquote>
]]></content>
      <categories>
        <category>DataStructureAndAlgorithm</category>
      </categories>
      <tags>
        <tag>Binary tree</tag>
      </tags>
  </entry>
  <entry>
    <title>25红黑树（上）：为什么工程中都用红黑树这种二叉树？</title>
    <url>/articles/79d0637c.html/</url>
    <content><![CDATA[<blockquote>
<p>声名：本文大部分内容出自于极客时间网站王争的专栏《数据结构与算法之美》，这里本人主要记录自己的学习过程，添加个人见解，并作为自己的学习笔记。如有侵权，立马删除。</p>
</blockquote>
<a id="more"></a>
<h3 id="问题导向"><a href="#问题导向" class="headerlink" title="问题导向"></a>问题导向</h3><p>　　我们学习了了树、二叉树、二叉查找树。二叉查找树是最常用的一种二叉树，它支持快速插入、删除、查找操作，各个操作的时间复杂度跟树的高度成正比，理想情况下，时间复杂度是O(logn)。不过，二叉查找树在频繁的动态更新过程中，可能会出现树的高度远大于log2n 的情况，从而导致各个操作的效率下降。极端情况下，二叉树会退化为链表，时间复杂度会退化到O(n).为此我们需要设计一种<strong>平衡二叉查找树</strong>,红黑树时平衡二叉查找树种的一个常见例子,工程中也经常用到.所以现在问题是<font color="red" size="3">为什么工程中都喜欢用红黑树，而不是其他平衡二叉查找树呢？</font></p>
<h3 id="什么是“平衡二叉查找树”？"><a href="#什么是“平衡二叉查找树”？" class="headerlink" title="什么是“平衡二叉查找树”？"></a>什么是“平衡二叉查找树”？</h3><p><strong>平衡二叉树的严格定义是这样的：二叉树中任意一个节点的左右子树的高度相差不能大于 1。</strong>我们学习过的完全二叉树、满二叉树其实都是平衡二叉树，但是非完全二叉树也有可能是平衡二叉树。<br><img src="/articles/79d0637c.html/平衡二叉树.png" alt><br>平衡二叉查找树不仅满足上面平衡二叉树的定义，还满足二叉查找树的特点。最先被发明的平衡二叉查找树是<a href="https://zh.wikipedia.org/wiki/AVL%E6%A0%91" target="_blank" rel="noopener">AVL</a>树，它严格符合平衡二叉查找树的定义，即任何节点的左右子树高度相差不超过 1，是一种高度平衡的二叉查找树。</p>
<p>但是很多平衡二叉查找树其实并没有严格符合上面的定义（树中任意一个节点的左右子树的高度相差不能大于 1)，比如红黑树，它从根节点到各个叶子节点的最长路径，有可能会比最短路径大一倍。发明平衡二叉查找树这类数据结构的初衷是，解决普通二叉查找树在频繁的插入、删除等动态更新的情况下，出现时间复杂度退化的问题。</p>
<p>所以，平衡二叉查找树中“平衡”的意思，其实就是让整棵树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些。</p>
<p>所以，如果我们现在设计一个新的平衡二叉查找树，只要树的高度不比 log2n 大很多（比如树的高度仍然是对数量级的），尽管它不符合我们前面讲的严格的平衡二叉查找树的定义，但我们仍然可以说，这是一个合格的平衡二叉查找树。</p>
<h3 id="如何定义一棵“红黑树”？"><a href="#如何定义一棵“红黑树”？" class="headerlink" title="如何定义一棵“红黑树”？"></a>如何定义一棵“红黑树”？</h3><p>平衡二叉查找树其实有很多，比如，Splay Tree（伸展树）、Treap（树堆）等，但是我们提到平衡二叉查找树，听到的基本都是红黑树。它的出镜率甚至要高于“平衡二叉查找树”这几个字，有时候，我们甚至默认平衡二叉查找树就是红黑树.红黑树的英文是“Red-Black Tree”，简称 R-B Tree。它是一种不严格的平衡二叉查找树，我们如何定义一棵红黑树?</p>
<p>顾名思义，红黑树中的节点，一类被标记为黑色，一类被标记为红色。除此之外，一棵红黑树还需要满足这样几个要求：</p>
<p>根节点是黑色的；每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；</p>
]]></content>
      <categories>
        <category>DataStructureAndAlgorithm</category>
      </categories>
      <tags>
        <tag>Binary tree</tag>
      </tags>
  </entry>
</search>
